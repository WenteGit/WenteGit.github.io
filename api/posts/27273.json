{"title":"Redis","slug":"Redis","date":"2022-08-22","updated":"2022-08-22","comments":true,"path":"api/posts/27273.json","excerpt":"<blockquote><p> 介绍了关于 Redis 的相关内容 </p></blockquote>","cover":null,"covers":null,"content":"<blockquote>\n<p>介绍了关于 Redis 的相关内容</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"缓存注解\"><a href=\"# 缓存注解\" class=\"headerlink\" title=\"缓存注解\"></a>缓存注解 </h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CacheConfig</span></span><br><span class=\"line\"> 是一个类级别的注解，允许共享缓存的名称。</span><br><span class=\"line\">一个类可能会有多个缓存操作而这些缓存操作可能是重复的，这时候可以使用<span class=\"meta\">@CacheConfig</span>.</span><br></pre></td></tr></table></figure>\n<blockquote>\n<hr>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable</span></span><br><span class=\"line\">* 代表从缓存中查询指定的 key，如果有，从缓存中取，不再执行方法。</span><br><span class=\"line\">* 如果没有则执行方法，并且将方法的返回值和指定的 key 关联起来，放入到缓存中。</span><br><span class=\"line\"></span><br><span class=\"line\">主要参数：</span><br><span class=\"line\">* value : 缓存的名称，在 spring 配置中定义，必须指定至少一个。</span><br><span class=\"line\">* key: 缓存的 key，可以为空，如果指定要按照 spel 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合。</span><br><span class=\"line\">* condition: 缓存的条件，可以为空，使用 spek 编写，返回 <span class=\"literal\">true</span> 或<span class=\"literal\">false</span>, 只有为 <span class=\"literal\">true</span> 使才进行缓存。</span><br><span class=\"line\"></span><br><span class=\"line\">Example:</span><br><span class=\"line\"><span class=\"meta\">@Cacheable(value=&quot;thisredis&quot;, key=&quot;&#x27;users_&#x27;+#id&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> User <span class=\"title function_\">findUser</span><span class=\"params\">(Integer id)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<hr>\n<p>如果在类上配置了 @CacheConfig, 那么此时 @Cacheable 中的 value 就会取代 @CacheConfig 中 cacheNames。<br>如果在类上配置了 @CacheConfig(cacheNames = “ “), 在该类下的 @Cacheable 中可以不用配置 value。</p>\n<hr>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CacheEvict</span></span><br><span class=\"line\">标记在方法上，方法执行完毕之后根据条件或 key 删除对应的缓存。</span><br><span class=\"line\"></span><br><span class=\"line\">Example:</span><br><span class=\"line\"><span class=\"meta\">@CacheEvict(value=&quot;thisredis&quot;,   key=&quot;&#x27;users_&#x27;+#id&quot;,condition=&quot;#id!=1&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">delUser</span><span class=\"params\">(Integer id)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">主要参数：</span><br><span class=\"line\">allEntries : 布尔类型 表示是否需要清除缓存中的所有元素。</span><br><span class=\"line\">key: 需要删除的缓存的 key</span><br><span class=\"line\"></span><br><span class=\"line\">当我们在更新数据库的数据时，要使用 <span class=\"meta\">@CacheEvict</span>，需要把 redis 的缓存清空，否则查询的数据就是 redis 缓存中的数据，这样就会导致数据库和缓存数据不一致的问题。（页面不能及时的同步更新后的数据）。</span><br><span class=\"line\"></span><br><span class=\"line\"> 加上<span class=\"meta\">@CacehEvict</span> 就会在查询数据时发现数据时最新的，与数据库保持一致。</span><br></pre></td></tr></table></figure>","url":"/posts/27273/","min2read":1,"word4post":489,"prev_post":null,"next_post":{"title":"IDEA_Hotkeys","url":"/posts/10026/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"缓存注解\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">缓存注解 </span></a></li></ol>","categories":[],"tags":[{"name":"Redis","path":"api/tags/Redis.json","url":"/tags/Redis/"}]}