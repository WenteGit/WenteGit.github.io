{"title":"JUC","slug":"JavaJUC","date":"2022-09-11","updated":"2022-11-12","comments":true,"path":"api/posts/30559.json","excerpt":"<blockquote><p> 主要总结了关于 JUC 的相关知识点 </p></blockquote>","cover":null,"covers":null,"content":"<blockquote>\n<p>主要总结了关于 JUC 的相关知识点</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"随记\"><a href=\"# 随记\" class=\"headerlink\" title=\"随记\"></a>随记</h1><blockquote>\n<ul>\n<li>volatile ： 强制每个线程到主存去获取数据而不是去 Cache</li>\n</ul>\n</blockquote>\n<h2 id=\"JUC 辅助类\"><a href=\"#JUC 辅助类\" class=\"headerlink\" title=\"JUC 辅助类\"></a>JUC 辅助类</h2><h3 id=\"CountDownLatch- 减少计数\"><a href=\"#CountDownLatch- 减少计数\" class=\"headerlink\" title=\"CountDownLatch(减少计数)\"></a>CountDownLatch(减少计数)</h3><blockquote>\n<ul>\n<li>使用场景： 多个线程互相等待都执行完毕之后，统一执行主线程</li>\n</ul>\n</blockquote>\n<h3 id=\"CyclicBarrier- 循环栅栏\"><a href=\"#CyclicBarrier- 循环栅栏\" class=\"headerlink\" title=\"CyclicBarrier(循环栅栏)\"></a>CyclicBarrier(循环栅栏)</h3><blockquote>\n<ul>\n<li>使用场景： 多个线程互相等待都执行完毕之后，统一执行另一线程</li>\n</ul>\n</blockquote>\n<h3 id=\"Semaphore- 信号灯\"><a href=\"#Semaphore- 信号灯\" class=\"headerlink\" title=\"Semaphore(信号灯)\"></a>Semaphore(信号灯)</h3><blockquote>\n<ul>\n<li>使用场景： 类似于线程池，多个线程抢夺有限个执行机会(锁的机制)</li>\n</ul>\n</blockquote>\n<h1 id=\"锁\"><a href=\"# 锁\" class=\"headerlink\" title=\"锁\"></a>锁 </h1><h2 id=\"无锁\"><a href=\"# 无锁\" class=\"headerlink\" title=\"无锁\"></a> 无锁</h2><blockquote>\n<p>多线程争夺资源，很乱</p>\n</blockquote>\n<h2 id=\"普通锁\"><a href=\"# 普通锁\" class=\"headerlink\" title=\"普通锁\"></a>普通锁</h2><blockquote>\n<p>使用 synchronized 和 ReentrantLock (都是独占锁)</p>\n</blockquote>\n<h2 id=\"读写锁 -ReentrantReadWriteLock\"><a href=\"# 读写锁 -ReentrantReadWriteLock\" class=\"headerlink\" title=\"读写锁 ReentrantReadWriteLock\"></a>读写锁 ReentrantReadWriteLock</h2><blockquote>\n<ul>\n<li>读读可以共享，支持多人读，可以提升性能</li>\n<li>写锁还是一个线程独占的</li>\n<li><em>缺点:</em>*<br>1, 造成锁饥饿，一直读却没有写<br>2, 同一线程读锁的情况下不能再写锁(可能会死锁)，但是同一线程写锁的情况下还可以去读锁</li>\n<li>锁降级：写锁可以降级为读锁，读锁不能升级为写锁 : 即同一线程读的时候不能写，但写的时候可以读</li>\n</ul>\n</blockquote>\n<h2 id=\"锁的介绍\"><a href=\"# 锁的介绍\" class=\"headerlink\" title=\"锁的介绍\"></a>锁的介绍</h2><blockquote>\n<ul>\n<li>自旋锁：自旋，jvm 默认是 10 次吧，有 jvm 自己控制。for 去争取锁</li>\n<li>自旋锁的其他种类</li>\n<li>阻塞锁：被阻塞的线程，不会争夺锁。</li>\n<li>可重入锁： 多次进入改锁的域</li>\n<li>读写锁</li>\n<li>互斥锁：锁本身就是互斥的</li>\n<li>悲观锁：不相信，这里会是安全的，必须全部上锁</li>\n<li>乐观锁：相信，这里是安全的。</li>\n<li>公平锁：有优先级的锁</li>\n<li>非公平锁：无优先级的锁</li>\n<li>偏向锁：无竞争不锁，有竞争挂起，转为轻量锁</li>\n<li>对象锁：锁住对象</li>\n<li>线程锁</li>\n<li>锁粗化：多锁变成一个，自己处理</li>\n<li>轻量级锁：CAS 实现</li>\n<li>锁消除：偏向锁就是锁消除的一种</li>\n<li>锁膨胀：jvm 实现，锁粗化</li>\n<li>信号量: 使用阻塞锁 实现的一种策略</li>\n</ul>\n</blockquote>\n<h1 id=\"阻塞队列\"><a href=\"# 阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h1><ul>\n<li>放入  |  取出  |     取队首元素 |    触发  </li>\n<li>add   | remove  |   element |    抛异常  </li>\n<li>offer |  poll   |     peek  |     返回 Bool  </li>\n<li>put   |  take    |     无   |     处于阻塞状态，一直处于运行  </li>\n<li>offer(e,time,unit) |  poll(time,unit)  这种方式的可设置阻塞时间，如果超过设置时  间，则返回 Bool</li>\n</ul>\n<h1 id=\"创建线程的多种方式：\"><a href=\"# 创建线程的多种方式：\" class=\"headerlink\" title=\"创建线程的多种方式：\"></a>创建线程的多种方式：</h1><ul>\n<li>1, 继承 Thread 类 ：参数不可传入 Callable</li>\n<li>2, 实现 Runnable 接口</li>\n<li>3, 通过 Callable 接口</li>\n<li>4, 通过线程池的方式来创建接口</li>\n</ul>\n<h1 id=\"Runnable（Thread 默认）与 Callable 接口的比较\"><a href=\"#Runnable（Thread 默认）与 Callable 接口的比较\" class=\"headerlink\" title=\"Runnable（Thread 默认）与 Callable 接口的比较\"></a>Runnable（Thread 默认）与 Callable 接口的比较</h1><p>  1, 返回值（R 无，C 有）<br>  2, 是否会抛出异常(R 无，C 有)<br>  3,Callable 和 Runnable 都是函数式接口，都可以使用 lambada 表达式<br>  4, 实现方法名称:  </p>\n<ul>\n<li>Runnable: run 方法  </li>\n<li>Callable: call 方法  </li>\n</ul>\n<blockquote>\n<hr>\n<p>  Runnable 接口有个实现类：FutureTask  </p>\n</blockquote>\n<ul>\n<li>FutureTask 构造可以传递 Callable, 有 Callable 的构造方法  </li>\n<li>FutureTask 可以先单开线程去做其他事情，最后汇总，汇总只需要一次  </li>\n<li>FutureTask 实际上是构造方法既能传入 Callable、也可以传入 Runnable  </li>\n</ul>\n<h1 id=\"线程池\"><a href=\"# 线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池 </h1><h2 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h2><h2 id=\"随记 -1\"><a href=\"# 随记 -1\" class=\"headerlink\" title=\"随记\"></a> 随记</h2><blockquote>\n<ul>\n<li>当阻塞队列和核心线程都满了之后，如果还有线程，将直接优先处理刚来的线程而不是处理阻塞队列里面的线程</li>\n</ul>\n</blockquote>\n<h3 id=\"参数\"><a href=\"# 参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 核心线程</span></span><br><span class=\"line\">&gt;<span class=\"type\">int</span> corePoolSize, </span><br><span class=\"line\">&gt;- - -</span><br><span class=\"line\"><span class=\"comment\">// 最大线程数量</span></span><br><span class=\"line\">&gt;<span class=\"type\">int</span> maximumPoolSize,</span><br><span class=\"line\">&gt;- - -</span><br><span class=\"line\"><span class=\"comment\">// 存活时间及其单位</span></span><br><span class=\"line\">&gt;<span class=\"type\">long</span> keepAliveTime,</span><br><span class=\"line\">&gt;TimeUnit unit,</span><br><span class=\"line\">&gt;- - -</span><br><span class=\"line\"><span class=\"comment\">// 阻塞队列 : 线程排队用的</span></span><br><span class=\"line\">&gt;BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">&gt;- - -</span><br><span class=\"line\"><span class=\"comment\">// 线程工厂：用于创建线程</span></span><br><span class=\"line\">&gt;ThreadFactory threadFactory,</span><br><span class=\"line\">&gt;- - -</span><br><span class=\"line\"><span class=\"comment\">// 拒绝策略 : 该线程池无法为其他线程提供服务了</span></span><br><span class=\"line\">&gt;RejectedExecutionHandler handler</span><br></pre></td></tr></table></figure>\n<h2 id=\"Executors\"><a href=\"#Executors\" class=\"headerlink\" title=\"Executors\"></a>Executors</h2><blockquote>\n<p>阿里开发规范已经不支持使用 Executors 了，而使用 ThreadPoolExecutor 代替</p>\n</blockquote>\n<h3 id=\"一池 -N- 线程\"><a href=\"# 一池 -N- 线程\" class=\"headerlink\" title=\"一池 N 线程\"></a>一池 N 线程</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"一池一线程\"><a href=\"# 一池一线程\" class=\"headerlink\" title=\"一池一线程\"></a>一池一线程</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService1</span> <span class=\"operator\">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动根据需要创建线程，可扩容，遇强则强\"><a href=\"# 自动根据需要创建线程，可扩容，遇强则强\" class=\"headerlink\" title=\"自动根据需要创建线程，可扩容，遇强则强\"></a>自动根据需要创建线程，可扩容，遇强则强</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService2</span> <span class=\"operator\">=</span> Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四种拒绝策略\"><a href=\"# 四种拒绝策略\" class=\"headerlink\" title=\"四种拒绝策略\"></a>四种拒绝策略</h3><blockquote>\n<ul>\n<li>AbortPolicy(默认): 直接抛出 Rejected 的异常</li>\n<li>CallerRunsPolicy: 将任务回退到调用者</li>\n<li>DiscardOldestPolicy: 抛弃队列中等待最久的任务，然后将当前任务加入到队列中，尝试再次提交当前任务</li>\n<li>DiscardPlicy : 默默丢弃无法处理的任务，不予处理也不抛出任何异常，如果运行任务丢失，这将是最好的策略</li>\n</ul>\n</blockquote>\n","url":"/posts/30559/","min2read":3,"word4post":"1.1k","prev_post":{"title":"sqlServer_command","url":"/posts/27698/"},"next_post":{"title":"theAlgorithm","url":"/posts/26841/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"随记\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">随记</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"JUC 辅助类\" href = \"#\"><span class=\"toc-number\">1.1.</span> <span class=\"toc-text\">JUC 辅助类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"CountDownLatch- 减少计数\" href = \"#\"><span class=\"toc-number\">1.1.1.</span> <span class=\"toc-text\">CountDownLatch(减少计数)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"CyclicBarrier- 循环栅栏\" href = \"#\"><span class=\"toc-number\">1.1.2.</span> <span class=\"toc-text\">CyclicBarrier(循环栅栏)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"Semaphore- 信号灯\" href = \"#\"><span class=\"toc-number\">1.1.3.</span> <span class=\"toc-text\">Semaphore(信号灯)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"锁\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">锁 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"无锁\" href = \"#\"><span class=\"toc-number\">2.1.</span> <span class=\"toc-text\"> 无锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"普通锁\" href = \"#\"><span class=\"toc-number\">2.2.</span> <span class=\"toc-text\">普通锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"读写锁 -ReentrantReadWriteLock\" href = \"#\"><span class=\"toc-number\">2.3.</span> <span class=\"toc-text\">读写锁 ReentrantReadWriteLock</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"锁的介绍\" href = \"#\"><span class=\"toc-number\">2.4.</span> <span class=\"toc-text\">锁的介绍</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"阻塞队列\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\">阻塞队列</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"创建线程的多种方式：\" href = \"#\"><span class=\"toc-number\">4.</span> <span class=\"toc-text\">创建线程的多种方式：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"Runnable（Thread 默认）与 Callable 接口的比较\" href = \"#\"><span class=\"toc-number\">5.</span> <span class=\"toc-text\">Runnable（Thread 默认）与 Callable 接口的比较</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"线程池\" href = \"#\"><span class=\"toc-number\">6.</span> <span class=\"toc-text\">线程池 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"ThreadPoolExecutor\" href = \"#\"><span class=\"toc-number\">6.1.</span> <span class=\"toc-text\">ThreadPoolExecutor</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"随记 -1\" href = \"#\"><span class=\"toc-number\">6.2.</span> <span class=\"toc-text\"> 随记</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"参数\" href = \"#\"><span class=\"toc-number\">6.2.1.</span> <span class=\"toc-text\">参数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"Executors\" href = \"#\"><span class=\"toc-number\">6.3.</span> <span class=\"toc-text\">Executors</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"一池 -N- 线程\" href = \"#\"><span class=\"toc-number\">6.3.1.</span> <span class=\"toc-text\">一池 N 线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"一池一线程\" href = \"#\"><span class=\"toc-number\">6.3.2.</span> <span class=\"toc-text\">一池一线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"自动根据需要创建线程，可扩容，遇强则强\" href = \"#\"><span class=\"toc-number\">6.3.3.</span> <span class=\"toc-text\">自动根据需要创建线程，可扩容，遇强则强</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"四种拒绝策略\" href = \"#\"><span class=\"toc-number\">6.3.4.</span> <span class=\"toc-text\">四种拒绝策略</span></a></li></ol></li></ol></li></ol>","categories":[{"name":"JavaStudy","path":"api/categories/JavaStudy.json","url":"/categories/JavaStudy/"}],"tags":[{"name":"JUC","path":"api/tags/JUC.json","url":"/tags/JUC/"}]}