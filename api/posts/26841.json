{"title":"theAlgorithm","slug":"theAlgorithm","date":"2022-09-08","updated":"2022-09-08","comments":true,"path":"api/posts/26841.json","excerpt":"<blockquote><p> 算法总结 </p></blockquote>","cover":null,"covers":null,"content":"<blockquote>\n<p>算法总结</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<blockquote>\n<h1 id=\"全排列\"><a href=\"# 全排列\" class=\"headerlink\" title=\"全排列\"></a>全排列</h1></blockquote>\n<h2 id=\"将字符串中的每个字母转变大小写 - 返回所有可能得到的字符串集合\"><a href=\"# 将字符串中的每个字母转变大小写 - 返回所有可能得到的字符串集合\" class=\"headerlink\" title=\"将字符串中的每个字母转变大小写, 返回所有可能得到的字符串集合\"></a>将字符串中的每个字母转变大小写, 返回所有可能得到的字符串集合 </h2><p><strong> 算法思路：</strong><br>如果下一个字符 c 是字母，将当前已遍历过的字符串全排列复制两份。<br>在第一份的每个字符串末尾添加 lowercase(c)，在第二份的每个字符串末尾添加 uppercase(c)。<br>如果下一个字符 c 是数字，将 c 直接添加到每个字符串的末尾。  </p>\n<p><strong>编程语言: Python</strong></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">letterCasePermutation</span>(<span class=\"params\">self, S</span>):</span><br><span class=\"line\">        ans = [[]]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> S:</span><br><span class=\"line\">            n = <span class=\"built_in\">len</span>(ans)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> char.isalpha():</span><br><span class=\"line\">                <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> xrange(n):</span><br><span class=\"line\">                    ans.append(ans[i][:])</span><br><span class=\"line\">                    ans[i].append(char.lower())</span><br><span class=\"line\">                    ans[n+i].append(char.upper())</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> xrange(n):</span><br><span class=\"line\">                    ans[i].append(char)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<h1 id=\"DFS- 深度优先\"><a href=\"#DFS- 深度优先\" class=\"headerlink\" title=\"DFS 深度优先\"></a>DFS 深度优先 </h1><h1 id=\"BFS- 广度优先\"><a href=\"#BFS- 广度优先\" class=\"headerlink\" title=\"BFS 广度优先\"></a>BFS 广度优先</h1><h1 id=\"递归与回溯\"><a href=\"# 递归与回溯\" class=\"headerlink\" title=\"递归与回溯\"></a> 递归与回溯 </h1><p> 题目描述:<br>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;ans;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt;temp;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">combine</span>(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>, n, k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 1 2 3 4</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> cur,<span class=\"type\">int</span> n,<span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 如果当前 temp 的大小为 s，未确定状态的区间[cur,n] 的长度为 t，如果 s + t &lt; ks+t&lt;k</span></span><br><span class=\"line\"><span class=\"comment\">// 那么即使 tt 个都被选中，也不可能构造出一个长度为 k 的序列</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp.<span class=\"built_in\">size</span>() + (n - cur + <span class=\"number\">1</span>) &lt; k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp.<span class=\"built_in\">size</span>() == k) &#123;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(temp);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        temp.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(cur + <span class=\"number\">1</span>, n, k);</span><br><span class=\"line\">        temp.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(cur + <span class=\"number\">1</span>, n,k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h1 id=\"二分查找\"><a href=\"# 二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找 </h1><h1 id=\"双指针\"><a href=\"# 双指针\" class=\"headerlink\" title=\"双指针\"></a> 双指针 </h1><h1 id=\"滑动窗口\"><a href=\"# 滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a> 滑动窗口</h1><h1 id=\"DP 动态规划\"><a href=\"#DP 动态规划\" class=\"headerlink\" title=\"DP 动态规划\"></a>DP 动态规划</h1></blockquote>\n<h2 id=\"各个房间内都有一定的现金，相邻的房间不可同时偷，求最好的偷取方案。\"><a href=\"# 各个房间内都有一定的现金，相邻的房间不可同时偷，求最好的偷取方案。\" class=\"headerlink\" title=\"各个房间内都有一定的现金，相邻的房间不可同时偷，求最好的偷取方案。\"></a>各个房间内都有一定的现金，相邻的房间不可同时偷，求最好的偷取方案。</h2><p><strong>算法思路：</strong><br>依次保存偷当前房间的话，算上之前的一共能偷到的总金额 <br><strong> 编程语言：C++</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rob</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums.<span class=\"built_in\">size</span>() == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>] &gt; nums[<span class=\"number\">1</span>] ? nums[<span class=\"number\">0</span>] : nums[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(nums.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            dp[i] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">2</span>] + nums[i], dp[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"给定一个三角形 -triangle-，找出自底向上求的最小路径和。\"><a href=\"# 给定一个三角形 -triangle-，找出自底向上求的最小路径和。\" class=\"headerlink\" title=\"给定一个三角形 triangle ，找出自底向上求的最小路径和。\"></a>给定一个三角形 triangle ，找出自底向上求的最小路径和。</h2><p><strong>算法思路</strong></p>\n<blockquote>\n<p>从倒数第二排开始，每次将该层的元素的下一层的相邻元素的最小的保存到该层元素，逐层返回到最顶层，则最顶层保存的就是最小路径  </p>\n</blockquote>\n<p><strong>编程语言：C++</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> size = triangle.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = size <span class=\"number\">-2</span>; i &gt;=<span class=\"number\">0</span> ; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; triangle[i].<span class=\"built_in\">size</span>(); j++) &#123;</span><br><span class=\"line\">                triangle[i][j] += <span class=\"built_in\">min</span>(triangle[i + <span class=\"number\">1</span>][j], triangle[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> triangle[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<h1 id=\"可用数组装链表，这样就可以让每一个链表都有一个下标了\"><a href=\"# 可用数组装链表，这样就可以让每一个链表都有一个下标了\" class=\"headerlink\" title=\"可用数组装链表，这样就可以让每一个链表都有一个下标了\"></a>可用数组装链表，这样就可以让每一个链表都有一个下标了</h1></blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ListNode</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, val=<span class=\"number\">0</span>, <span class=\"built_in\">next</span>=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">        self.val = val</span><br><span class=\"line\">        self.<span class=\"built_in\">next</span> = <span class=\"built_in\">next</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">reorderList</span>(<span class=\"params\">self, head: ListNode</span>) -&gt; <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> head:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        vec = <span class=\"built_in\">list</span>()</span><br><span class=\"line\">        node = head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> node:</span><br><span class=\"line\">            vec.append(node)</span><br><span class=\"line\">            node = node.<span class=\"built_in\">next</span></span><br><span class=\"line\">        i, j = <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(vec) - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; j:</span><br><span class=\"line\">            vec[i].<span class=\"built_in\">next</span> = vec[j]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == j:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            vec[j].<span class=\"built_in\">next</span> = vec[i]</span><br><span class=\"line\">            j -= <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        vec[i].<span class=\"built_in\">next</span> = <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Cpp 综合积累\"><a href=\"#Cpp 综合积累\" class=\"headerlink\" title=\"Cpp 综合积累\"></a>Cpp 综合积累</h1><blockquote>\n<h2 id=\"函数方法\"><a href=\"# 函数方法\" class=\"headerlink\" title=\"函数方法\"></a>函数方法</h2></blockquote>\n<h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><blockquote>\n<p>vector 也可以当做栈来使用 <br> 如下：pop_back 表示出栈，push_back 表示入栈<br>arr.back 表示获取栈顶元素<br>arr.front 表示获取栈底元素或者叫做队列头元素</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt;arr = &#123; <span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">arr.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">cout&lt;&lt;arr.<span class=\"built_in\">back</span>();</span><br><span class=\"line\">cout &lt;&lt; arr.<span class=\"built_in\">front</span>();</span><br></pre></td></tr></table></figure>\n<h2 id=\"关键字\"><a href=\"# 关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><h3 id=\"new 关键字\"><a href=\"#new 关键字\" class=\"headerlink\" title=\"new 关键字\"></a>new 关键字</h3><blockquote>\n<p>new 关键字可用作 new 一个新的对象出来，并返回一个指针类型的变量指向该对象，可以 new 类，也可以 new 结构体</p>\n</blockquote>\n","url":"/posts/26841/","min2read":4,"word4post":925,"prev_post":null,"next_post":{"title":"Redis","url":"/posts/27273/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"全排列\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">全排列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"将字符串中的每个字母转变大小写 - 返回所有可能得到的字符串集合\" href = \"#\"><span class=\"toc-number\">1.1.</span> <span class=\"toc-text\">将字符串中的每个字母转变大小写, 返回所有可能得到的字符串集合 </span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"DFS- 深度优先\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">DFS 深度优先 </span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"BFS- 广度优先\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\">BFS 广度优先</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"递归与回溯\" href = \"#\"><span class=\"toc-number\">4.</span> <span class=\"toc-text\"> 递归与回溯 </span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"二分查找\" href = \"#\"><span class=\"toc-number\">5.</span> <span class=\"toc-text\">二分查找 </span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"双指针\" href = \"#\"><span class=\"toc-number\">6.</span> <span class=\"toc-text\"> 双指针 </span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"滑动窗口\" href = \"#\"><span class=\"toc-number\">7.</span> <span class=\"toc-text\"> 滑动窗口</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"DP 动态规划\" href = \"#\"><span class=\"toc-number\">8.</span> <span class=\"toc-text\">DP 动态规划</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"各个房间内都有一定的现金，相邻的房间不可同时偷，求最好的偷取方案。\" href = \"#\"><span class=\"toc-number\">8.1.</span> <span class=\"toc-text\">各个房间内都有一定的现金，相邻的房间不可同时偷，求最好的偷取方案。</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"给定一个三角形 -triangle-，找出自底向上求的最小路径和。\" href = \"#\"><span class=\"toc-number\">8.2.</span> <span class=\"toc-text\">给定一个三角形 triangle ，找出自底向上求的最小路径和。</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"可用数组装链表，这样就可以让每一个链表都有一个下标了\" href = \"#\"><span class=\"toc-number\">9.</span> <span class=\"toc-text\">可用数组装链表，这样就可以让每一个链表都有一个下标了</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"Cpp 综合积累\" href = \"#\"><span class=\"toc-number\">10.</span> <span class=\"toc-text\">Cpp 综合积累</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"函数方法\" href = \"#\"><span class=\"toc-number\">10.1.</span> <span class=\"toc-text\">函数方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"vector\" href = \"#\"><span class=\"toc-number\">10.1.1.</span> <span class=\"toc-text\">vector</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"关键字\" href = \"#\"><span class=\"toc-number\">10.2.</span> <span class=\"toc-text\">关键字</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"new 关键字\" href = \"#\"><span class=\"toc-number\">10.2.1.</span> <span class=\"toc-text\">new 关键字</span></a></li></ol></li></ol></li></ol>","categories":[{"name":"Algorithm","path":"api/categories/Algorithm.json","url":"/categories/Algorithm/"}],"tags":[{"name":"MyAlgorithm","path":"api/tags/MyAlgorithm.json","url":"/tags/MyAlgorithm/"}]}