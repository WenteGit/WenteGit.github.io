{"title":"Caffeine","slug":"TechStack-Caffeine","date":"2022-11-11","updated":"2023-01-15","comments":true,"path":"api/posts/46615.json","excerpt":"<blockquote><p> 本文主要介绍了关于 Caffeine 的用法，仅限于如何使用 Caffeine</p></blockquote>","cover":null,"covers":null,"content":"<blockquote>\n<p>本文主要介绍了关于 Caffeine 的用法，仅限于如何使用 Caffeine</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"Caffeine 简介\"><a href=\"#Caffeine 简介\" class=\"headerlink\" title=\"Caffeine 简介\"></a>Caffeine 简介</h1><blockquote>\n<p>Caffeine 是一种在本地进行本地缓存的缓存库，可以使用它来搭建本地缓存 <br> 可使用它构建本地缓存 +Redis 的多级缓存机制<br>Caffeine 提供了四种缓存添加策略：</p>\n<ul>\n<li>手动加载</li>\n<li>自动加载</li>\n<li>手动异步加载</li>\n<li>自动异步加载</li>\n</ul>\n</blockquote>\n<h1 id=\"手动加载\"><a href=\"# 手动加载\" class=\"headerlink\" title=\"手动加载\"></a>手动加载</h1> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">              <span class=\"comment\">// 设置数据过期时间</span></span><br><span class=\"line\">              .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.MINUTES)</span><br><span class=\"line\">              <span class=\"comment\">// 设置数据的最大长度</span></span><br><span class=\"line\">              .maximumSize(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">              .build();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;key1&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 根据 key 查找一个缓存元素， 没有查找到的时候返回 null</span></span><br><span class=\"line\">              <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> cache.getIfPresent(key);</span><br><span class=\"line\">      <span class=\"comment\">// 根据 key 查找缓存，如果缓存存在，则返回对应缓存值，如果缓存不存在则生成缓存元素, 如果无法生成则返回 nul</span></span><br><span class=\"line\">              <span class=\"type\">String</span> <span class=\"variable\">value2</span> <span class=\"operator\">=</span> cache.get(key, <span class=\"built_in\">this</span>::createValueByKey);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 添加一个缓存元素</span></span><br><span class=\"line\">              cache.put(<span class=\"string\">&quot;key2&quot;</span>,<span class=\"string\">&quot;xtzl&quot;</span>);</span><br><span class=\"line\">              <span class=\"type\">String</span> <span class=\"variable\">value_key2</span> <span class=\"operator\">=</span> cache.getIfPresent(<span class=\"string\">&quot;key2&quot;</span>);</span><br><span class=\"line\">              Assertions.assertEquals(<span class=\"string\">&quot;xtzl&quot;</span>,value_key2);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 移除一个缓存元素</span></span><br><span class=\"line\">              cache.invalidate(<span class=\"string\">&quot;key2&quot;</span>);</span><br><span class=\"line\">              value_key2 = cache.getIfPresent(<span class=\"string\">&quot;key2&quot;</span>);</span><br><span class=\"line\">              Assertions.assertNull(value_key2);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没查到缓存之后生成缓存元素的方法, 生成并自动加入到 Cache 中</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String <span class=\"title function_\">createValueByKey</span><span class=\"params\">(String key)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> key+<span class=\"string\">&quot;_value&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"自动加载\"><a href=\"# 自动加载\" class=\"headerlink\" title=\"自动加载\"></a>自动加载</h1> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    LoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">            .maximumSize(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">            .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.MINUTES)</span><br><span class=\"line\">            .build(<span class=\"built_in\">this</span>::createExpensiveGraph);</span><br><span class=\"line\">    <span class=\"comment\">// 往缓存中存入数据</span></span><br><span class=\"line\">        cache.put(<span class=\"string\">&quot;key2&quot;</span>,<span class=\"string\">&quot;value2&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 查找缓存，若存在则返回对应缓存值，如果缓存不存在则调用指定方法生成指定缓存值,  如果无法生成则返回 null</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">val_key1</span> <span class=\"operator\">=</span> cache.get(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">val_key2</span> <span class=\"operator\">=</span> cache.get(<span class=\"string\">&quot;key2&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 批量查找缓存，如果缓存不存在则生成缓存元素</span></span><br><span class=\"line\">        <span class=\"comment\">// 模拟加入多个缓存元素</span></span><br><span class=\"line\">        List&lt;String&gt; cacheKeyList= <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            cache.put(<span class=\"string\">&quot;k&quot;</span> + i,<span class=\"string\">&quot;v&quot;</span> + i);</span><br><span class=\"line\">            cacheKeyList.add(<span class=\"string\">&quot;k&quot;</span>+i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Map&lt;String, String&gt; cacheAll = cache.getAll(cacheKeyList);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 验证是否正常生成</span></span><br><span class=\"line\">        Assertions.assertEquals(<span class=\"string\">&quot;key1_cache_value&quot;</span>, val_key1);</span><br><span class=\"line\">        Assertions.assertEquals(<span class=\"string\">&quot;value2&quot;</span>,val_key2);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            Assertions.assertEquals(<span class=\"string\">&quot;v&quot;</span>+i,cacheAll.get(<span class=\"string\">&quot;k&quot;</span>+i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> String <span class=\"title function_\">createExpensiveGraph</span><span class=\"params\">(String key)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> key+<span class=\"string\">&quot;_cache_value&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"手动加载与自动加载的区别\"><a href=\"# 手动加载与自动加载的区别\" class=\"headerlink\" title=\"手动加载与自动加载的区别\"></a>手动加载与自动加载的区别</h1><blockquote>\n<ul>\n<li>手动加载在 Caffeine.newBuilder()中未指定创建缓存值的方法</li>\n<li>手动加载将 getIfPresent() 和 get()方法区分开</li>\n<li>手动加载在 get()方法需要指定创建缓存值的方法    </li>\n</ul>\n</blockquote>\n<blockquote>\n<p>总结：<br> 个人感觉还是自动加载方便。因为在 build 我们的 Cache 的时候就已经指定了创建缓存值的方法</p>\n</blockquote>\n<h1 id=\"手动异步加载\"><a href=\"# 手动异步加载\" class=\"headerlink\" title=\"手动异步加载\"></a>手动异步加载 </h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestManualAsynchronous</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">        AsyncCache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">                .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.MINUTES)</span><br><span class=\"line\">                .maximumSize(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">                .buildAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;key1&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 查找一个缓存元素， 没有查找到的时候返回 null</span></span><br><span class=\"line\">            CompletableFuture&lt;String&gt; key_value = cache.getIfPresent(key);</span><br><span class=\"line\">        <span class=\"comment\">// 查找缓存元素，如果不存在，则异步生成对应 key 的缓存值</span></span><br><span class=\"line\">            CompletableFuture&lt;String&gt; key_get_value = cache.get(key, <span class=\"built_in\">this</span>::createExpensiveGraph);</span><br><span class=\"line\">        <span class=\"comment\">// 添加或者更新一个缓存元素</span></span><br><span class=\"line\">            cache.put(key, key_get_value);</span><br><span class=\"line\">        <span class=\"comment\">// 移除一个缓存元素</span></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; key3_value = cache.get(<span class=\"string\">&quot;key3&quot;</span>, <span class=\"built_in\">this</span>::createExpensiveGraph);</span><br><span class=\"line\">        cache.put(<span class=\"string\">&quot;key3&quot;</span>,key3_value);</span><br><span class=\"line\">        <span class=\"comment\">// 也要先转成同步的之后才移除</span></span><br><span class=\"line\">        cache.synchronous().invalidate(<span class=\"string\">&quot;key3&quot;</span>); </span><br><span class=\"line\">        CompletableFuture&lt;String&gt; key3_del = cache.getIfPresent(<span class=\"string\">&quot;key3&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 验证</span></span><br><span class=\"line\">        Assertions.assertNull(key_value);</span><br><span class=\"line\">        <span class=\"comment\">// join() 或者 get()方法是得到字符串类型的值</span></span><br><span class=\"line\">        Assertions.assertEquals(<span class=\"string\">&quot;key1_value&quot;</span>,key_get_value.join()); </span><br><span class=\"line\">        Assertions.assertNull(key3_del);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 根据 key 创建对应的缓存元素，并自动加入到缓存 Cache 中</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">createExpensiveGraph</span><span class=\"params\">(String key)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key+<span class=\"string\">&quot;_value&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"自动异步加载\"><a href=\"# 自动异步加载\" class=\"headerlink\" title=\"自动异步加载\"></a>自动异步加载</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">    AsyncLoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">            .maximumSize(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">            .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.MINUTES)</span><br><span class=\"line\">            <span class=\"comment\">// 你可以选择: 去异步的封装一段同步操作来生成缓存元素</span></span><br><span class=\"line\">            .buildAsync(<span class=\"built_in\">this</span>::createExpensiveGraph);</span><br><span class=\"line\">        <span class=\"comment\">/** 也可以选择: 构建一个异步缓存元素操作并返回一个 future</span></span><br><span class=\"line\"><span class=\"comment\">            .buildAsync((key, executor) -&gt; createExpensiveGraphAsync(key, executor));</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;key1&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 查找缓存元素，如果其不存在，将会异步进行生成</span></span><br><span class=\"line\">    CompletableFuture&lt;String&gt; key1_value = cache.get(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 批量查找缓存元素，如果其不存在，将会异步进行生成</span></span><br><span class=\"line\">    String [] keys = &#123;<span class=\"string\">&quot;k1&quot;</span>,<span class=\"string\">&quot;k2&quot;</span>,<span class=\"string\">&quot;k3&quot;</span>&#125;;</span><br><span class=\"line\">    List&lt;String&gt; keysList = Arrays.asList(keys);</span><br><span class=\"line\">    CompletableFuture&lt;Map&lt;String, String&gt;&gt; keys_values_map = cache.getAll(keysList);</span><br><span class=\"line\">    <span class=\"comment\">// 将 CompletableFuture 类型获取到其中的 Map</span></span><br><span class=\"line\">    Map&lt;String, String&gt; map = keys_values_map.get();</span><br><span class=\"line\">    <span class=\"comment\">// 将 Map 中的元素提取成 Set 集合，元素为 Entry 类型，并使用 Set 集合的迭代器迭代遍历</span></span><br><span class=\"line\">    Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class=\"line\">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entries.iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (iterator.hasNext())&#123;</span><br><span class=\"line\">        Map.Entry&lt;String, String&gt; next = iterator.next();</span><br><span class=\"line\">        System.out.println(next.getKey());</span><br><span class=\"line\">        System.out.println(next.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String <span class=\"title function_\">createExpensiveGraph</span><span class=\"params\">(String key)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> key+<span class=\"string\">&quot;_value&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"同步和异步的差别\"><a href=\"# 同步和异步的差别\" class=\"headerlink\" title=\"同步和异步的差别\"></a>同步和异步的差别</h1><blockquote>\n<ul>\n<li>移除缓存元素，同步直接调用 invalidate()就可移除，异步需要先使用 synchronous()转成同步之后才能调用 invalidate()移除元素</li>\n<li>get() 和 getIfPresent()方法在同步中直接返回的是缓存值，在异步方法中返回的是 CompletableFuture 类型的数据，CompletableFuture 类型的数据需要执行 join()或者 get()方法才能获取到真正的缓存值</li>\n</ul>\n</blockquote>\n<h1 id=\"CacheLoader\"><a href=\"#CacheLoader\" class=\"headerlink\" title=\"CacheLoader\"></a>CacheLoader</h1><blockquote>\n<p>CacheLoader 共可实现 6 个方法</p>\n<ul>\n<li>load</li>\n<li>loadall</li>\n<li>asyncload</li>\n<li>asyncloadall</li>\n<li>reload</li>\n<li>asyncReload</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LoadingCache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span><br><span class=\"line\">       .maximumSize(<span class=\"number\">10_000</span>)</span><br><span class=\"line\">       .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.MINUTES)</span><br><span class=\"line\">       .build(<span class=\"keyword\">new</span> <span class=\"title class_\">CacheLoader</span>&lt;String, Object&gt;() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"comment\">// 调用 get 方法，若在缓存未命中，则生成一个缓存值</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Object <span class=\"title function_\">load</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String s)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> s + <span class=\"string\">&quot;_value&quot;</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"注解的使用\"><a href=\"# 注解的使用\" class=\"headerlink\" title=\"注解的使用\"></a>注解的使用 </h1><h2 id=\"引入依赖\"><a href=\"# 引入依赖\" class=\"headerlink\" title=\"引入依赖\"></a> 引入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>caffeine<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"常用注解\"><a href=\"# 常用注解\" class=\"headerlink\" title=\"常用注解\"></a>常用注解</h2><blockquote>\n<hr>\n</blockquote>\n<ul>\n<li>@Cacheable：表示该方法支持缓存。当调用被注解的方法时，如果对应的键已经存在缓存，则不再执行方法体，而从缓存中直接返回。当方法返回 null 时，将不进行缓存操作。<blockquote>\n<hr>\n</blockquote>\n</li>\n<li>@CachePut：表示执行该方法后，其值将作为最新结果更新到缓存中，每次都会执行该方法。<blockquote>\n<hr>\n</blockquote>\n</li>\n<li>@CacheEvict：表示执行该方法后，将触发缓存清除操作。<blockquote>\n<hr>\n</blockquote>\n</li>\n<li>@Caching：用于组合前三个注解，例如：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Caching(cacheable = @Cacheable(&quot;CacheConstants.GET_USER&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">         evict = &#123;@CacheEvict(&quot;CacheConstants.GET_DYNAMIC&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">         allEntries = true)&#125;)</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<hr>\n</blockquote>\n<h1 id=\"多级缓存 - 二级缓存 - 的逻辑实现图\"><a href=\"# 多级缓存 - 二级缓存 - 的逻辑实现图\" class=\"headerlink\" title=\"多级缓存 (二级缓存) 的逻辑实现图\"></a>多级缓存 (二级缓存) 的逻辑实现图</h1><blockquote>\n<ul>\n<li>要求一级缓存的数据过期时间要比二级缓存短</li>\n<li>我的项目中，Caffeine 缓存时间是 30s，redis 缓存时间是 3 分钟<img src = \"http://xtzl.wentexl.cn/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E9%80%BB%E8%BE%91.png\"/></li>\n</ul>\n</blockquote>\n</li>\n</ul>\n","url":"/posts/46615/","min2read":7,"word4post":"1.6k","prev_post":{"title":"Sqlserver-Grant","url":"/posts/20431/"},"next_post":{"title":"Sqlserver_TSQL","url":"/posts/4967/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"Caffeine 简介\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">Caffeine 简介</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"手动加载\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">手动加载</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"自动加载\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\">自动加载</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"手动加载与自动加载的区别\" href = \"#\"><span class=\"toc-number\">4.</span> <span class=\"toc-text\">手动加载与自动加载的区别</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"手动异步加载\" href = \"#\"><span class=\"toc-number\">5.</span> <span class=\"toc-text\">手动异步加载 </span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"自动异步加载\" href = \"#\"><span class=\"toc-number\">6.</span> <span class=\"toc-text\">自动异步加载</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"同步和异步的差别\" href = \"#\"><span class=\"toc-number\">7.</span> <span class=\"toc-text\">同步和异步的差别</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"CacheLoader\" href = \"#\"><span class=\"toc-number\">8.</span> <span class=\"toc-text\">CacheLoader</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"注解的使用\" href = \"#\"><span class=\"toc-number\">9.</span> <span class=\"toc-text\">注解的使用 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"引入依赖\" href = \"#\"><span class=\"toc-number\">9.1.</span> <span class=\"toc-text\"> 引入依赖</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"常用注解\" href = \"#\"><span class=\"toc-number\">9.2.</span> <span class=\"toc-text\">常用注解</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"多级缓存 - 二级缓存 - 的逻辑实现图\" href = \"#\"><span class=\"toc-number\">10.</span> <span class=\"toc-text\">多级缓存 (二级缓存) 的逻辑实现图</span></a></li></ol>","categories":[{"name":"TechStack","path":"api/categories/TechStack.json","url":"/categories/TechStack/"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json","url":"/tags/Cache/"}]}