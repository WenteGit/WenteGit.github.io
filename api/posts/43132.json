{"title":"Transaction","slug":"boot_Transaction","date":"2022-08-02","updated":"2022-08-03","comments":true,"path":"api/posts/43132.json","excerpt":"<blockquote><p> 该文主要介绍了关于 SpringBoot 的事务管理的相关知识点 </p></blockquote>","cover":"http://xtzl.wentexl.cn/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E8%A7%84%E5%88%99.png","covers":["http://xtzl.wentexl.cn/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E8%A7%84%E5%88%99.png"],"content":"<blockquote>\n<p>该文主要介绍了关于 SpringBoot 的事务管理的相关知识点</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"核心\"><a href=\"# 核心\" class=\"headerlink\" title=\"核心\"></a>核心</h1><blockquote>\n<ul>\n<li>Spring 并不直接管理事务，而是通过各种事务管理器来调用特定平台的事务实现</li>\n<li>spring 统一管理事务，把不同的数据库访问技术的事务处理统一起来</li>\n<li>已经 commit 的事务是不能 rollback 的</li>\n</ul>\n</blockquote>\n<h1 id=\"常用的事务管理器\"><a href=\"# 常用的事务管理器\" class=\"headerlink\" title=\"常用的事务管理器\"></a>常用的事务管理器</h1><blockquote>\n<ul>\n<li>DataSourceTransactionManager：用于 JDBC 的持久化支持，也可用于 IBATIS</li>\n<li>HibernateTransactionManager：用于 Hibernate3 的持久化支持</li>\n<li>JpaTransactionManager：用于 Java 持久化 API 的持久化支持</li>\n<li>JtaTransactionManager：主要用于分布式事务的支持</li>\n</ul>\n</blockquote>\n<h1 id=\"事务的传播行为 ProPagation\"><a href=\"# 事务的传播行为 ProPagation\" class=\"headerlink\" title=\"事务的传播行为 ProPagation\"></a>事务的传播行为 ProPagation</h1><blockquote>\n<p><strong>事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式 </strong><br> 优秀博文:<a href=\"http://t.csdn.cn/TgggY\">http://t.csdn.cn/TgggY</a><br><strong>重点：</strong></p>\n<ul>\n<li>PROPAGATION_REQUIRED : 表示当前方法必须运行在事务中，若当前存在事务，则在原有事务中运行，否则创建一个新的事务。</li>\n</ul>\n<hr>\n<ul>\n<li>PROPAGATION_REQUIRES_NEW :  新建事务，如果当前存在事务，把当前事务挂起。</li>\n</ul>\n<hr>\n<ul>\n<li>PROPAGATION_SUPPORTS : 如果当前有事务，则使用事务，如果当前没有事务，就以非事务方式执行</li>\n</ul>\n<hr>\n<ul>\n<li>Propagation.NOT_SUPPORTED :  以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li>\n</ul>\n<hr>\n<hr>\n<p><strong>次要:</strong></p>\n<ul>\n<li>PROPAGATION_MANDATORY ：表示该方法必须在事务中运行，若当前事务不存在则抛异常。举例来说，一个 service 方法调用了两个 dao 方法，那么在执行其中的一个 dao 方法时，都要求已经启动了事务，否则需要抛异常。</li>\n</ul>\n<hr>\n<ul>\n<li>PROPAGATION_NESTED : 表示若当前已存在一个事务，那么该方法将在嵌套事务中运行。嵌套事务可以独立于当前事务进行提交或回滚，若当前事务不存在，则该传播行为与 PROPAGATION_REQUIRED 一样。举例来说，一个 service 方法中调用了某 dao 方法，并且根据该 dao 方法执行的成功或失败区分了两套处理逻辑，这时候若 dao 执行失败，它只要保证不对数据库数据有任何影响（通过 rollback）就可以了，不需要回滚整个 service 方法，故这个 dao 方法需要在嵌套事务中运行。</li>\n</ul>\n<hr>\n<ul>\n<li>PROPAGATION_NEVER : 表示当前方法不应该运行在事务中，若当前已经有一个事务在运行，则抛异常。这种适用于在某些 dao 操作中，它要求之前的事务已经结束，而它本身的操作结果不会受到其他 dao 操作结果的影响（比如被其他操作所 rollback）。</li>\n</ul>\n<hr>\n<ul>\n<li>PROPAGATION_NOT_SUPPORTED : 表示当前方法不应该运行在事务中，若当前已经有一个事务在运行，则将其挂起。</li>\n</ul>\n</blockquote>\n<h1 id=\"事务并发可能导致的错误\"><a href=\"# 事务并发可能导致的错误\" class=\"headerlink\" title=\"事务并发可能导致的错误\"></a>事务并发可能导致的错误</h1><blockquote>\n<ul>\n<li>脏读：某事务读取了其他事务未提交的数据后，其他事务又将其数据回滚，导致该事务使用了无效的数据。</li>\n</ul>\n<hr>\n<ul>\n<li>不可重复读：某事务执行两次相同的查询操作，但是由于在这两次操作中间存在其他事务更新了数据，从而导致两次查询的结果不一致。</li>\n</ul>\n<hr>\n<ul>\n<li>幻读 ：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 删除或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候真实的数据集已经发生了变化，但是 A 却查询不出来这种变化，因此产生了幻读。</li>\n</ul>\n<hr>\n</blockquote>\n<h1 id=\"Spring 提供的事务隔离 isolation\"><a href=\"#Spring 提供的事务隔离 isolation\" class=\"headerlink\" title=\"Spring 提供的事务隔离 isolation\"></a>Spring 提供的事务隔离 isolation</h1><blockquote>\n<p>若通过相关互斥机制保证事务的绝对隔离，则会很大程度影响并发的性能，最差情况就相当于事务是串行地执行。为了尽可能避免这些问题、权衡性能以及提高事务隔离的灵活性，Spring 定义了五种隔离级别，以允许应用程序自己决定所能接受的、被其他事务所影响的程度。</p>\n<hr>\n<ul>\n<li>ISOLATION_DEFAULT : 使用底层数据库默认的隔离级别。</li>\n</ul>\n<hr>\n<ul>\n<li>ISOLATION_READ_UNCOMMITTED : 允许读取未提交的数据，这可能导致脏读、不可重复读和幻读。</li>\n</ul>\n<hr>\n<ul>\n<li>ISOLATION_READ_COMMITTED ：允许读取已提交的数据，这可以避免脏读，但是还是可能导致不可重复读和幻读。</li>\n</ul>\n<hr>\n<ul>\n<li>ISOLATION_REPEATABLE_READ : 对同一字段的多次读取结果是一致的，除非由本事务自己更新，这可以避免不可重复读和脏读，但是还是可能导致幻读。</li>\n</ul>\n<hr>\n<ul>\n<li>ISOLATION_SERIALIZABLE：完全按照 ACID 所要求的，可以避免脏读、不可重复读和幻读。注意：这种事务隔离级别的效率最差，因为它经常需要将事务相关的表进行加锁，锁粒度大。</li>\n</ul>\n<hr>\n<p><img src=\"http://xtzl.wentexl.cn/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E8%A7%84%E5%88%99.png\" alt=\"事务\"></p>\n</blockquote>\n","url":"/posts/43132/","min2read":4,"word4post":"1.2k","prev_post":{"title":"SpringAop","url":"/posts/21566/"},"next_post":{"title":"Seata","url":"/posts/63021/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"核心\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">核心</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"常用的事务管理器\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">常用的事务管理器</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"事务的传播行为 ProPagation\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\">事务的传播行为 ProPagation</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"事务并发可能导致的错误\" href = \"#\"><span class=\"toc-number\">4.</span> <span class=\"toc-text\">事务并发可能导致的错误</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"Spring 提供的事务隔离 isolation\" href = \"#\"><span class=\"toc-number\">5.</span> <span class=\"toc-text\">Spring 提供的事务隔离 isolation</span></a></li></ol>","categories":[{"name":"SpringBoot","path":"api/categories/SpringBoot.json","url":"/categories/SpringBoot/"}],"tags":[{"name":"Transaction","path":"api/tags/Transaction.json","url":"/tags/Transaction/"}]}