{"title":"Interview-MeiTuan","slug":"Interview-MeiTuan","date":"2023-03-16","updated":"2023-03-18","comments":true,"path":"api/posts/41865.json","excerpt":"<blockquote><p> 关于美团的面试，及其面经积累 </p></blockquote>","cover":null,"covers":null,"content":"<blockquote>\n<p>关于美团的面试，及其面经积累</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"Java 八股文\"><a href=\"#Java 八股文\" class=\"headerlink\" title=\"Java 八股文\"></a>Java 八股文</h1><h2 id=\"Java 及 Web 基础\"><a href=\"#Java 及 Web 基础\" class=\"headerlink\" title=\"Java 及 Web 基础\"></a>Java 及 Web 基础</h2><ol>\n<li>元空间: Java 8 中引入了元空间的概念，将类元数据存储在本地内存中，而不再是永久代。这种方式使得类元数据的管理更加灵活和高效，可以避免永久代出现的问题，如内存溢出、GC 时间过长等。</li>\n<li>常用的状态码：200、301、302、401、403、404、500</li>\n<li>Get、Post、Put 的区别<ul>\n<li>GET 不安全，请求参数在 URL，明文传输</li>\n<li>POST 数据在请求体，加密传输</li>\n<li>PUT 向服务器更新或创建资源</li>\n</ul>\n</li>\n<li>Cookie 和 Session 的区别<ul>\n<li>存储位置：Cookie 是保存在客户端浏览器中的，而 Session 是保存在服务器端的。</li>\n<li>安全性：Cookie 中的数据可以被客户端浏览器拦截并篡改，因此不适合保存敏感数据，而 Session 保存在服务器端，可以保证数据的安全性。</li>\n<li>存储容量：Cookie 存储容量比较小，通常只能存储几 KB 的数据，而 Session 存储容量较大，可以存储几 MB 的数据。</li>\n<li>生命周期：Cookie 有一个过期时间，如果没有设置过期时间，则默认为浏览器关闭时失效，而 Session 的生命周期由服务器管理，默认情况下，Session 在 30 分钟内无任何操作时会失效。</li>\n</ul>\n</li>\n<li></li>\n</ol>\n<h2 id=\"Spring 全家桶框架\"><a href=\"#Spring 全家桶框架\" class=\"headerlink\" title=\"Spring 全家桶框架\"></a>Spring 全家桶框架</h2><ol>\n<li><p>SpringIOC 和 SpringAOP 的原理</p>\n<ul>\n<li>IOC<ul>\n<li>DI 依赖注入: 通过构造函数、属性或方法参数等方式，将一个对象所依赖的其他对象传递给它，而不是由这个对象自己去创建或查找依赖的对象。这样做的好处是，我们可以更灵活地管理和替换这些依赖</li>\n<li>IC 控制反转: 控制反转的核心思想是将对象的创建和管理交给容器或框架，而不是由程序员自己手动创建和管理对象。这样做的好处是可以将对象的生命周期和作用域管理交给框架或容器，从而避免了一些常见的问题，比如对象的重复创建、对象的生命周期管理等等。</li>\n</ul>\n</li>\n<li>AOP<ul>\n<li>面向切面的技术：所谓“切面”，简单说就是那些与业务无关，却被业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Spring 的三级缓存</p>\n<ul>\n<li>一级缓存：存放已经创建完成的 Bean</li>\n<li>二级缓存：存放早起创建但是未填充属性的 Bean</li>\n<li>三级缓存：存放 ObjectFactory 这样的 Bean 的工厂对象，负责动态的创建和管理 Bean</li>\n<li>主要通过三级缓存可解决循环依赖、Bean 的重复创建等问题</li>\n</ul>\n</li>\n<li><p>占位符</p>\n<ul>\n<li>‘#’ : #占位符会对输入的参数值进行类型转换，防止 SQL 注入攻击。</li>\n<li>‘$’ : $ 占位符在 SQL 语句中直接替换成输入的参数值，它不会对输入的参数值进行类型转换，也不会防止 SQL 注入攻击<h2 id=\"JUC\"><a href=\"#JUC\" class=\"headerlink\" title=\"JUC\"></a>JUC</h2></li>\n</ul>\n</li>\n<li><p>Synchronized 的锁升级</p>\n<ul>\n<li>偏向锁：线程 A 第一次竞争到资源，加的是偏向锁,MarkWord 存的是偏向线程 ID，之后只需检查是否是偏向线程访问即可，效率最高。</li>\n<li>轻量级锁：线程 B 来和线程 A 竞争资源且竞争成功，则偏向锁切换偏向线程，竞争失败，则偏向锁升级为轻量级锁, 轻量级锁本质就是自旋锁 CAS</li>\n<li>重量级锁：大量线程参与竞争或 CAS 多次自旋未成功，升级为重量级锁，效率最低</li>\n</ul>\n</li>\n<li><p>线程池</p>\n<ul>\n<li>七大参数<ul>\n<li>核心线程数 corePoolSize </li>\n<li>最大线程数 maximumPoolSize   </li>\n<li>空闲线程的存活时间 keepAliveTime </li>\n<li>存活时间单位 TimeUnit</li>\n<li>阻塞队列 workQueue </li>\n<li>线程工厂 threadFactory </li>\n<li>拒绝策略 handler<ul>\n<li>抛出异常</li>\n<li>任务调回</li>\n<li>丢弃任务</li>\n<li>与最老任务竞争</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>参数设置<ul>\n<li>I/O 通常是对数据库的操作, 线程数如果不多的话，在处理 IO 的时候不能用 CPU，导致 CPU 的使用率较低。</li>\n<li>CPU 密集型：<ul>\n<li>核心线程 = CPU 核心</li>\n<li>最大线程 = CPU 核心 + 1</li>\n</ul>\n</li>\n<li>IO 密集型<ul>\n<li>核心线程 = 2*CPU 核心</li>\n<li>最大线程 = 2*CPU 核心 + 1</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>运行流程</li>\n</ul>\n</li>\n<li><p>volatile</p>\n<ul>\n<li>概念：”volatile”是一个关键字，用于指示一个变量是易变的，并且可能会被多个线程同时访问和修改。</li>\n<li>作用：<ul>\n<li>可见性：使用”volatile”关键字声明的变量，当一个线程修改该变量的值时，其他线程可以立即看到最新的值。</li>\n<li>禁止重排序：使用”volatile”关键字声明的变量，在读取和写入时会禁止编译器对其进行重排序，从而保证了指令的执行顺序。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线程的创建方式</p>\n<ul>\n<li>继承 Thread 类并重写 run()方法</li>\n<li>实现 Runnable 接口或者 Callable 接口</li>\n<li>使用线程池创建接口</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><ol>\n<li><p>垃圾回收算法</p>\n<ul>\n<li>标记清除算法: 这是一种最基本的垃圾回收算法。它的核心思想是先标记所有可达对象，然后清除所有未被标记的对象。标记和清除分别需要扫描整个堆，效率较低，同时可能会产生内存碎片。</li>\n<li>标记整理算法: 这种算法在标记阶段与标记 - 清除算法类似，但在清除阶段不是简单地删除未被标记的对象，而是将所有存活对象都向一端移动，然后将另一端的空间全部释放，从而避免了内存碎片的问题。</li>\n<li>复制算法: 这种算法将堆分为两个区域，每次只使用其中的一部分。当当前区域用完后，将存活对象复制到另一个区域中，然后将当前区域中的所有对象清除。复制算法的特点是效率高，但需要两倍的空间。</li>\n<li>分代算法: 这种算法认为对象的生命周期具有不同的阶段，将堆分为多个代，一般将新生代和老年代分开处理。新生代中的对象生命周期较短，采用复制算法；老年代中的对象生命周期较长，采用标记 - 整理算法。分代算法充分利用了对象的生命周期分布规律，提高了垃圾回收效率。</li>\n</ul>\n</li>\n<li><p>内存模型</p>\n<ul>\n<li><p>堆 (线程共享): 存储对象实例、为对象分配内存空间、GC 主要作用区域</p>\n</li>\n<li><p>方法区(线程共享): 存储类的元数据信息，如类名、方法名、字段名等。方法区还用于存储运行时常量池、静态变量、即时编译器编译后的代码等信息。</p>\n</li>\n<li><p>Java 虚拟机栈: 用于存放 Java 方法执行时的栈帧。每个栈帧包含局部变量表、动态链接、返回地址等信息。当线程调用 Java 方法时，JVM 会在 Java 虚拟机栈中为该方法分配一个栈帧，在方法返回时，该栈帧会被弹出并销毁。</p>\n</li>\n<li><p>本地方法栈: 本地方法栈和 Java 虚拟机栈类似，用于存储本地方法 (其他语言编写的) 的栈帧。</p>\n</li>\n<li><p>程序计数器: 用于指示 JVM 正在执行哪个线程的字节码指令</p>\n</li>\n<li><p>堆的分区</p>\n<ul>\n<li>新生代(1/3) : Eden(8/10) 幸存区 1(1/10) 幸存区 2(1/10)  [通常采用复制算法]</li>\n<li>老年代(2/3) : 存放存活时间较长的对象，这些对象可能是长时间存活的业务数据、缓存对象、连接池等 [通常采用标记整理算法]</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"数据库\"><a href=\"# 数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><ol>\n<li><p>四大特性(ACID)</p>\n<ul>\n<li>原子性 ： 每个操作不可再分</li>\n<li>一致性 ： 一个事务可以让数据从一种一致状态切换到另一种一致性状态</li>\n<li>隔离性 ： 事务并行执行互不影响，最后结果和串行执行的结果相同</li>\n<li>持久性 : 一个事务一旦被提交，在数据库中的改变就是永久的，提交后就不能再回滚</li>\n</ul>\n</li>\n<li><p>三大问题</p>\n<ul>\n<li>脏读：读到了未提交的数据</li>\n<li>不可重复读：同一个事务两次读到的数据值不同</li>\n<li>幻读：同一个事务两次读到的数据记录数量不同</li>\n</ul>\n</li>\n<li><p>隔离级别</p>\n<ul>\n<li>READ UNCOMMITTED: 读未提交</li>\n<li>READ COMMITTED: 读已提交</li>\n<li>REPEATABLE READ: 可重复读</li>\n<li>SERIALIZABLE: 可串行化</li>\n</ul>\n</li>\n<li><p>SQL 执行顺序</p>\n<ul>\n<li>from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt; order by -&gt; limit</li>\n</ul>\n</li>\n<li><p>事务的传播行为</p>\n</li>\n<li><p>MVCC 原理</p>\n<ul>\n<li>作用:<ul>\n<li>解决脏读、不可重复读的事务读写问题</li>\n<li>在保证隔离性的基础上，提升了读取效率和并发性</li>\n</ul>\n</li>\n<li>描述：在执行 Update 和 Delete 操作的时候，会将每次操作记录记录在 UndoLog 中, 每条记录都有唯一的事务 ID, 而 ReadView 记录了数据版本链的一些统计值，包括活跃事务集，当前事务 ID 等，然后通过四步判断法进行判断，遍历整个版本链，最终得到一个符合所有要求的数据版本。</li>\n<li>四步判断法：第一步主要判断是否是同一个读取的当前事务修改的数据，第二三步是判断是否是读到的未来的数据，第四步是判断是否是读的已提交的数据</li>\n<li>作用解释：因为保证了读到的都是已提交的数据，所以避免了脏读，因为同一个事务使用的都是同一个 Readview，所以保证同一个事务匹配到的是同一个版本的数据，所以避免了不可重复读的问题。</li>\n</ul>\n</li>\n<li><p>日志 Log</p>\n<ul>\n<li>binlog（二进制日志）：记录所有对 MySQL 数据库的更改操作，例如 INSERT、UPDATE、DELETE 等，以二进制格式存储。binlog 文件可以用于数据备份和恢复，数据复制和数据同步。</li>\n<li>undo log（回滚日志）：在事务中，如果执行了 UPDATE 或 DELETE 操作，MySQL 会先将修改前的数据记录到 undo log 中，然后再对数据进行修改。如果事务回滚，则 MySQL 可以使用 undo log 来撤销已经进行的修改。</li>\n<li>redo log（重做日志）：在事务中，MySQL 会先将对数据的修改记录到 redo log 中，然后再进行实际的修改。如果 MySQL 在执行修改操作后崩溃，MySQL 可以使用 redo log 来恢复数据。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><ul>\n<li>缓存故障<ul>\n<li>缓存穿透<ul>\n<li>概念：指一个存在的 key，在缓存过期的一刻，同时有大量的请求访问这个 key，由于缓存失效，请求会穿透缓存直接访问数据库，造成数据库压力过大。缓存击穿通常是由于缓存过期时间设置过短或者缓存中的数据过期策略不合理，导致大量的请求直接访问数据库。</li>\n<li>解决方法：可以通过布隆过滤器等方式，在缓存中添加一个不存在的数据时，先判断其是否存在于布隆过滤器中，如果不存在则直接返回，避免大量的请求直接访问数据库。</li>\n</ul>\n</li>\n<li>缓存击穿<ul>\n<li>概念：指一个存在的 key，在缓存过期的一刻，同时有大量的请求访问这个 key，由于缓存失效，请求会穿透缓存直接访问数据库，造成数据库压力过大。</li>\n<li>解决方案：可以采用永不过期的方式或者在缓存中添加短暂的二级缓存等方式来解决缓存击穿问题。</li>\n</ul>\n</li>\n<li>缓存雪崩<ul>\n<li>概念：指缓存中的大量数据同时过期失效，导致大量请求直接访问数据库，造成数据库压力过大。</li>\n<li>解决方案：可采用数据预热，提前将缓存数据加载到缓存中，还可以设置多级缓存, 还可采用使用分布式锁控制只有一个请求来重新加载缓存数据，避免缓存雪崩。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>数据库缓存一致性<ul>\n<li>双写模式: 通常使用的是“先更新数据库，再更新缓存”的顺序，以确保数据一致性。如果更新缓存失败，可以将缓存标记为失效，让下一次查询时重新从数据库中获取数据。(每次写入都要写入两个地方，可能造成读写操作变慢)</li>\n<li>延时双删：在更新数据库时，先将缓存中的数据标记为无效，然后等待一定时间后再删除缓存数据。(一定时候后才更新缓存，让数据库读写操作更快一点)</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>Redis 的持久化策略<ul>\n<li>RDB 持久化 : Redis 会周期性地将内存中的数据集快照写入磁盘，即生成一个 RDB 文件，可能会丢失最后一次快照以后的所有修改。</li>\n<li>AOF 持久化 : Redis 会将执行的每个写命令都记录到一个追加的文件中，在 Redis 重启时，会重新执行 AOF 文件中的所有写命令，以便恢复原始数据集，但会导致更高的磁盘空间占用和更慢的写入性能。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基础学科\"><a href=\"# 基础学科\" class=\"headerlink\" title=\"基础学科\"></a>基础学科 </h2><h3 id=\"数据结构\"><a href=\"# 数据结构\" class=\"headerlink\" title=\"数据结构\"></a> 数据结构</h3><ol>\n<li>HashMap 的原理<ul>\n<li>jdk1.7 与 jdk1.8 的区别：<ul>\n<li>1.7 是单链表，1.8 加入了红黑树</li>\n<li>1.7 是头插法，1.8 使用了尾插法，避免了环形链表死循环的问题</li>\n</ul>\n</li>\n<li>数据结构：数组 + 链表 + 红黑树<ul>\n<li>链表转红黑树条件：数组容量大于 64 且链表长度大于 8, 若数组容量不够则会扩容</li>\n</ul>\n</li>\n<li>线程不安全</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"计算机网络\"><a href=\"# 计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络 </h3><h3 id=\"操作系统\"><a href=\"# 操作系统\" class=\"headerlink\" title=\"操作系统\"></a> 操作系统</h3><ol>\n<li>进程和线程的区别<ul>\n<li>根本区别：进程是操作系统进行 <strong> 资源分配 </strong> 的最小单元，线程是操作系统进行 <strong> 运算调度 </strong> 的最小单元。</li>\n<li>从属关系不同：进程中包含了线程，线程属于进程。</li>\n<li>开销不同：进程的创建、销毁和切换的开销都远大于线程。</li>\n<li>拥有资源不同：每个进程有自己的内存和资源，一个进程中的线程会共享这些内存和资源。</li>\n<li>CPU 利用率不同：进程的 CPU 利用率较低，因为上下文切换开销较大，而线程的 CPU 的利用率较高，上下文的切换速度快。</li>\n</ul>\n</li>\n<li></li>\n</ol>\n<h1 id=\"项目积累\"><a href=\"# 项目积累\" class=\"headerlink\" title=\"项目积累\"></a>项目积累 </h1><h2 id=\"项目难点及解决方案\"><a href=\"# 项目难点及解决方案\" class=\"headerlink\" title=\"项目难点及解决方案\"></a> 项目难点及解决方案 </h2><h2 id=\"项目亮点\"><a href=\"# 项目亮点\" class=\"headerlink\" title=\"项目亮点\"></a> 项目亮点</h2>","url":"/posts/41865/","min2read":12,"word4post":"3.7k","prev_post":{"title":"","url":"/posts/0/"},"next_post":{"title":"BigData-HBase","url":"/posts/10071/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"Java 八股文\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">Java 八股文</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"Java 及 Web 基础\" href = \"#\"><span class=\"toc-number\">1.1.</span> <span class=\"toc-text\">Java 及 Web 基础</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"Spring 全家桶框架\" href = \"#\"><span class=\"toc-number\">1.2.</span> <span class=\"toc-text\">Spring 全家桶框架</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"JUC\" href = \"#\"><span class=\"toc-number\">1.3.</span> <span class=\"toc-text\">JUC</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"JVM\" href = \"#\"><span class=\"toc-number\">1.4.</span> <span class=\"toc-text\">JVM</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"数据库\" href = \"#\"><span class=\"toc-number\">1.5.</span> <span class=\"toc-text\">数据库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"MySQL\" href = \"#\"><span class=\"toc-number\">1.5.1.</span> <span class=\"toc-text\">MySQL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"Redis\" href = \"#\"><span class=\"toc-number\">1.5.2.</span> <span class=\"toc-text\">Redis</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"基础学科\" href = \"#\"><span class=\"toc-number\">1.6.</span> <span class=\"toc-text\">基础学科 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"数据结构\" href = \"#\"><span class=\"toc-number\">1.6.1.</span> <span class=\"toc-text\"> 数据结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"计算机网络\" href = \"#\"><span class=\"toc-number\">1.6.2.</span> <span class=\"toc-text\">计算机网络 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"操作系统\" href = \"#\"><span class=\"toc-number\">1.6.3.</span> <span class=\"toc-text\"> 操作系统</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"项目积累\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">项目积累 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"项目难点及解决方案\" href = \"#\"><span class=\"toc-number\">2.1.</span> <span class=\"toc-text\"> 项目难点及解决方案 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"项目亮点\" href = \"#\"><span class=\"toc-number\">2.2.</span> <span class=\"toc-text\"> 项目亮点</span></a></li></ol></li></ol>","categories":[{"name":"Interview","path":"api/categories/Interview.json","url":"/categories/Interview/"}],"tags":[]}