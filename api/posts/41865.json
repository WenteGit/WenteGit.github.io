{"title":"Interview","slug":"Interview","date":"2023-03-16","updated":"2023-10-13","comments":true,"path":"api/posts/41865.json","excerpt":"<blockquote><p> 面试八股文与项目介绍 </p></blockquote>","cover":"http://xtzl.wentexl.cn/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.png","covers":["http://xtzl.wentexl.cn/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.png"],"content":"<blockquote>\n<p>面试八股文与项目介绍</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"Java 八股文\"><a href=\"#Java 八股文\" class=\"headerlink\" title=\"Java 八股文\"></a>Java 八股文</h1><h2 id=\"Java 及 Web 基础\"><a href=\"#Java 及 Web 基础\" class=\"headerlink\" title=\"Java 及 Web 基础\"></a>Java 及 Web 基础</h2><ol>\n<li><p>元空间: Java 8 中引入了元空间的概念，将类元数据存储在本地内存中，而不再是永久代。这种方式使得类元数据的管理更加灵活和高效，可以避免永久代出现的问题，如内存溢出、GC 时间过长等。</p>\n</li>\n<li><p>Get、Post、Put 的区别</p>\n<ul>\n<li>数据位置：GET 方法将请求参数附加在 URL 的查询字符串中，而 POST 方法将请求参数放在请求的消息体中。由于 URL 长度的限制，GET 方法的参数传输通常会受到一定的限制。</li>\n<li>安全性：由于 GET 方法将请求参数暴露在 URL 中，因此请求的安全性较低，容易被攻击者截获和窃取。而 POST 方法将请求参数放在消息体中，相对来说更为安全。</li>\n<li>可缓存性：GET 方法通常可以被缓存，因为它的请求参数以及 URL 是不变的。而 POST 方法的请求参数会影响服务器的状态，不能被缓存。</li>\n<li>幂等性：GET 方法是幂等的，即多次请求同一个 URL 的结果相同，不会对服务器状态产生影响。而 POST 方法通常不是幂等的，多次请求同一个 URL 可能会导致服务器状态的改变。</li>\n<li>用途：GET 方法主要用于获取资源，POST 方法主要用于提交数据。例如，用 GET 方法可以请求一个 HTML 页面或图像文件，用 POST 方法可以提交一个表单。</li>\n<li>PUT 请求：<ul>\n<li>如果服务器上已经存在了一个资源，并且客户端发送了一个 PUT 请求，那么服务器将用客户端上传的新资源替换原有的资源。如果服务器上不存在该资源，则会创建一个新的资源。</li>\n<li>PUT 请求通常需要在请求头中指定上传的资源的 URI 和一些元数据，以便服务器正确处理请求。</li>\n<li>与 POST 请求不同，PUT 请求的请求体中通常包含完整的资源内容，而不是仅包含部分数据或请求参数。</li>\n<li>PUT 请求可能会导致服务器上的数据被覆盖或删除，因此在使用 PUT 请求时需要谨慎处理，避免意外修改或删除重要数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Cookie 和 Session 的区别</p>\n<ul>\n<li>存储位置：Cookie 是保存在客户端浏览器中的，而 Session 是保存在服务器端的。</li>\n<li>安全性：Cookie 中的数据可以被客户端浏览器拦截并篡改，因此不适合保存敏感数据，而 Session 保存在服务器端，可以保证数据的安全性。</li>\n<li>存储容量：Cookie 存储容量比较小，通常只能存储几 KB 的数据，而 Session 存储容量较大，可以存储几 MB 的数据。</li>\n<li>生命周期：Cookie 有一个过期时间，如果没有设置过期时间，则默认为浏览器关闭时失效，而 Session 的生命周期由服务器管理，默认情况下，Session 在 30 分钟内无任何操作时会失效。</li>\n</ul>\n</li>\n<li><p>动态代理</p>\n<ul>\n<li>jdk 动态代理 : 首先说适用场景吧，jdk 动态代理是适用于代理那些已经实现过接口的类，在执行其方法的前后，可以添加一些额外的逻辑。其具体的实现主要是通过 Java 的反射机制来动态地创建一个代理对象，这个代理对象需要拿到目标对象的引用及其接口的类信息，它会实现 InvocationHandler 接口，并通过 invoke 方法作为进入目标对象的目标方法的入口，由此呢，就可以在调用 invoke 方法之前实现调用目标方法前的逻辑，在调用 invoke 方法之后实现调用目标方法后的逻辑。</li>\n<li>cglib 动态代理: CGLIB 动态代理主要用于代理那些没有实现接口的类，它通过生成目标类的子类来实现代理。具体实现是使用了 ASM 字节码生成技术，来生成字节码并动态创建子类。通过继承目标类，代理类继承了目标类的行为，并重写了目标类的方法，以实现自定义的代理逻辑。</li>\n<li>对比：JDK 动态代理适用于代理已经实现了接口的类，而 CGLIB 动态代理则可以用于代理未实现接口的类，相比 JDK 动态代理，CGLIB 代理通常会稍微慢一些，因为它涉及到动态生成子类的过程。</li>\n<li>Spring 中的使用<ul>\n<li>SpringAoP(jdk 动态代理)：使用 jdk 动态代理来实现横切关注点的切入。通过代理生成机制，Spring 可以在运行时动态地为目标对象创建代理对象，并在目标对象的方法执行前后插入额外的逻辑，如日志记录、性能监控。</li>\n<li>事务管理(jdk 动态代理)：Spring 的声明式事务管理就是通过动态代理来实现的。通过在配置文件或注解中声明事务管理的规则，Spring 会在运行时为标记了事务注解的方法创建代理对象，在方法执行前后进行事务的开启、提交或回滚操作。</li>\n<li>缓存管理(cglib 动态代理)：Spring 的缓存管理模块也使用了动态代理。通过在方法上添加缓存注解，Spring 会在运行时为带有缓存注解的方法生成代理对象，并在方法执行前先从缓存中查找数据或将执行结果存入缓存中，从而提高系统的性能。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>面向对象和面向过程</p>\n<ul>\n<li>面向对象(Java): 将现实世界中的事物抽象成一个个对象，对象包括属性和方法。对象的属性用来描述对象的状态，方法用来描述对象的行为。在面向对象编程中，程序员将不同的对象进行组合，形成一个完整的系统。</li>\n<li>面向过程(C 语言): 是一种基于函数的编程方法，将一个大问题分解为一系列小问题，每个小问题都可以使用一个函数来解决。在面向过程编程中，程序员关注的是程序中的函数，函数之间通过参数传递数据，函数中的变量也只在函数内部有效。</li>\n</ul>\n</li>\n<li><p>Java 的四大引用</p>\n<ul>\n<li>强引用（Strong Reference）：当程序中存在一个强引用时，垃圾回收器将不会回收该对象，只有在该对象的所有强引用都被释放时，垃圾回收器才会将该对象回收。通常使用的对象都是强引用。</li>\n<li>软引用（Soft Reference）：软引用是一种比较弱化的强引用，当内存不足时，垃圾回收器会根据一定的策略（通常是 LRU 算法）来回收软引用所指向的对象。软引用通常用于实现内存敏感的缓存。</li>\n<li>弱引用（Weak Reference）：当一个对象只被弱引用引用时，垃圾回收器在进行垃圾回收时，如果该对象没有被任何强引用引用，那么就会将该对象回收。弱引用通常用于解决内存泄漏问题。</li>\n<li>虚引用（Phantom Reference）：虚引用是 Java 中最弱的一种引用类型，它的作用是在对象被垃圾回收器回收时，收到一个系统通知。虚引用通常用于跟踪对象被垃圾回收器回收的时机，或者在对象被回收时执行一些自定义的清理操作。</li>\n</ul>\n</li>\n<li><p>重写和重载</p>\n<ul>\n<li>重写<ul>\n<li>要求方法名，方法参数，方法返回值类型都要与父类相同，方法返回类型可以是被重写方法返回值类型的子类</li>\n<li>访问修饰符不能比被重写方法的访问修饰符更严格。例如，如果被重写方法是公共方法，则重写方法不能是私有方法。</li>\n<li>重写方法不能抛出更广泛的异常。如果被重写方法抛出一个异常，那么重写方法必须抛出相同的异常或其子类型异常。但是，重写方法可以抛出未检查的异常，即 RuntimeException 以及其子类型异常。</li>\n</ul>\n</li>\n<li>重载<ul>\n<li>同一个类中定义的多个方法，它们具有相同的方法名</li>\n<li>参数列表必须不同，返回类型可以不同</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>String、StringBuffer、StringBuilder</p>\n<ul>\n<li>可变性<ul>\n<li>String 是定长字符串，不可变</li>\n<li>StringBuffer 和 StringBuilder 可变</li>\n</ul>\n</li>\n<li>线程安全性<ul>\n<li>String 是定长字符串，线程安全</li>\n<li>StringBuffer 线程安全，因为每个操作都用 synchronized 同步关键字修饰</li>\n<li>StringBuilder 线程不安全</li>\n</ul>\n</li>\n<li>性能效率<ul>\n<li>String 的性能最低，因为每次发生字符串拼接和修改的时候，都需要创建新的对象和分配内存</li>\n<li>StringBuilder 在单线程的性能更高，多线程的性能低于 StringBuffer</li>\n</ul>\n</li>\n<li>存储位置<ul>\n<li>String 存储在字符串常量池</li>\n<li>StringBuffer 和 StringBuilder 存储在堆内存中</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Java 的 IO 模型</p>\n<ul>\n<li>IO 阻塞模型：当一个线程执行 IO 操作时，它将被阻塞，直到 IO 操作完成。在阻塞状态下，线程无法执行其他任务，因此一个线程只能处理一个 IO 操作。</li>\n<li>IO 非阻塞模型：当进行 IO 操作时，线程可以继续执行其他任务而不需要等待 IO 操作的完成，需要使用循环轮询的方式不断地检查 IO 操作的状态，以确定是否已经完成</li>\n<li>IO 多路复用模型：多路复用是一种通过管理多个 IO 操作来提高效率的技术。在多路复用模型中，一个线程可以同时处理多个 IO 操作，而不需要为每个 IO 操作创建一个单独的线程。</li>\n<li>异步 IO 模型：IO 操作的启动和完成是由系统内核来处理，而不需要应用程序的线程主动参与。当应用程序发起一个异步 IO 操作后，它可以继续执行其他任务，而无需等待 IO 操作的完成。</li>\n</ul>\n</li>\n<li><p>Java 的三大特性</p>\n<ul>\n<li>封装：封装是指将数据和对数据的操作封装在一个类中，通过访问修饰符来控制对数据的访问。封装可以隐藏数据的实现细节，提供统一的接口来访问和操作数据，增加代码的可维护性和安全性。</li>\n<li>继承：继承是指一个类可以继承另一个类的属性和方法。通过继承，子类可以重用父类的代码，并且可以在父类的基础上进行扩展和修改。继承可以建立类之间的层次关系，提高代码的可重用性和扩展性。  </li>\n<li>多态：多态是指同一个方法可以在不同的对象上表现出不同的行为。多态通过方法的重写（覆盖）和方法的重载来实现。通过多态，可以编写更加灵活和通用的代码，提高代码的可扩展性和可维护性。</li>\n</ul>\n</li>\n<li><p>Java 的线程调度</p>\n<ul>\n<li>线程优先级：Java 线程可以设置优先级，优先级越高，操作系统在调度时倾向于给予该线程更多的 CPU 时间片。通过 Thread.setPriority(int priority)方法设置线程的优先级。</li>\n<li>yield()方法：线程可以调用 yield()方法，暗示给操作系统一个提示，表示该线程愿意放弃当前的 CPU 时间片，让其他线程执行。操作系统可以选择忽略该提示。</li>\n<li>sleep()方法：线程可以调用 sleep()方法，使线程暂停执行一段时间，让其他线程有机会获得执行。</li>\n</ul>\n</li>\n<li><p>Java 的常量池、字符串池、对象池</p>\n<ul>\n<li>常量池：Java 中的常量池是一种特殊的存储区域，用于存储编译期间确定的常量。常量池分为两种类型，一种是类常量池，用于存储类中的常量，另一种是运行时常量池，用于存储每个线程的常量。常量池中存储的常量包括基本类型、字符串、类、方法和字段等。</li>\n<li>字符串池：Java 中的字符串池是用于存储字符串的缓存区域，它可以避免重复创建相同字符串对象。字符串池可以通过 String 类的 intern()方法来访问，当调用 intern()方法时，如果字符串池中已经存在相同的字符串，则返回已存在的字符串对象，否则将该字符串对象添加到字符串池中，并返回该字符串对象的引用。</li>\n<li>对象池：Java 中的对象池是一种重复使用对象的机制，它可以减少对象创建和销毁的开销，提高程序的性能。对象池通常用于创建、缓存和重复使用频繁创建和销毁的对象，如线程池、连接池和对象缓存池等。</li>\n<li>总结： 总的来说，常量池、字符串池和对象池都是 Java 虚拟机中的重要概念，它们都是为了提高 Java 程序的性能和节省内存而设计的。常量池用于存储常量，字符串池用于缓存字符串对象，对象池用于重复使用对象，以减少创建和销毁对象的开销。</li>\n</ul>\n</li>\n<li><p>Java 通配符</p>\n<ul>\n<li><? extends Object> 代表上边界限定通配符\n  - 匹配对象：继承自 Object 的所有对象，即 Object 的所有子类对象\n  - 用法：直接使用 add()方法受限，但可以使用 get 方法</li>\n<li><? super Object> 代表下边界限定通配符\n  - 匹配对象：Object 的所有父类对象\n  - 用法：使用 get()方法受限，获取到的应该是 Object 对象，但可以使用 add 方法</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Spring 全家桶框架\"><a href=\"#Spring 全家桶框架\" class=\"headerlink\" title=\"Spring 全家桶框架\"></a>Spring 全家桶框架</h2><ol>\n<li><p>SpringIOC 和 SpringAOP 的原理</p>\n<ul>\n<li>IOC<ul>\n<li>DI 依赖注入: 通过构造函数、属性或方法参数等方式，将一个对象所依赖的其他对象传递给它，而不是由这个对象自己去创建或查找依赖的对象。这样做的好处是，我们可以更灵活地管理和替换这些依赖</li>\n<li>IC 控制反转: 控制反转的核心思想是将对象的创建和管理交给容器或框架，而不是由程序员自己手动创建和管理对象。这样做的好处是可以将对象的生命周期和作用域管理交给框架或容器，从而避免了一些常见的问题，比如对象的重复创建、对象的生命周期管理等等。</li>\n</ul>\n</li>\n<li>AOP<ul>\n<li>面向切面的技术：所谓“切面”，简单说就是那些与业务无关，却被业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</li>\n<li>通知执行顺序<ol>\n<li>环绕通知前</li>\n<li>@Before 通知</li>\n<li>程序逻辑</li>\n<li>@AfterReturning 通知 或者 @AfterThrowing 异常通知</li>\n<li>@After 通知</li>\n<li>环绕通知后</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Spring 的三级缓存</p>\n<ul>\n<li>三级缓存<ul>\n<li>一级缓存：存放已经创建完成的 Bean</li>\n<li>二级缓存：存放早起创建但是未填充属性的 Bean，或者是代理对象</li>\n<li>三级缓存：存放 ObjectFactory 这样的 Bean 的工厂对象，负责动态的创建和管理 Bean</li>\n</ul>\n</li>\n<li><img src=\"http://xtzl.wentexl.cn/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.png\"/></li>\n<li>解决循环依赖的流程<ol>\n<li>A 对象实例化并将对象工厂放入到三级缓存</li>\n<li>A 对象依赖注入发现 B 对象也需要创建</li>\n<li>B 对象实例化并将对象工厂放入到三级缓存</li>\n<li>B 对象依赖注入发现循环依赖(一级和二级缓存都拿不到实例)，调用 A 对象的对象工厂的 getObject 方法</li>\n<li>A 的工厂对象的 getObject 方法内部判断 A 对象是否被代理过，如果未被代理过，则返回 A 对象的实例，如果被代理过，则返回一个新的代理对象，并将未初始化的实例对象或代理对象放入二级缓存。</li>\n<li>B 对象依赖注入成功，进入初始化，初始化完成之后将 B 对象放入一级缓存，并删除 B 对象的在三级缓存的工厂对象</li>\n<li>A 拿到 B 的实例对象并继续初始化</li>\n<li>A 和 B 都初始化完成</li>\n</ol>\n</li>\n<li>为什么一定要是三级缓存，二级缓存不行吗？<ul>\n<li>答案：如果 A 对象没有被代理，则可以。如果 A 对象被代理过，则不行</li>\n<li>理由：如果 A 和 B，A 和 C 都是循环依赖，那在解决循环依赖的时候，在 A 的对象工厂调用 getObject 的时候，就会生成并注入两个不同的 A 的代理对象，这就造成了对象的重复创建</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Spring 占位符</p>\n<ul>\n<li>‘#’ : #占位符会对输入的参数值进行类型转换，防止 SQL 注入攻击。</li>\n<li>‘$’ : $ 占位符在 SQL 语句中直接替换成输入的参数值，它不会对输入的参数值进行类型转换，也不会防止 SQL 注入攻击</li>\n</ul>\n</li>\n<li><p>RPC 框架</p>\n<ul>\n<li>理解：RPC 是一种用于实现分布式系统间通信的协议和技术，通过隐藏底层的网络通信细节，它允许一个服务通过网络请求另一个计算机上的服务或函数，在使应用程序能够像调用本地函数一样调用远程服务, 并获取结果，实现协同工作和资源共享。和 http 不同的是，HTTP 是一种用于客户端和服务器之间的通信的协议，主要用于 Web 应用程序的数据传输。</li>\n<li>好处：<ul>\n<li>抽象化通信：RPC 隐藏了底层网络通信的细节，使得开发者可以将重点放在业务逻辑上，而不用关心底层的网络通信实现。</li>\n<li>分布式系统的协作：RPC 可以方便地在分布式系统中调用远程服务，使得不同的系统能够协同工作，共享资源和功能。</li>\n<li>跨语言和跨平台支持：RPC 协议可以在不同的编程语言和平台上使用，使得不同技术栈的系统能够互相通信。</li>\n</ul>\n</li>\n<li>SpringCloud<ul>\n<li>注册中心: Ereuka、Zookeeper、Nacos、Consul</li>\n<li>服务调用: restTemplate、OpenFeign</li>\n<li>服务降级：Hystrix、Sentinel</li>\n<li>服务配置：Nacos、Config</li>\n<li>服务网关：GateWay</li>\n<li>服务总线：Bus、Nacos</li>\n</ul>\n</li>\n<li>Hadoop<ul>\n<li>HDFS</li>\n<li>MapReduce</li>\n</ul>\n</li>\n<li>Spark<ul>\n<li>执行流程：<ol>\n<li>根据 RDD 依赖关系 -&gt; DAG 流程图 —(DAGScheduler)–&gt; Stage —-(TaskScheduler)–&gt; tasks</li>\n<li>Executor  —(申请任务)–&gt; SparkContext、 任务调度器 —-(分发任务)—&gt; Executor</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>设计模式</p>\n<ul>\n<li>模式<ul>\n<li>工厂模式（Factory Pattern）：Spring 中使用工厂模式来实现对象的创建和管理，例如 BeanFactory 和 ApplicationContext 就是工厂模式的典型实现。</li>\n<li>代理模式（Proxy Pattern）：Spring 中使用代理模式来实现 AOP，通过动态代理技术在不改变原有类结构的前提下，对类的方法进行增强或切面操作。</li>\n<li>观察者模式（Observer Pattern）：Spring 中使用观察者模式来实现事件监听器的功能，例如 ApplicationListener 接口就是观察者模式的实现。</li>\n<li>模板模式（Template Pattern）：Spring 中使用模板模式来实现 JdbcTemplate 等模板类，将通用的数据访问逻辑封装在模板类中，提高了代码复用性和可维护性。</li>\n<li>单例模式（Singleton Pattern）：Spring 中大量使用了单例模式，确保在整个应用中只有一个实例对象被创建和共享，提高了应用的性能和效率。</li>\n<li>适配器模式（Adapter Pattern）：Spring 中使用适配器模式来适配各种数据源，例如 JDBC 适配器可以将不同厂商的 JDBC 驱动进行统一适配。</li>\n</ul>\n</li>\n<li>设计原则<ul>\n<li>单一原则：一个类只做同一个类型的事情，更注重于实现的细节</li>\n<li>开放 - 封闭原则：对修改关闭对扩展开放</li>\n<li>里氏替换原则：子类可以完全替代父类，如果 A 继承 B，但 B 中有一些方法，对于 A 来说是没有必要的，则抽一个 C 作为基类出来提取公共部分，并让 A 和 B 去继承 C</li>\n<li>接口隔离原则：每个接口都做同一类的事情，尽量按功能来细分，不要写成一个很大的接口</li>\n<li>依赖倒转原则：禁止套娃，直接依赖最初的类，不能 A 依赖 B，B 依赖 C，希望直接是 A 依赖 C</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Spring 事务</p>\n<ul>\n<li>@Transaction 失效场景<ul>\n<li>事务方法所在的类没有加载到容器中</li>\n<li>事务方法不是 public 类型</li>\n<li>同一类中，一个没有添加事务的方法调用另外以一个添加事务的方法，事务不生效</li>\n<li>抛出异常且手动捕获异常</li>\n<li>Spring 默认抛出了未检查 unchecked 异常（继承自 RuntimeException 的异常）或者 Error 才回滚事务，其他异常需要指定 rollbackFor 才能回滚事务，如果不指定又抛出了其他异常(IOException)，比如说 FileNotFoundException，则事务失效</li>\n</ul>\n</li>\n<li>传播行为<ul>\n<li>Required ： 内外事务合为一个</li>\n<li>New-Required : 内外事务隔离</li>\n<li>Supported : 有事务就按事务执行，没事务就按无事务的方式执行</li>\n<li>Not-Supported : 采用非事务的方式执行</li>\n</ul>\n</li>\n<li>隔离级别<ul>\n<li>RU</li>\n<li>RC</li>\n<li>RR</li>\n<li>可串行化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Bean 的作用域</p>\n<ul>\n<li>singleton : 容器中以单实例存在</li>\n<li>prototype : 容器中以多实例存在</li>\n<li>request   : 在同一个请求内共享</li>\n<li>session   : 在同一个 Session 内存共享</li>\n<li>globalSession : 全局的 Session 都共享同一个 Bean 实例</li>\n</ul>\n</li>\n<li><p>BeanFactory 和 FactoryBean</p>\n<ul>\n<li>BeanFactory : 所有 Bean 的根接口，我把它看做制作 Bean 的图纸的工厂，它在产生 Bean 的同时也提供了依赖注入的能力 </li>\n<li>FactoryBean : 动态生成一个实例 Bean 的工厂，我把它看做按照图纸生成一个实实在在的组件，可加载到容器中去。</li>\n</ul>\n</li>\n<li><p>Bean 的生命周期</p>\n<ul>\n<li>从配置中加载 beanDefination</li>\n<li>实例化</li>\n<li>属性赋值</li>\n<li>初始化</li>\n<li>销毁</li>\n</ul>\n</li>\n<li><p>分布式事务</p>\n<ul>\n<li><p>CAP 理论：一致性（数据）C、可用性（整个服务）A、分区容忍性 P</p>\n<ul>\n<li>分区：一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。</li>\n<li>分区容忍性：当一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，由于数据项就可能分布到各个区里，所以我们仍然是可以访问的到这个数据的，容忍性就提高了。</li>\n<li>一致性的问题：然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题，因为长时间的阻塞等待会导致我们的服务性能降低，严重的甚至可能导致我们服务崩溃</li>\n</ul>\n</li>\n<li><p>BASE 理论：是对 CAP 的一种解决思路，主要包含三个思想</p>\n<ul>\n<li>Basically Available （基本可用）：系统在面对故障或部分故障时，仍然能够保持基本的可用性，即系统仍然能够对外提供服务，并能够及时响应请求。</li>\n<li>Soft State（软状态）：系统中的数据状态可以在一段时间内是不稳定的，即系统中的数据可能存在中间状态，而不是绝对一致的状态。这种中间状态可能是由于数据复制、缓存等原因导致的。</li>\n<li>Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，系统可以通过一定的机制来保证最终数据的一致性，例如异步复制、定期数据同步等，最终达到数据一致。</li>\n</ul>\n</li>\n<li><p>Seata：<a href=\"https://blog.csdn.net/m0_58600248/article/details/126271252?spm=1001.2014.3001.5506\">https://blog.csdn.net/m0_58600248/article/details/126271252?spm=1001.2014.3001.5506</a></p>\n</li>\n<li><p>XA 模式和 AT 模式的比较</p>\n<ul>\n<li>XA 模式是强一致性，因为所有的本地事务都会等待 TC 发起提交命令之后才会提交自己的事务，对数据的修改才会持久化到磁盘中去</li>\n<li>AT 模式是最终一致性的，因为本地事务执行完 SQL 之后，会先提交，然后才会向 TC 报告自己的状态，如果存在一些本地事务故障，则会导致短暂的不一致的情况，需要第二阶段的回滚这样的补偿机制来保证最终一致性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Springboot 怎么实现自动配置</p>\n<ul>\n<li>引入 start 依赖，start 依赖里提前配置好了该组件被继承进来需要用到的配置，一旦引用，SpringBoot 就会把这些配置自动加载到应用程序中</li>\n<li>加载了哪些配置<ul>\n<li>自动配置类，也就是 @Configuration 所标识的类</li>\n<li>文件配置，也就是 application.yml 这种文件</li>\n<li>条件化配置，@Conditional，用来定义了在满足特定条件时才应用该自动配置</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Springboot 为什么能快速构建应用</p>\n<ul>\n<li>内置 Tomcat</li>\n<li>摆脱了大量的 xml 文件的配置</li>\n<li>自动配置原理，很多配置都是写好了的，直接加载了之后拿来用</li>\n</ul>\n</li>\n<li><p>SpringMVC 的执行流程</p>\n<ol>\n<li>客户端发送 HTTP 请求到前端控制器（DispatcherServlet）。 </li>\n<li>DispatcherServlet 根据请求的 URL 找到对应的处理器映射器（HandlerMapping）。 </li>\n<li>处理器映射器根据请求的 URL 映射到具体的处理器（Controller）。 </li>\n<li>处理器被调用并处理请求，然后返回一个 ModelAndView 对象。 </li>\n<li>处理器将 ModelAndView 对象传递给 DispatcherServlet。 </li>\n<li>DispatcherServlet 调用视图解析器（ViewResolver）来解析 ModelAndView 对象，找到对应的视图。 </li>\n<li>视图解析器将视图对象返回给 DispatcherServlet。 </li>\n<li>DispatcherServlet 将模型数据传递给视图对象，然后渲染视图。 </li>\n<li>最终，DispatcherServlet 将响应返回给客户端。 </li>\n</ol>\n</li>\n</ol>\n<h2 id=\"JUC\"><a href=\"#JUC\" class=\"headerlink\" title=\"JUC\"></a>JUC</h2><ol>\n<li><p>Synchronized </p>\n<ul>\n<li>原理:synchronized 是 Java 中用于实现同步的关键字，它可以应用于方法或代码块中。其主要原理是通过对一个对象或类进行加锁来保证多个线程之间的互斥访问。当一个线程获取了锁，其他线程就必须等待锁被释放后才能进入被锁定的代码块。 </li>\n<li>锁对象<ul>\n<li>修饰的是普通方法：锁的是实例对象</li>\n<li>修饰的是静态方法：锁的是类 class 对象</li>\n<li>修饰的是代码块：锁的是代码块之前，括号之内的实例对象</li>\n</ul>\n</li>\n<li>锁升级<ul>\n<li>偏向锁：线程 A 第一次竞争到资源，加的是偏向锁,MarkWord 存的是偏向线程 ID，之后只需检查是否是偏向线程访问即可，效率最高。</li>\n<li>轻量级锁：线程 B 来和线程 A 竞争资源且竞争成功，则偏向锁切换偏向线程，竞争失败，则偏向锁升级为轻量级锁, 轻量级锁本质就是自旋锁 CAS</li>\n<li>重量级锁：大量线程参与竞争或 CAS 多次自旋未成功，升级为重量级锁，效率最低</li>\n</ul>\n</li>\n<li>区别于 ReentrantLock:<ul>\n<li>ReentrantLock 是 Java 层面的实现，synchronized 是 JVM 层面的实现。</li>\n<li>使用 synchronized 关键字实现同步，线程执行完同步代码块会自动释放锁 (a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，而 ReentrantLock 需要手动释放锁需在 finally 中手工释放锁（unlock() 方法释放锁），否则容易造成线程死锁。</li>\n<li>synchronized 是非公平锁，ReentrantLock 可以实现公平和非公平锁。</li>\n<li>ReentrantLock 可以设置超时获取锁。在指定的截止时间之前获取锁，如果截止时间到了还没有获取到锁，则返回。配合重试机制更好的解决死锁。</li>\n<li>ReentrantLock 上等待获取锁的线程是可中断的，线程可以放弃等待锁。而 synchonized 会无限期等待下去。</li>\n<li>ReentrantLock 的 tryLock() 方法可以尝试非阻塞的获取锁，调用该方法后立刻返回，如果能够获取则返回 true，否则返回 false。</li>\n<li>synchronized 无法判断是否获取锁的状态，Lock 可以判断是否获取到锁，并且可以主动尝试去获取锁。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线程池</p>\n<ul>\n<li><p>线程池实际上就是，可以通过预先创建一定数量的线程来管理任务执行，并重用线程以减少创建和销毁线程的开销，从而提高程序的性能和效率。但是如果线程池大小设置不当，可能会导致资源浪费或者系统负载过高的问题。如果任务队列中的任务数量过多，或者线程池中的线程数量过少，也可能会导致任务执行的延迟。  </p>\n</li>\n<li><p>七大参数</p>\n<ul>\n<li>核心线程数 corePoolSize </li>\n<li>最大线程数 maximumPoolSize   </li>\n<li>空闲线程的存活时间 keepAliveTime </li>\n<li>存活时间单位 TimeUnit</li>\n<li>阻塞队列 workQueue </li>\n<li>线程工厂 threadFactory </li>\n<li>拒绝策略 handler<ul>\n<li>抛出异常</li>\n<li>任务调回</li>\n<li>丢弃任务</li>\n<li>与最老任务竞争</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>参数设置</p>\n<ul>\n<li>I/O 通常是对数据库的操作, 线程数如果不多的话，在处理 IO 的时候不能用 CPU，导致 CPU 的使用率较低。</li>\n<li>CPU 密集型：<ul>\n<li>核心线程 = CPU 核心</li>\n<li>最大线程 = CPU 核心 + 1</li>\n</ul>\n</li>\n<li>IO 密集型<ul>\n<li>核心线程 = 2*CPU 核心</li>\n<li>最大线程 = 2*CPU 核心 + 1</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>运行流程</p>\n<ul>\n<li>初始化线程池：需要指定线程池的参数，线程池会根据这些参数创建一定数量的线程，并初始化线程池的内部数据结构。</li>\n<li>接收任务：线程池会一直处于运行状态，等待接收任务。当有任务到达时，线程池会接收任务并将其放入任务队列中。</li>\n<li>线程分配任务：线程池中的线程会从任务队列中取出任务。如果核心线程数尚未达到设定的值，线程池会创建新的线程来处理任务。如果核心线程数已满，但还有任务到达，任务会被放入任务队列中等待执行。</li>\n<li>任务执行：线程不断从任务队列中取出任务，并执行任务的逻辑。</li>\n<li>关闭线程池：当不再需要线程池时，可以显式地关闭线程池。一般是先调用 shutdown()方法停止接收新任务，然后再调用 awaitTermination()方法等待任务执行完毕，最后再调用 shutdownNow()方法强制关闭线程池，以确保任务能够顺利完成</li>\n</ul>\n</li>\n<li><p>阻塞队列</p>\n<ul>\n<li>如果需要一个有界队列，且并发读写较少，可以选择使用 ArrayBlockingQueue</li>\n<li>如果需要一个无界队列，且并发读写较多，可以选择使用 LinkedBlockingQueue。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>volatile(建议从 JMM 中引入)</p>\n<ul>\n<li>概念：volatile 关键字用于标记变量，指示编译器和运行时系统每次访问该变量时都必须从内存中读取值，而不是使用缓存的值。在多线程编程中</li>\n<li>作用：使用 volatile 可以保证可见性和禁止指令重排，从而保证线程安全。</li>\n<li>补充解释：具体来说，当一个线程修改 volatile 变量的值时，其他线程将立即看到该变量的新值，因为该值是从内存中读取的。此外，由于 volatile 变量不能被缓存，因此在对该变量进行读取和写入操作时，不会发生指令重排，从而避免了线程安全问题。需要注意的是，volatile 仅保证单个操作的原子性，而不是多个操作的原子性。如果需要保证多个操作的原子性，应该使用其他机制，如锁、原子操作等。</li>\n</ul>\n</li>\n<li><p>线程的创建方式</p>\n<ul>\n<li>继承 Thread 类并重写 run()方法</li>\n<li>实现 Runnable 接口或者 Callable 接口</li>\n<li>使用线程池创建接口</li>\n</ul>\n</li>\n<li><p>CAS 可能出现的问题</p>\n<ul>\n<li>ABA 问题：CAS 操作在进行比较时，只会比较原值和期望值是否相等，但是在并发环境下，可能会存在 A-&gt;B-&gt;A 的情况，这时候 CAS 就无法检测出这种情况，导致并发安全问题。</li>\n<li>自旋开销：在使用 CAS 进行无锁编程时，由于 CAS 是一个自旋操作，需要不断地进行尝试和比较，从而可能会带来一定的 CPU 开销和性能损失。</li>\n<li>公平性：CAS 操作无法像锁机制一样保证公平性，可能会导致一些线程一直无法获取资源。</li>\n</ul>\n</li>\n<li><p>线程的同步方式</p>\n<ul>\n<li>synchronized: 采用互斥锁的方式来实现同步，当一个线程进入同步方法时，它会自动获取该方法所属对象的锁，其他线程需要等待该线程释放锁后才能进入该方法。</li>\n<li>ReentrantLock: 是一个可重入的互斥锁，与 synchronized 相比，ReentrantLock 提供了更灵活的锁定机制和更多的功能，如可实现公平锁、可用 condition 绑定很多条件等。</li>\n<li>Semaphore: 是一种计数信号量，用于控制对共享资源的访问。类似线程池的思想</li>\n<li>CountDownLatch: 多个线程并行执行完之后统一地执行主线程</li>\n<li>CyclicBarrier: 多线线程并行执行完之后单开一个线程去执行</li>\n</ul>\n</li>\n<li><p>零拷贝</p>\n<ul>\n<li>概念: 是指在数据传输过程中，数据在不经过中间缓存（如用户态缓存）的情况下，直接从发送端复制到接收端，避免了数据在内存之间的多次复制，从而提高了数据传输的效率。</li>\n</ul>\n</li>\n<li><p>ThreadLocal</p>\n<ul>\n<li>概念：每个线程内部都维护了一个 ThreadLocalMap(懒加载的)，key 为 threadLocal 实例，value 为要保存的副本，说白了就是保存的线程的私有变量, 它允许在多线程环境下，每个线程都拥有自己独立的变量副本，这样就可以避免线程之间的数据互相干扰。</li>\n<li>问题：<ul>\n<li>内存泄漏问题，ThreaLocal 本身作为 key 是弱引用，存放的实例对象是强引用，GC 不会回收强引用，从而导致内存没有及时释放</li>\n<li>使用 ThreadLocal 可能导致上下文丢失，因为可能会开一些异步线程去做一些操作，而在异步线程就可能丢失掉主线程的变量，从而后续如果需要用到这些变量，就获取不到了</li>\n</ul>\n</li>\n<li>应用场景<ul>\n<li>避免不必要的参数传递：将对象数据存储到 ThreadLocal 中，在本线程任何位置遇到的时候，都可以直接调用 get 方法来取</li>\n<li>线程间数据隔离：每个线程在自己线程里使用自己的局部变量，各线程间的 ThreadLocal 对象互不影响，例子就是 Spring 在 Dao 层，单例对象却可以有多个连接，多个连接都是每个线程自己的副本</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线程的五种状态</p>\n<ul>\n<li>新建、就绪、运行、阻塞、死亡</li>\n</ul>\n</li>\n<li><p>sleep()和 wait()的区别</p>\n<ul>\n<li>wait()是 Object 的方法，sleep()是 Thread 类的方法</li>\n<li>wait()会释放锁，sleep()不会释放锁</li>\n<li>wait()要在同步方法或者同步代码块中执行，sleep()没有限制</li>\n<li>wait()要调用 notify()或 notifyall()唤醒,sleep()自动唤醒</li>\n</ul>\n</li>\n<li><p>线程池 execute 和 submit 的区别</p>\n<ul>\n<li>返回值类型不同：execute() 方法返回值为 void，而 submit() 方法返回一个 Future 对象，可以通过该对象获取任务执行的结果。</li>\n<li>对于提交的任务类型不同：execute() 方法只能提交 Runnable 类型的任务，而 submit() 方法可以提交 Runnable 和 Callable 类型的任务。Runnable 代表一个不带返回值的任务，Callable 则代表一个带返回值的任务。</li>\n<li>阻塞行为不同：execute() 方法是一种无阻塞的提交方式，它会立即返回，并将任务提交给线程池中的一个线程执行；而 submit() 方法是一种阻塞的提交方式，它会等待线程池中有一个线程可用时再执行任务，如果线程池中没有可用线程，则任务会等待，直到有线程可用。</li>\n<li>异常处理方式不同：execute() 方法无法处理任务执行过程中抛出的异常，而 submit() 方法可以捕获任务执行过程中抛出的异常，并将其封装到 Future 对象中，以便后续处理。</li>\n</ul>\n</li>\n<li><p>锁分类</p>\n<ul>\n<li>乐观锁 ： 通过 CAS + 版本号</li>\n<li>悲观锁 : 每次获取到资源之后都加锁</li>\n<li>公平锁 ：多个线程按顺序平均都能分到资源 </li>\n<li>非公平锁： 无顺序一直竞争资源</li>\n<li>自旋锁：当锁被占用时，线程不会被阻塞，而是通过不断重试的方式获取锁</li>\n<li>偏向锁：当只有一个线程访问时，该线程可以直接获得锁，不需要进行同步</li>\n<li>可重入锁: 同一个线程能连续获得同一个资源的锁</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><ol>\n<li><p>垃圾回收算法</p>\n<ul>\n<li>标记清除算法: 这是一种最基本的垃圾回收算法。它的核心思想是先标记所有可达对象，然后清除所有未被标记的对象。标记和清除分别需要扫描整个堆，效率较低，同时可能会产生内存碎片。</li>\n<li>标记整理算法: 这种算法在标记阶段与标记 - 清除算法类似，但在清除阶段不是简单地删除未被标记的对象，而是将所有存活对象都向一端移动，然后将另一端的空间全部释放，从而避免了内存碎片的问题。</li>\n<li>复制算法: 这种算法将堆分为两个区域，每次只使用其中的一部分。当当前区域用完后，将存活对象复制到另一个区域中，然后将当前区域中的所有对象清除。复制算法的特点是效率高，但需要两倍的空间。</li>\n<li>分代算法: 这种算法认为对象的生命周期具有不同的阶段，将堆分为多个代，一般将新生代和老年代分开处理。新生代中的对象生命周期较短，采用复制算法；老年代中的对象生命周期较长，采用标记 - 整理算法。分代算法充分利用了对象的生命周期分布规律，提高了垃圾回收效率。</li>\n</ul>\n</li>\n<li><p>垃圾回收器</p>\n<ul>\n<li><p>CMS 收集器</p>\n<ul>\n<li>针对老年代，采用标记 - 清除法，容易产生内存碎片</li>\n<li>以获取最短回收停顿时间为目标</li>\n<li>对 CPU 资源敏感、无法处理浮动垃圾</li>\n</ul>\n</li>\n<li><p>G1 收集器: JDK1.9 以后的默认垃圾回收器</p>\n<ul>\n<li>分代收集，针对不同的分代结果，采用不同的收集算法，包括新生代和老年代</li>\n<li>采用标记 - 整理 + 复制算法回收内存，使用可达性分析法来判断对象是否可以被回收</li>\n<li>能充分利用多 CPU、多核环境下的硬件优势、注重响应速度<ul>\n<li>原理：<ul>\n<li>并行处理：G1 收集器采用了多线程并行处理来加速垃圾回收过程。在收集过程中，G1 将整个堆空间分成多个区域（Region），每个区域都可以被多个线程并行处理。这样，每个线程只需要处理一小部分的垃圾，从而减少了单个线程的工作量，提高了垃圾回收的效率。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>可作为 GCROOT 对象</p>\n<ul>\n<li>长期存活的对象：比如线程池、I/O 等系统资源对象，它们通常需要在整个应用生命周期中持续存在。</li>\n<li>静态变量和常量：静态变量和常量是在类加载时被初始化的，它们的生命周期通常很长。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>新生代晋升到老年代的策略</p>\n<ul>\n<li>对象年龄阈值策略：JVM 中每个对象都有一个年龄计数器，当一个对象在新生代中经历了一定数量的垃圾收集后仍然存活，它的年龄计数器就会增加 1。当一个对象的年龄超过一定阈值时，它就会被晋升到老年代中。可以通过调整年龄阈值来控制对象晋升的速度。</li>\n<li>空间不足：如果新生代的可用空间不足以存放新的对象，JVM 会先尝试触发一次垃圾回收，如果回收后仍然无法获得足够的空间，JVM 就会尝试将部分存活的对象直接晋升到老年代中，以腾出新生代的空间。</li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li>内存结构<ul>\n<li>堆 (线程共享): 存储对象实例、为对象分配内存空间、GC 主要作用区域</li>\n<li>方法区(线程共享): 存储类的元数据信息，如类名、方法名、字段名等。方法区还用于存储运行时常量池、静态变量、即时编译器编译后的代码等信息。</li>\n<li>Java 虚拟机栈: 用于存放 Java 方法执行时的栈帧。每个栈帧包含局部变量表、动态链接、返回地址等信息。当线程调用 Java 方法时，JVM 会在 Java 虚拟机栈中为该方法分配一个栈帧，在方法返回时，该栈帧会被弹出并销毁。</li>\n<li>本地方法栈: 本地方法栈和 Java 虚拟机栈类似，用于存储本地方法 (其他语言编写的) 的栈帧。</li>\n<li>程序计数器: 用于指示 JVM 正在执行哪个线程的字节码指令</li>\n<li>堆的分区<ul>\n<li>新生代(1/3) : Eden(8/10) 幸存区 1(1/10) 幸存区 2(1/10)  [通常采用复制算法]</li>\n<li>老年代(2/3) : 存放存活时间较长的对象，这些对象可能是长时间存活的业务数据、缓存对象、连接池等 [通常采用标记整理算法]</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p>如何减少 Full GC</p>\n<ul>\n<li>尽量少创建一些临时对象</li>\n<li>增加堆的大小</li>\n<li>使用对象池, 提高对象的利用率</li>\n<li>调整年轻代的 S 区的大小，</li>\n</ul>\n</li>\n<li><p>什么情况下会内存溢出</p>\n<ul>\n<li>堆内存溢出<ol>\n<li>加载的类越来越多时</li>\n<li>当对象一直创建而不被回收时</li>\n<li>虚拟机栈的线程越来越多时</li>\n</ol>\n</li>\n<li>栈溢出<ul>\n<li>方法调用次数过多，一般是递归不当造成</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"7\">\n<li>类加载器<ul>\n<li>概念：类加载机制是 Java 虚拟机（JVM）加载类文件到内存中的过程。</li>\n<li>双亲委派模型: 它首先将这个请求委派给它的父类加载器去完成，如果父类加载器还存在父类加载器，它会将请求一直传递给更高级的父类加载器，直到顶层的父类加载器。</li>\n<li>好处：双亲委派模型保证了类的唯一性，避免了类的重复加载，从而保证 Java 程序的稳定性和安全性。</li>\n<li>种类<ul>\n<li>引导类加载器：也称为根加载器，是最顶层的类加载器，用来加载 Java 的核心库，如 java.lang 包中的类。</li>\n<li>扩展类加载器：负责加载 Java 平台扩展库，默认加载 JAVA_HOME/lib/ext 目录下的 jar 包。</li>\n<li>应用程序类加载器：负责加载应用程序 classpath 目录下的所有类，即我们自己编写的 Java 类。</li>\n<li>自定义类加载器：我们可以通过继承 java.lang.ClassLoader 类实现自己的类加载器，用于实现特定的类加载需求，如从网络上加载类文件等。</li>\n<li>总结：每个类加载器都有自己的加载范围，即它能够加载哪些类。当一个类加载器需要加载一个类时，它会先查找自己已经加载的类，如果没有找到，则向上委托给父类加载器，直到顶层的引导类加载器，如果仍然没有找到，先判断自己是否能加载这个类，如果不能，则会向下委托给子类加载器去加载，总结起来就是自下而上去查找，又自上而下来加载。这样的加载方式构成了 Java 类加载器的双亲委派模型。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h2><ul>\n<li><p>概念：JMM 是指的是 Java 内存模型，它是一种规范，它规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）, 线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。同时，不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。</p>\n</li>\n<li><p>特性</p>\n<ul>\n<li>原子性：一个操作不能被打断，要么全部执行完毕，要么不执行。</li>\n<li>可见性：一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量的这种修改（变化）。</li>\n<li>有序性: 在单线程程序里，确实顺序执行；但是在多线程并发时，程序的执行就有可能出现乱序。</li>\n</ul>\n</li>\n<li><p>有序性和可见性的保证</p>\n<ul>\n<li>synchronized<ul>\n<li>获取锁的时候直接从主存中读取变量，释放锁之前把工作内存的变量数据重新刷回主存</li>\n<li>既保证了多线程的并发有序性，又保证了多线程的内存可见性。</li>\n</ul>\n</li>\n<li>volatile<ul>\n<li>每次修改变量都会直接刷到主存</li>\n<li>可以保证内存可见性，不能保证并发有序性(不具有原子性)，可禁止指令重排。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>volatile 的原理：会生成一个内存 lock 前缀指令，相当于一个内存屏障</p>\n<ul>\n<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>\n<li>它会强制将对缓存的修改操作立即写入主存；</li>\n<li>如果是写操作，它会导致其他 CPU 中对应的缓存行无效。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据库\"><a href=\"# 数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><ol>\n<li><p>四大特性(ACID)</p>\n<ul>\n<li>原子性 ： 每个操作不可再分</li>\n<li>一致性 ： 一个事务可以让数据从一种一致状态切换到另一种一致性状态</li>\n<li>隔离性 ： 事务并行执行互不影响，最后结果和串行执行的结果相同</li>\n<li>持久性 : 一个事务一旦被提交，在数据库中的改变就是永久的，提交后就不能再回滚</li>\n</ul>\n</li>\n<li><p>三大问题</p>\n<ul>\n<li>脏读：读到了未提交的数据</li>\n<li>不可重复读：同一个事务两次读到的数据值不同</li>\n<li>幻读：同一个事务两次读到的数据记录数量不同</li>\n</ul>\n</li>\n<li><p>隔离级别</p>\n<ul>\n<li>READ UNCOMMITTED: 读未提交</li>\n<li>READ COMMITTED: 读已提交</li>\n<li>REPEATABLE READ: 可重复读</li>\n<li>SERIALIZABLE: 可串行化</li>\n</ul>\n</li>\n<li><p>SQL 执行顺序</p>\n<ul>\n<li>from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt; order by -&gt; limit</li>\n</ul>\n</li>\n<li><p>MVCC 原理</p>\n<ul>\n<li>作用:<ul>\n<li>解决脏读、不可重复读的事务读写问题</li>\n<li>在保证隔离性的基础上，提升了读取效率和并发性</li>\n</ul>\n</li>\n<li>描述：在执行 Update 和 Delete 操作的时候，会将每次操作记录记录在 UndoLog 中, 每条记录都有唯一的事务 ID, 而 ReadView 记录了数据版本链的一些统计值，包括活跃事务集，当前事务 ID 等，然后通过四步判断法进行判断，遍历整个版本链，最终得到一个符合所有要求的数据版本。</li>\n<li>四步判断法：第一步主要判断是否是同一个读取的当前事务修改的数据，第二三步是判断是否是读到的未来的数据，第四步是判断是否是读的已提交的数据</li>\n<li>作用解释：因为保证了读到的都是已提交的数据，所以避免了脏读，因为同一个事务使用的都是同一个 Readview，所以保证同一个事务匹配到的是同一个版本的数据，所以避免了不可重复读的问题。</li>\n</ul>\n</li>\n<li><p>日志 Log</p>\n<ul>\n<li>bin log（二进制日志）：记录所有对 MySQL 数据库的更改操作，例如 INSERT、UPDATE、DELETE 等，以二进制格式存储。binlog 文件可以用于数据备份和恢复，数据复制和数据同步。</li>\n<li>undo log（回滚日志）：在事务中，如果执行了 UPDATE 或 DELETE 操作，MySQL 会先将修改前的数据记录到 undo log 中，然后再对数据进行修改。如果事务回滚，则 MySQL 可以使用 undo log 来撤销已经进行的修改。</li>\n<li>redo log（重做日志）：在事务中，MySQL 会先将对数据的修改记录到 redo log 中，然后再进行实际的修改。如果 MySQL 在执行修改操作后崩溃，MySQL 可以使用 redo log 来恢复数据。</li>\n<li>慢查询日志：MySQL 的慢查询日志是一种记录执行时间超过一定阈值的查询语句的日志。可以记录查询语句、执行时间、锁等待时间等信息</li>\n</ul>\n</li>\n<li><p>MySQL 慢查询</p>\n<ul>\n<li>概念：慢查询是指执行时间较长、响应时间较慢的 SQL 查询语句。通常来说，如果一条 SQL 查询语句的执行时间超过了一定的阈值（例如 1 秒钟），就可以将其视为慢查询。</li>\n<li>定位：可以使用 MySQL 的慢查询日志文件</li>\n<li>影响：它们可能会导致服务器资源的过度占用，影响系统的响应速度和稳定性。</li>\n<li>解决方案<ul>\n<li>使用索引：确保表的索引能够覆盖查询的列，这将使 MySQL 能够快速找到需要的数据。</li>\n<li>优化查询语句：使用合适的查询语句可以提高性能。使用 JOIN 时，应该尽可能使用 INNER JOIN 而不是 LEFT JOIN 或 RIGHT JOIN，因为后者可能会导致较慢的查询速度。</li>\n<li>优化表结构：可以改善查询性能。例如，避免使用过多的 JOIN，使用正确的数据类型，避免使用过多的 NULL 值等等。</li>\n</ul>\n</li>\n<li>索引优化<ul>\n<li>索引选择：根据每个字段的特点来选择、尽量走覆盖索引，减少回表</li>\n<li>代码层面：严禁 for 循环查表、连接池参数优化、尽量避免联表查询</li>\n<li>架构层面：分库分表、索引定期维护，定期进行索引的重建、重新组织或碎片整理，可以保持索引的良好状态和性能</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>聚簇索引和非聚簇索引</p>\n<ul>\n<li>区别：<ul>\n<li>物理存储方式不同: 前者的数据存在同一块物理存储区域，后者是建立索引值与行记录映射关系，有点像顺序存储和链式存储</li>\n<li>适用范围不同: 聚簇索引适合于频繁查询范围较小的数据、后者适用于频繁查询单个或少量的记录, 因为每个索引条目只需要查询一次就可以找到相应的行记录。</li>\n<li>字段数量不同: 每张表前者只能有一个，后者可以有多个</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>MySQL 索引</p>\n<ul>\n<li>如何判断 MySQL 中的索引有没有生效: 在 select 语句前面加上 explain 就可以了</li>\n<li>主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值</li>\n<li>唯一索引：唯一索引不能有相同值，但允许为空</li>\n<li>普通索引：允许出现重复值</li>\n<li>组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则</li>\n<li>全文索引：通过建立倒排索引提升检索效率，广泛用于搜索引擎</li>\n</ul>\n</li>\n</ol>\n<ol start=\"10\">\n<li>MySQL 索引的应用场景</li>\n</ol>\n<ul>\n<li>适合：<ul>\n<li>频繁作为查询的字段</li>\n<li>查询作为和其他表关联的字段</li>\n<li>查询中常作为排序条件的字段</li>\n</ul>\n</li>\n<li>不适合：<ul>\n<li>频繁更新的字段</li>\n<li>表的记录不多的字段</li>\n<li>数据重复且分布平均的字段</li>\n</ul>\n</li>\n</ul>\n<ol start=\"11\">\n<li><p>索引是越多越好吗？优缺点在何处？</p>\n<ul>\n<li>优点<ul>\n<li>快速访问：索引可以加速数据访问，使得查询数据更快速。</li>\n<li>提高性能：索引可以提高数据库性能，使得数据的读取更快。</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>索引的成本：索引需要额外的存储空间来存储数据，这可能会占用大量磁盘空间。</li>\n<li>增加写入负担：索引的维护需要一定的时间和计算资源，因此在数据量大且经常写入的情况下，索引的创建和更新可能会带来一定的负担。</li>\n<li>复杂性增加：如果过多的索引被创建，可能会使得数据结构变得更加复杂和难以管理，增加了维护的难度。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>MySQL 索引失效场景</p>\n<ul>\n<li>对索引列使用左模糊或者左右模糊查询</li>\n<li>对索引使用函数</li>\n<li>对索引进行表达式运算</li>\n<li>对索引隐式类型转换的时候</li>\n<li>违背最左匹配原则</li>\n<li>or 的左右两边不全是索引字段</li>\n</ul>\n</li>\n</ol>\n<ol start=\"13\">\n<li>如果索引不合适，会删除吗，是什么流程<ul>\n<li>如果索引不合适，通常会进行重新设计和重建索引，而不是直接删除索引。这是因为索引是数据库中非常重要的组成部分，它们帮助加速查询和提高数据库性能。</li>\n<li>重建索引的流程通常包括以下步骤：<ol>\n<li>确定需要重建索引的表和索引：通过分析数据库性能和查询计划，确定哪些表和索引需要重建。</li>\n<li>停止对表的写操作：停止对需要重建索引的表的写入操作，以确保在重建过程中不会发生数据丢失或数据不一致的情况。</li>\n<li>删除旧的索引：删除需要重建的索引。</li>\n<li>重建索引：根据设计好的新索引结构，重新创建索引。</li>\n<li>重新启用写操作：重建索引完成后，重新启用对表的写入操作。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"14\">\n<li><p>MySQL 的基本数据类型</p>\n<ul>\n<li>整型（xxxint）</li>\n<li>位类型(bit)</li>\n<li>浮点型（float 和 double、real）</li>\n<li>日期时间类型（date,time,datetime,year）</li>\n<li>字符串（char,varchar,xxxtext）</li>\n<li>二进制数据（xxxBlob、xxbinary）</li>\n<li>定点数（decimal,numeric）</li>\n<li>枚举（enum）</li>\n<li>集合（set）</li>\n</ul>\n</li>\n<li><p>MySQL 回表</p>\n<ul>\n<li>概念：一般是对于非主键索引而言的, 查询完得到的结果是主键索引的值，然后不但要遍历非主键索引的 B+ 树，还要重新遍历一遍主键索引的 B+ 树，叫做回表</li>\n<li>解决：可以通过覆盖索引的方式解决，即索引的字段中已经包含了需要查询的字段</li>\n</ul>\n</li>\n<li><p>MySQL 锁</p>\n<ul>\n<li>共享锁: 共享锁允许多个事务同时读取同一资源，但是不能进行修改操作。这个语句会给查询的结果集上共享锁，其他事务可以读取这个结果集，但是不能进行修改操作，直到释放锁为止。<ul>\n<li><code>sql SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE; </code></li>\n</ul>\n</li>\n<li>排他锁: 排他锁是最高级别的锁，它禁止其他事务对资源的任何读取和写入操作，只有当前事务可以对资源进行读取和写入操作。<ul>\n<li><code>sql SELECT * FROM table_name WHERE ... FOR UPDATE; </code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>SQL 执行流程</p>\n<ul>\n<li>建立连接校验用户名密码 -&gt; 查询缓存 -&gt; 词法分析语法分析 -&gt; 优化器判断是否有索引 -&gt; 执行器判断是否有权限 -&gt; 执行语句并返回结果集</li>\n</ul>\n</li>\n</ol>\n<ol start=\"18\">\n<li>SQL 优化<ul>\n<li>查询 SQL 尽量不要使用 select *，而是具体字段</li>\n<li>避免在 where 子句中使用 or 来连接条件</li>\n<li>使用 varchar 代替 char</li>\n<li>查询尽量避免返回大量数据</li>\n<li>尽量使用数值替代字符串类型</li>\n<li>如何结合业务来进行 SQL 优化<ul>\n<li>只查询必要字段：那么查询时只选择业务需要的必要字段，而不要选择所有字段。减少查询返回的数据量有助于提高查询效率</li>\n<li>选取合适的候选码：根据控制层传递的参数，考虑选用合适的候选码作为 where 筛选条件，尽量走覆盖索引</li>\n<li>数据分页：如果查询结果太大，可以考虑分页查询，每次只查询一部分结果，这样可以减少一次性返回大量数据所带来的负担</li>\n<li>考虑合并多个查询：有时候，可以将多个独立的查询合并为一个查询，减少数据库连接和查询次数，从而提高查询效率。</li>\n<li>缓存数据：对于一些频繁查询的数据，可以考虑在应用程序层面进行缓存，避免频繁地访问数据库，提高响应速度。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"19\">\n<li><p>防止 SQL 注入</p>\n<ul>\n<li>使用 mybatis 的”#{}“预编译，将传入的值按照字符串的形式进行处理</li>\n<li>利用工具进行 SQL 注入检测</li>\n<li>对进入数据库的特殊字符进行转义处理，或编码转换</li>\n<li>校验参数的数据格式是否合法(可以使用正则或特殊字符的判断)</li>\n</ul>\n</li>\n<li><p>存储引擎</p>\n<ul>\n<li>Myisam<ul>\n<li>不支持事务</li>\n<li>不支持外键</li>\n<li>仅支持表锁</li>\n<li>在并发操作时需要加锁，可能导致读写冲突，有性能瓶颈，并发性能较低</li>\n<li>没有缓冲池机制</li>\n<li>叶子结点保存的是数据的地址</li>\n</ul>\n</li>\n<li>innoDB<ul>\n<li>支持事务</li>\n<li>支持外键</li>\n<li>可支持行锁</li>\n<li>具有 MVCC 机制，可以实现读取操作不阻塞写入操作，提供了更好的并发性能</li>\n<li>InnoDB 采用了缓冲池机制，将数据和索引缓存到内存中，加快数据的访问速度。</li>\n<li>叶子结点保存的就是数据</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数据库主键是否可以用 string 类型，比如说 UUID，优缺点是什么</p>\n<ul>\n<li>断言：可以，有优势有劣势，需要做取舍</li>\n<li>优势<ul>\n<li>全局唯一性：UUID 是一个由 128 位数字组成的字符串，几乎可以保证在不同系统和数据库之间的唯一性。这对于分布式系统和多个独立数据库之间的数据一致性非常重要。</li>\n<li>无需数据库自增：可以方便地在分布式环境中生成主键，而无需额外的同步机制</li>\n</ul>\n</li>\n<li>劣势<ul>\n<li>存储空间占用：相比于整数类型的主键，string 类型的主键会占用更多的存储空间</li>\n<li>索引效率低下：string 类型的主键会导致索引文件变大、需要更多的磁盘 IO 和内存消耗，会降低我们的索引效率，也就降低了我们的查询效率</li>\n<li>不适合作为聚焦索引：聚集索引的顺序会对数据的存储和访问效率产生影响，而 UUID 的无序性会导致频繁的数据页分裂和不均匀的存储</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Mysql 集群</p>\n<ul>\n<li>主从复制<ul>\n<li>原理：主服务器上的写操作会立即被记录到二进制日志，并通过网络传输到从服务器，然后在从服务器上执行相同的操作来复制数据。复制过程是异步的，主服务器上的写操作并不会等待从服务器的执行完成。 但是如果主服务器发生故障或网络中断，复制会暂时停止。当主服务器恢复后，从服务器会自动重新连接并继续复制。</li>\n<li>优点<ul>\n<li>读写分离：主服务器负责处理写操作，而从服务器可以处理读操作。</li>\n<li>故障恢复：当主服务器发生故障时，可以将其中一个从服务器提升为新的主服务器，实现快速的故障转移和自动恢复，降低业务中断时间。</li>\n<li>扩展性：通过添加更多的从服务器，可以水平扩展数据库系统，处理更大规模的并发请求和数据量。</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>数据延迟：由于主从复制是异步的过程，从服务器上的数据复制存在一定的延迟。这意味着从服务器上的数据可能不是实时的，可能存在一小段时间的数据不一致。</li>\n<li>单点故障：从复制架构中的主服务器仍然是单点故障的风险。如果主服务器发生故障，需要手动切换到一个备用的从服务器来代替主服务器，可能导致一定的停机时间和数据丢失。</li>\n<li>无法水平扩展写操作：主从复制只能将写操作限制在主服务器上，从服务器只能进行读操作。这限制了系统的写操作扩展性，主服务器的性能成为瓶颈</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>双主模式<ul>\n<li>优点<ul>\n<li>高可用性：双主模式提供了更高的可用性，因为系统不会出现单点故障。如果其中一个主服务器发生故障，另一个主服务器可以继续处理写操作，从而实现故障转移并保持业务的连续性。</li>\n<li>数据一致性：在双主模式下，每个主服务器都可以接收和处理写操作，写操作会同时在两个主服务器上执行。这意味着数据在两个主服务器之间具有更高的一致性，不会出现主从复制的延迟和不一致性问题。</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>冲突处理：在双主模式下，同时在两个主服务器上执行写操作可能会导致数据冲突的问题。例如，如果两个主服务器同时修改相同的数据行，就会出现冲突，需要解决冲突并确保数据一致性。</li>\n<li>配置和管理复杂性：双主模式的配置和管理相对复杂。需要确保双主服务器之间的复制设置正确，并处理可能出现的冲突和同步问题。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>count，sum，avg 对 null 和空串的处理</p>\n<ul>\n<li>count：count(*)会计算 null 和空串，count 具体一个字段会忽略 null，不会忽略空串</li>\n<li>sum：不计算 null 和空串</li>\n<li>avg：不计算 null 为行，但是会把空串计算成一行</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><ol>\n<li>缓存故障<ul>\n<li>缓存穿透<ul>\n<li>概念：是用户访问的数据既不在缓存当中，也不在数据库中。当高并发或有人利用不存在的 Key 频繁攻击时，数据库的压力骤增，甚至崩溃，这就是缓存穿透问题。</li>\n<li>解决方法：可以通过布隆过滤器等方式，在缓存中添加一个不存在的数据时，先判断其是否存在于布隆过滤器中，如果不存在则直接返回，避免大量的请求直接访问数据库。</li>\n</ul>\n</li>\n<li>缓存击穿<ul>\n<li>概念：指一个存在的 key，在缓存过期的一刻，同时有大量的请求访问这个 key，由于缓存失效，请求会穿透缓存直接访问数据库，造成数据库压力过大。</li>\n<li>解决方案：可以采用永不过期的方式或者在缓存中添加短暂的二级缓存等方式来解决缓存击穿问题。</li>\n</ul>\n</li>\n<li>缓存雪崩<ul>\n<li>概念：指缓存中的大量数据同时过期失效，导致大量请求直接访问数据库，造成数据库压力过大。</li>\n<li>解决方案：可采用数据预热，提前将缓存数据加载到缓存中，还可以设置多级缓存, 还可采用使用分布式锁控制只有一个请求来重新加载缓存数据，避免缓存雪崩。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li>数据库缓存一致性<ul>\n<li>双写模式: 通常使用的是“先更新数据库，立马更新缓存”的顺序，以确保数据一致性。如果更新缓存失败，可以将缓存标记为失效，让下一次查询时重新从数据库中获取数据。(每次写入都要写入两个地方，可能造成更新操作变慢)</li>\n<li>延时双删：在更新数据库时，先给缓存中的数据设置过期时间，然后等待一定时间后再删除缓存数据。(一定时候后才更新缓存，让数据库读写操作更快一点)</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>Redis 的持久化策略</p>\n<ul>\n<li>RDB 持久化 : Redis 会周期性地将内存中的数据集快照写入磁盘，即生成一个 RDB 文件，可能会丢失最后一次快照以后的所有修改。</li>\n<li>AOF 持久化 : Redis 会将执行的每个写命令都记录到一个追加的文件中，在 Redis 重启时，会重新执行 AOF 文件中的所有写命令，以便恢复原始数据集，但会导致更高的磁盘空间占用和更慢的写入性能。</li>\n</ul>\n</li>\n<li><p>Redis 的数据类型</p>\n<ul>\n<li><p>字符串类型(string)：</p>\n<ul>\n<li>用于存储单个值，例如整数、浮点数、字符串等。</li>\n</ul>\n</li>\n<li><p>列表类型（list）：有序集合</p>\n<ul>\n<li>消息队列：使用 lpush 和 brpop 实现阻塞队列</li>\n<li>分页查询：使用 lrange 和下标来实现分页读取</li>\n</ul>\n</li>\n<li><p>哈希类型（hash）：映射表</p>\n<ul>\n<li>可以存储一些用户信息，订单信息，用户 ID 或订单 ID 作为 hashKey</li>\n<li>实现购物车功能，用户 ID 作为缓存 Key，商品编码作为 hashKey，商品信息作为 hashValue</li>\n</ul>\n</li>\n<li><p>集合类型（set）：无序不重复集合</p>\n<ul>\n<li>社交类软件的共同好友，比如说抖音的共同好友</li>\n<li>统计访问我们网站的 IP 地址</li>\n</ul>\n</li>\n<li><p>有序集合类型（sorted set）：有序不重复集合，但每个元素都有一个分数（score）与之关联，并按照分数排序，底层是跳表 + 压缩列表，当有序集合保存的元素数量小于 128 个且有序集合保存的所有元素的总大小小于 64 字节的时候用压缩列表</p>\n<ul>\n<li>排行榜的，带有权重的且不允许重复的，都可以用 zset</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p>Redis 的数据淘汰策略</p>\n<ul>\n<li>LRU (最近最少使用): Redis 会根据键最后一次被访问的时间来删除最近最少使用的键。当内存达到限制时，Redis 会优先删除最久未被访问的键，以释放更多的内存空间。</li>\n<li>LFU (最不经常使用)：Redis 会根据键被访问的次数来删除最不经常使用的键。当内存达到限制时，Redis 会优先删除被访问次数最少的键，以释放更多的内存空间。</li>\n<li>TTL (生存时间)：Redis 会根据键的生存时间来删除过期键。每个键都可以设置一个生存时间，当键的生存时间到期时，Redis 会自动删除该键。</li>\n<li>Random (随机)：Redis 会随机删除一些键来释放内存空间。这种策略没有考虑键的访问时间或频率，因此可能会删除一些有用的键。</li>\n<li>Maxmemory-policy（最大内存策略）：这是一种基于多个淘汰策略的组合策略。Redis 会根据当前内存使用量和内存限制来选择合适的淘汰策略。例如，在内存使用量接近内存限制时，Redis 会使用 LRU 或 LFU 策略来删除最近或最不经常使用的键，以保留更多的内存空间。</li>\n</ul>\n</li>\n<li><p>Redis 为什么快</p>\n<ul>\n<li>完全基于内存，通过磁盘 IO 读取到内存这部分的开销</li>\n<li>数据结构简单，对数据操作也简单，主要使用 string、list、hash、set、zset 这几种数据结构</li>\n<li>采用单线程来处理，省去了很多上下文切换的时间以及 CPU 消耗</li>\n<li>使用基于 IO 多路复用机制的线程模型，可以处理并发的链接</li>\n</ul>\n</li>\n<li><p>Redis 分布式锁</p>\n<ul>\n<li>背景<br>  为什么要有分布式锁：传统的锁，包括 sychronized、包括 ReentrantLock 都只能锁单机，只能控制多线程对单机的访问，但是如果基于分布式架构，比如说在我们的微服务应用当中，不同的服务部署在不同的机器上，且各个服务之间也有交互，则传统的锁就会失效，所以需要一个能够在分布式架构中也能起到访问控制的锁出现，也就是我们的分布式锁，而其中 redis 分布式锁就是其中的一种</li>\n<li>原理<ul>\n<li>基于 setNx：setNx 是 Redis 的一个原子操作，用于设置一个键值对，但只在键不存在时才执行。要获取锁，客户端可以使用 SETNX 命令在 Redis 中创建一个特定的键，并设置一个随机的唯一标识作为值。如果 SETNX 操作返回 1，表示客户端成功获取到锁；如果返回 0，表示锁已被其他客户端持有。在释放锁时，客户端可以使用 DEL 命令删除对应的键。</li>\n</ul>\n</li>\n<li>命令<ul>\n<li>SET key value [EX seconds] [PX milliseconds] [NX|XX]: 尝试给指定的 key 设置一个对应的 value。该指令可以用于获取锁。参数 EX 和 PX 用于设置键的过期时间，NX 表示只在键不存在时设置值（用于获取锁），XX 表示只在键已经存在时设置值（用于释放锁）。</li>\n<li>GETSET key value: 设置给定 key 的 value 并返回旧的 value。该指令可用于检查并更新锁的值。</li>\n<li>DEL key: 删除指定的 key。该指令可用于释放锁。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Zookeeper 锁</p>\n</li>\n</ol>\n<ul>\n<li><p>原理</p>\n<ul>\n<li><p>创建锁节点：当一个进程或线程需要获取锁时，它会在 ZooKeeper 上创建一个有序临时节点（例如：/locks/lock-000000001）。</p>\n</li>\n<li><p>检查前一个节点：进程会获取当前创建的有序节点的序号，并检查是否它是当前锁下的最小序号节点。如果是最小节点，表示当前进程获取到了锁，可以执行相关操作。否则，进程会监听前一个节点（例如：/locks/lock-000000000）的删除事件。</p>\n</li>\n<li><p>监听前一个节点：进程在 ZooKeeper 上对前一个节点进行注册监听器。如果前一个节点被删除（即前一个进程释放了锁），ZooKeeper 会通知当前进程。</p>\n</li>\n<li><p>锁释放：当进程完成了任务，它会删除自己创建的节点，从而释放锁。这会触发 ZooKeeper 通知下一个等待的进程。</p>\n</li>\n</ul>\n</li>\n<li><p>总结</p>\n<ul>\n<li><p>通过这个基本的原理，ZooKeeper 锁可以实现互斥访问，保证在任意时刻只有一个进程能够获取到锁，其他进程需要等待。同时，ZooKeeper 的有序临时节点保证了节点创建的顺序，进程可以根据节点的序号判断自己是否是当前锁下的最小节点。</p>\n</li>\n<li><p>需要注意的是，使用 ZooKeeper 锁时要处理会话过期和网络分区等异常情况。当一个进程的会话过期或与 ZooKeeper 服务器失去连接时，它创建的临时节点会被自动删除，从而释放锁。此外，由于 ZooKeeper 是一个分布式系统，网络分区或 ZooKeeper 服务器故障可能会导致锁的不可用性或不确定性。因此，在使用 ZooKeeper 锁时，需要考虑这些异常情况并进行相应的处理和恢复机制。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ol start=\"8\">\n<li><p>Redis 集群</p>\n<ul>\n<li><p>主从复制</p>\n<ul>\n<li><p>作用：对读写能力扩展，采用读写分离的方式解决性能瓶颈</p>\n</li>\n<li><p>数据同步</p>\n<ul>\n<li>同步策略：主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li>\n<li>全量同步<ul>\n<li>从服务器连接主服务器，发送 SYNC 命令；</li>\n<li>主服务器接收到 SYNC 命名后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；</li>\n<li>主服务器 BGSAVE 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li>\n<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li>\n<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li>\n<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>\n</ul>\n</li>\n<li>增量同步<ul>\n<li>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</li>\n<li>Redis 增量复制是指 Slave 初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优势</p>\n<ul>\n<li>读写分离：主从复制，主机会自动将数据同步到从机，实现了读写分离</li>\n<li>分担主服务器压力：从服务器同样可以接受其他从服务器的连接和同步请求，这样可以有效的分载主服务器的同步压力</li>\n<li>非阻塞提供服务：主服务器是以非阻塞的方式为从服务器提供服务，所以在主从同步期间，客户端依然可以提交查询或修改请求，从服务器也是以非阻塞的方式完成数据同步的，在同步期间，如果有客户端提供查询请求，Redis 则返回同步之前的数据。</li>\n</ul>\n</li>\n<li><p>劣势</p>\n<ul>\n<li>容易发生单点故障的问题，主机宕机之后，则无法进行写请求，需要人工干预来选择新的主节点</li>\n<li>主机宕机后如果有部分数据没有及时同步到从机，更换主机 IP 后会导致数据不一致的问题</li>\n<li>如果多个从机断线，需要重启的时候，如果在同一时间段进行重启，多个 slave 重启，都会发送 sync 请求 (redis2.8 之后是 psync) 并进行主机全量同步，那就会导致主机 IO 剧增从而主机宕机</li>\n<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容就会变得艰难</li>\n</ul>\n</li>\n<li><p>psync 和 sync 的区别：psync 是只同步掉线期间的数据，sync 是全量同步</p>\n</li>\n</ul>\n</li>\n<li><p>哨兵机制</p>\n<ul>\n<li>作用：用一个哨兵来监控所有的服务器状态，一旦发现某个主服务器宕机或故障了，就自动让从服务器顶上去</li>\n<li>原理：哨兵是一个独立的进程，会独立运行，哨兵进程通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器当哨兵进程检测到某个主机宕机后，会自动将 slave 切换为 master，然后通过发布订阅模式同之其他从服务器，修改配置文件，让他们切换主机</li>\n<li>服务器下线认定<ul>\n<li>主观下线：如果一个服务器没有在 master-down-after-milliseconds 选项所指定的时间内，对向它发送 PING 命令的哨兵返回一个有效的回复，那么哨兵就会将这个服务器标记为主观下线</li>\n<li>客观下线：客观下线的评判由多个哨兵完成，一个主机是否下线，由多个哨兵投票完成，当多个哨兵说该主机下线了，那么它就是下线了</li>\n<li>主观切换到客观标准：如果哨兵在给定范围内，从其他哨兵那里接收到了足够数量的主服务器下线报告，那么哨兵就会将主服务器的状态从主观下线切换为客观下线</li>\n<li>下线标记去除：如果没有足够的哨兵进程同意主服务器下线，那么主服务器的客观下线状态标记就会被移除，如果主服务器重新向哨兵发送的 PING 命令返回了有效的回复，主服务器的主观下线状态就会被移除</li>\n<li>补充：客观下线只适用于主服务器，对于其他类型的 Redis 实例，哨兵在将它们判断为下线前不需要进行协商，所以从服务器或其他哨兵不会达到客观下线条件。</li>\n</ul>\n</li>\n<li>任务<ul>\n<li>监控（Monitoring）： 哨兵会不断检查主服务器和从服务以及其他哨兵是否运作正常</li>\n<li>提醒（Notification）: 当被监控的某个服务器出现问题时，哨兵可以通过 API 向管理员或其他应用程序发送通知</li>\n<li>自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时，哨兵会开始一次自动故障转移操作，它会将失效的主服务器的其中一个从服务器升级为新的主服务器，并让失效的主服务器的其他从服务器知晓新的主服务器。当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。</li>\n</ul>\n</li>\n<li>优势<ul>\n<li>从上文可以看出，哨兵机制集群模式是基于主从复制模式的，所以它有主从复制的所有优点</li>\n<li>主从服务器可以自动切换，系统更加健壮，可用性更高</li>\n</ul>\n</li>\n<li>劣势<ul>\n<li>内存浪费：每台 Redis 服务器都存储了相同的数据，非常浪费内存</li>\n<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容就会变得很复杂</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Cluster 模式(Redis 内置集群)</p>\n<ul>\n<li>架构图 <img src = \"http://xtzl.wentexl.cn/redis%E7%9A%84cluster.png\"/></li>\n<li>作用：每台 Redis 节点上存储了不同的内容</li>\n<li>原理：任意两个节点之间都是相互连通的（采用的是 PING-PONG 机制），内部使用二进制协议优化传输速度和带宽。客户端可以与任意一个节点相连，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作，Redis 集群使用的是哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 Key 通过 CRC16 校验后对 16384 取模来决定放置在那个槽。集群中的每个节点负责一部分的 hash 槽，意思是无论有多少个节点，都只有 16384 个槽来分</li>\n<li>保证高可用：Redis-Cluster 集群引入了主从复制模型，一个主节点对应一个或多个从节点，当主节点宕机后，就会启用从节点</li>\n<li>对主机的宕机判断：采用的是投票方式，当其它主节点 ping 一个主节点时，如果半数以上的主节点与其通信超时，那么就认为该主节点宕机了，为了得出投票结果，主节点个数一般是奇数。</li>\n<li>优势<ul>\n<li>使用这种架构很容易添加或删除节点，比如如果想删除某个节点，那么就将该节点的槽移动到其他节点上，然后将没有任何槽的节点移除</li>\n<li>在一定程度上节约了内存空间</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>reids 判断键已过期</p>\n<ul>\n<li>定期删除：Redis 服务器会周期性地（默认每秒钟 10 次）随机检查一部分设置了过期时间的键，并删除其中已经过期的键。这个过程是通过 Redis 的『定时器』来完成的，每次执行一小部分过期键的删除操作，以避免对服务器的性能产生明显的影响。</li>\n<li>惰性删除：当客户端访问一个设置了过期时间的键时，Redis 会先检查这个键是否已经过期，如果过期则立即删除。这种方式确保了过期键能够在被访问时立即被删除。</li>\n</ul>\n</li>\n<li><p>redis 的 key</p>\n<ul>\n<li><p>热 key（hotkey）：访问十分频繁的 key</p>\n<ul>\n<li>场景<ul>\n<li>爆款商品</li>\n<li>热点新闻</li>\n<li>热门活动</li>\n</ul>\n</li>\n<li>问题<ul>\n<li>缓存击穿</li>\n<li>占用 CPU 资源，使效率降低，可能会影响到其他业务</li>\n<li>热 key 所在的节点访问量大，容易造成物理网卡瓶颈</li>\n</ul>\n</li>\n<li>解决方案<ul>\n<li>做二级缓存，添加一个本地缓存来存热 key</li>\n<li>熔断限流，可以针对热 key 做单点限流，限定缓存集群的 qps</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>大 key（bigkey）：存放的数据特别大的 key</p>\n<ul>\n<li>场景<ul>\n<li>String 存放的数据大于 10k</li>\n<li>集合类型的存放的数据量超过五千个，或者个数不多，但是每个数据都很大，导致整体数据较大</li>\n</ul>\n</li>\n<li>问题<ul>\n<li>网络拥塞：如果一个 Key 占用的空间很大，那么每次访问都会消耗大量的网络带宽，可能导致机器或局域网的流量被打满，影响其他服务的通信。</li>\n<li>在操作大 key 时会比较耗时，客户端有可能会超时阻塞。</li>\n<li>在删除的时候如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>\n</ul>\n</li>\n<li>解决方案<ul>\n<li>将一个大 key 按逻辑分为若干个小 key</li>\n<li>制定合适的内存淘汰策略，及时淘汰和清理掉无效数据</li>\n<li>使用合适的数据结构来存储数据，例如 Hash</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"MQ\"><a href=\"#MQ\" class=\"headerlink\" title=\"MQ\"></a>MQ</h2><h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><blockquote>\n<p>优秀博文：<a href=\"https://baijiahao.baidu.com/s?id=1737713844357727373&amp;wfr=spider&amp;for=pc\">https://baijiahao.baidu.com/s?id=1737713844357727373&amp;wfr=spider&amp;for=pc</a></p>\n<hr>\n<ul>\n<li>消息消费失败，由于 retry 重试机制，重新入队又将消息发送出去。</li>\n<li>消息确认机制影响性能，非必要不使用；</li>\n<li>消费者先保证消息能签收，业务处理失败可以人工补偿。</li>\n</ul>\n<hr>\n</blockquote>\n<ol>\n<li><p>交换机类型</p>\n<ul>\n<li>FanoutExchange : 广播交换机，适用于简单模式、订阅模式、工作队列模式</li>\n<li>DirectExchange : 路由定向交换机，适用于路由模式</li>\n<li>HeadersExchange: 头交换机，适用于路由模式, 路由交换机的路由是基于路由键，头交换机的路由值基于消息的 header 数据。</li>\n<li>TopicExchange : 主题交换机，适用于通配符模式</li>\n</ul>\n</li>\n<li><p>重复消费问题</p>\n<ul>\n<li>产生原因   <ul>\n<li>消息消费成功: 事务已提交，签收时结果服务器宕机或网络原因导致签收失败，消息状态会由 unack 转变为 ready，重新发送给其他消费方</li>\n<li>消息消费失败: 由于 retry 重试机制，重新入队又将消息发送出去。</li>\n</ul>\n</li>\n<li>解决方案<ul>\n<li>开启手动 ACK 的机制，当消费端消费成功之后会给服务端发送一条确定信息，当收到确认信息之后，我们在服务端才让下一个消息进行消费。默认是自动 ACK，也就是消费端消费成功了不会发送信息给服务端。</li>\n<li>使用唯一的消息 ID，并存到数据库中，每次消费者消费之前都去检查一下这条消息是否被消费过，如果没有才进行消费</li>\n<li>使用分布式锁的方式，比如说 redis 的分布式锁命令 setNX</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何保证消费顺序</p>\n<ul>\n<li>在生产端可以给每个消息一个序号，然后消费端按照排序的序号进行消费</li>\n<li>采用单队列单消费者的模式，将同一消息类型的消息放到一个队列中去，因为消费顺序主要是由于不同消费端对不同消息的处理能力不同导致的</li>\n</ul>\n</li>\n<li><p>消息丢失</p>\n<ul>\n<li>产生原因<ul>\n<li>消息发出后，中途网络故障，服务器没收到；</li>\n<li>消息发出后，服务器收到了，消费方还未处理业务逻辑，服务却挂掉了，而消息也自动签收，等于啥也没干。</li>\n</ul>\n</li>\n<li>解决方案<ul>\n<li>confirm 模式 ： 保证生产端到交换机这段路，消息无论是否成功被交换机拿到，都要返回一个确认消息</li>\n<li>return 模式： 保证交换机到队列这段路，消息没能到队列才发送一个返回消息。</li>\n<li>手动 ACK 模式：消费成功才将消息移除，失败或因异常情况而尚未处理，就重新入队。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><ol>\n<li><p>消息丢失</p>\n<ul>\n<li>解决方案<ul>\n<li>服务端持久化设置为同步刷盘：消息投递到 broker 的时候，需要将消息进行持久化，分同步刷盘和异步刷盘，同步刷盘的话可保证消息一定不丢失，就算丢失了也可以选择即时补偿，也就是重新发一次</li>\n<li>生产者设置为同步投递：使用带有回调通知的 send 方法，并且设置 acks = all，则可保证是同步方式，也就是说必须要让服务器确认收到消息之后才会继续往下执行。如果服务器没来得及接收就宕机了，也可以保证消息不丢失，因为生产者在投递消息的时候会有记录日志，等服务器重启之后，可以通过日志信息去完成对消息的补偿</li>\n<li>消费者设置成手动 ack 提交: kafka 中，消息消费完成之后不会立即删除，而是使用定时的清除策略，当我们确保消息成功消费之后，我们要进行手动的 ack 提交，如果消息失败，则要不断重试</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>消息顺序</p>\n<ul>\n<li>触发场景<ul>\n<li>一个 topic 有多个 partition，producer 生产者将一组有序的消息被分散发送到了不同的 partition</li>\n<li>多个消费者消费了同一个 partition 的消息</li>\n</ul>\n</li>\n<li>解决方案<ul>\n<li>单线程发送消息到 MQ，单线程对 MQ 进行消费，即消费者和生产者都是单线程的，且 Topic 中只有一个 partition</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>重复消费</p>\n<ul>\n<li>触发场景<ul>\n<li>消费者宕机且还未来得及向 GroupCoordinator 的_consumer_offsets 提交位移，默认是每 5s 提交一次，重启后会导致重复消费的问题</li>\n<li>消费端处理性能较低，在默认的 5 分钟以内没办法处理完消息，则会触发 Rebalance 机制，原分区交给其他的消费者消费了，但是由于_consumer_offsets 的滞后性，所以原分区仍然会存在一部分消息会被新的消费者重复消费</li>\n</ul>\n</li>\n<li>解决方案<ul>\n<li>采用异步的方式处理消息，缩短消息的消费时长</li>\n<li>调整消息处理的默认时间，可以拉长一点，避免触发 rebalance 机制</li>\n<li>对每个消息都设置一个唯一键，可以保存在 mysql 或者 redis 中，在消费消息之前先去 mysql 或者 redis 中判断是否该消息已经被消费，如果被消费了则跳过消费</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Kafka 的选举策略</p>\n<ul>\n<li>Controller 的选举<ul>\n<li>原理：所有的 broker 都尝试去在 zookeeper 中创建一个临时的节点 controller，谁先创建成功，谁就担任了 controller 的角色，如果挂了或者网络出现问题，则临时节点就会消失，需要按先到先得来重新选举。</li>\n<li>职责：<ul>\n<li>监听 Broker、Topic、Partition 的变化</li>\n<li>获取和管理 Broker、Topic、Partition 的信息</li>\n<li>获取 Partition 的主从信息，并参与 leader 的选举过程</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Leader 的选举<ul>\n<li>原理：在 ISR 集合中的副本通常是与原 leader 保持数据同步的副本，具有优先被选择权，默认让 ISR 的第一个副本成为 Leader。但是如果 ISR 中没有副本，则可以通过调整设置，默认让拥有最新数据的那个副本成为 leader</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"基础学科\"><a href=\"# 基础学科\" class=\"headerlink\" title=\"基础学科\"></a>基础学科 </h2><h3 id=\"数据结构\"><a href=\"# 数据结构\" class=\"headerlink\" title=\"数据结构\"></a> 数据结构</h3><ol>\n<li><p>HashMap 的原理</p>\n<ul>\n<li>在 jdk1.7 与 jdk1.8 的区别：<ul>\n<li>数据结构：jdk1.7 是数组 + 链表，jdk1.8 引入了红黑树这样一种综合能力强的数据结构</li>\n<li>插入方法：jdk1.7 是采用的头插入法来将元素插入进链表，这可能导致链表倒置，jdk1.8 是采用的尾插法来将元素插入进链表</li>\n<li>扩容优化：数组容量大于 64 且链表长度大于 8，会首先将链表转成红黑树，并不会直接扩容</li>\n</ul>\n</li>\n<li>为什么使用红黑树<ul>\n<li>红黑树也是一种平衡二叉树，它各个节点着色方式的限制，确保没有任意一条从根到叶子的路径超过最短路径的两倍。它是一种弱平衡二叉树，但是它有着良好的稳定性和完整的功能，性能表现也很不错，综合实力强。相对于 AVL 树来说，红黑树的旋转次数少，对于搜索、插入、删除多的操作下用红黑树就更为合适了。</li>\n</ul>\n</li>\n<li>多线程导致的问题<ul>\n<li>线程安全问题：HashMap 不是线程安全的，多个线程同时对 HashMap 进行操作可能会导致数据的不一致性，例如 put 和 remove 操作可能导致元素丢失或重复等问题。</li>\n<li>性能问题：当多个线程同时对 HashMap 进行操作时，由于需要进行锁竞争或者 CAS 操作，可能会导致性能下降，尤其是在高并发情况下。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Concurrenthashmap 原理</p>\n<ul>\n<li><p>数据结构</p>\n<ul>\n<li>jdk1.7：JDK 1.7 中的 ConcurrentHashMap 的每个 Segment 段中的数据结构是数组 + 链表</li>\n<li>jdk1.8：而在 JDK 1.8 中，ConcurrentHashMap 使用了更为高效的数据结构，引入了红黑树。</li>\n</ul>\n</li>\n<li><p>并发度</p>\n<ul>\n<li>jdk1.7：JDK 1.7 的 ConcurrentHashMap 的并发度是固定的，即段的数量是固定的，由构造函数中的参数指定。</li>\n<li>jdk1.8：在 JDK 1.8 中，ConcurrentHashMap 不再使用固定的段，而是根据实际数据和并发访问情况来动态地扩展和收缩哈希表的大小。</li>\n</ul>\n</li>\n<li><p>锁粒度</p>\n<ul>\n<li>jdk1.7：JDK 1.7 的 ConcurrentHashMap 使用分段锁，即每个段都有一个独立的锁来保护它的元素。这意味着不同的线程可以同时访问和修改不同的段，从而提高并发性能。</li>\n<li>jdk1.8： JDK 1.8 中，ConcurrentHashMap 引入了更细粒度的锁策略，即将锁的粒度缩小到每个桶（bucket）级别，也就是数组中的每个元素都有一个独立的锁。</li>\n</ul>\n</li>\n<li><p>锁策略(针对于 put 或者 remove 操作)</p>\n<ul>\n<li>jdk1.7：定位之后会采用自旋锁 + 锁膨胀的机制进行加锁，也就是自旋获取锁，当自旋次数超过 64 时，会发生膨胀，直接陷入阻塞状态，等待唤醒。并且在整个 put 操作期间都持有锁。</li>\n<li>jdk1.8: 采用 CAS+synchronized 的机制。如果对应下标处没有结点，说明没有发生哈希冲突，此时直接通过 CAS 进行插入，若成功，直接返回。若失败，则使用 synchronized 进行加锁插入。</li>\n</ul>\n</li>\n<li><p>和 HashMap 的区别</p>\n<ul>\n<li>ConcurrentHashMap 采用了分段锁技术来保证并发访问的线程安全性，在加锁的时候不必要锁住整个 Map</li>\n<li>ConcurrentHashMap 在扩容时只需要对 Segment 段进行扩容，而不需要对整个 Map 进行扩容，因此扩容的代价相对较小</li>\n<li>ConcurrentHashMap 对于读操作和写操作进行了分离，对于读操作没有加锁，可以实现读取的高并发性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>B 树和 B+ 树之间的区别</p>\n<ul>\n<li><p>B 树</p>\n<ul>\n<li>它是一种多路的平衡搜索树。</li>\n<li>它跟普通的平衡二叉树的不同是，B 树的每个节点可以存储多个数据，而且每个节点不止有两个子节点，最多可以有上千个子节点。</li>\n<li>B 树中每个节点都存放着索引和数据，数据遍布整个树结构，搜索可能在非叶子节点结束，最好的情况是 O(1)。</li>\n</ul>\n</li>\n<li><p>B+ 树</p>\n<ul>\n<li>B+ 树的层级更少：相较于 B 树 B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快。</li>\n<li>B+ 树查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比 B 树更稳定</li>\n<li>B+ 树区间查询更方便：B+ 树所有的叶子节点数据构成了一个双向链表，在查询大小区间的数据时候更方便，数据紧密性很高。</li>\n<li>B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历  所有的叶子节点即可，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>\n</ul>\n</li>\n<li><p>InnoDB 为什么选择 B+ 树</p>\n<ul>\n<li>扫库、扫表能力更强：如果我们要对表进行全表扫描，只需要遍历叶子节点就可以了，不需要遍历整棵 B+ 树</li>\n<li>数据连续可达：叶子节点上有下一个数据区的指针，数据形成了链表</li>\n<li>效率稳定：B+ 树永远是在叶子节点拿到数据，所以 IO 次数是稳定的，而 B 树运气好的话根节点就能拿到数据，运气不好就要到叶子节点才能拿到数据，所花费的时间会有差异。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>队列和堆栈</p>\n<ul>\n<li>队列<ul>\n<li>顺序：先入先出</li>\n<li>可在一端插入，另一端删除</li>\n<li>可基于地址指针，从头部或者尾部来遍历，且不需要开辟临时空间，遍历速度更快</li>\n<li>场景：任务调度、消息传递等场景</li>\n</ul>\n</li>\n<li>栈<ul>\n<li>顺序：后入先出</li>\n<li>插入和删除在同一端</li>\n<li>只能从顶部取数据，且需要开辟临时空间，如若要取栈底的元素，得先把所有元素给取出来一遍才行，遍历速度更慢</li>\n<li>场景：回溯、表达式求值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>压缩列表</p>\n<ul>\n<li>概念：为了更好的利用数组的优势（排列紧凑，内存连续），同时避免内存浪费，每个节点可以存放不同大小的元素</li>\n<li>组成部分：<ul>\n<li>zlbytes：记录整个压缩列表占用的内存字节数</li>\n<li>zltail：偏移量，记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，可以计算出表尾节点的地址</li>\n<li>zllen：压缩列表包含的节点数量</li>\n<li>entry：列表节点<ul>\n<li>previous_entry_length: 记录上一个节点的长度，为了方便反向遍历 ziplist</li>\n<li>encoding: 当前节点的编码规则，记录了节点的 content 属性所保存数据的类型以及长度</li>\n<li>content: 当前节点的值，可以是数字或字符串。</li>\n</ul>\n</li>\n<li>zlend：用于标记压缩列表的末端</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"计算机网络\"><a href=\"# 计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h3><ol>\n<li><p>TCP 和 UDP (传输层协议)</p>\n<ul>\n<li><p>比较</p>\n<ul>\n<li>可靠性：TCP 是一种面向连接的协议，提供可靠的数据传输。它使用确认、重传和流量控制等机制来确保数据的完整性和顺序。UDP 是一种无连接的协议，不提供可靠性保证，数据传输可能丢失、重复或乱序。</li>\n<li>连接过程：TCP 建立连接和断开连接的过程较为复杂，包括三次握手和四次挥手，确保通信双方建立可靠的连接。UDP 没有连接建立的过程，每个数据包都是独立的，可以直接发送。</li>\n<li>速度和效率：由于 TCP 提供可靠性保证和连接管理，它的开销较大，传输速度相对较慢。UDP 没有这些额外的开销，因此传输速度较快，效率较高。</li>\n<li>数据量限制：TCP 对数据包的大小有限制，因为 TCP 报文段的最大长度受到网络的最大传输单元（MTU）限制。UDP 没有这个限制，可以发送更大的数据包。</li>\n</ul>\n</li>\n<li><p>TCP 可靠性的保证</p>\n<ul>\n<li>确认机制：TCP 将每个发送的数据包进行编号（序列号），接收端通过发送确认消息来确认已经成功接收到的数据。如果发送端没有收到确认消息，就会重新发送数据。</li>\n<li>超时与重传：TCP 使用超时重传机制。如果发送端在合理的时间内没有收到确认消息，就会认为数据包丢失，触发重传机制，重新发送数据。</li>\n<li>流量控制：TCP 通过使用滑动窗口机制进行流量控制。接收端通过发送窗口大小的信息告知发送端自己的可接收数据量，以避免发送太多数据导致接收端无法处理。</li>\n</ul>\n</li>\n<li><p>TCP 粘包问题</p>\n<ul>\n<li>概念：当发送方在短时间内连续发送多个数据包时，接收方在接收数据时可能会将多个数据包合并成一个数据包，从而导致数据包大小超过了接收缓冲区的大小，这就是所谓的粘包问题。</li>\n<li>导致原因：由于数据包的边界不明确或者多个数据包连续发送导致接收端难以正确解析和处理数据</li>\n<li>解决方案：<ul>\n<li>采用特定的分隔符。发送方在发送数据包之前，在数据包中加入特定的分隔符，接收方在接收数据包时根据分隔符将数据包进行分割。</li>\n<li>采用消息头和消息体。发送方在发送数据包之前，在数据包中加入消息头和消息体，消息头用于标识消息体的长度和类型，接收方在接收数据包时根据消息头将数据包进行分割。</li>\n<li>定长包格式：可以使用定长的包格式，确保每个数据包都具有相同的长度。接收端按照固定长度进行解析，从而避免了粘包问题。但是这种方法可能会浪费一些空间，因为包中的数据长度不一定总是满载。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>http 与 https(应用层协议)</p>\n<ul>\n<li>http<ul>\n<li>概念：HTTP 代表超文本传输协议，它是用于在 Web 浏览器和 Web 服务器之间传输数据的协议。</li>\n<li>机制：HTTP 协议是明文传输数据的，这种明文传输数据的方式存在一定的风险，特别是在传输敏感信息时。</li>\n</ul>\n</li>\n<li>https<ul>\n<li>概念：HTTPS 代表安全超文本传输协议，它是 HTTP 协议的安全版本。</li>\n<li>机制：在 HTTPS 下，传输的数据是通过 SSL 或 TLS 加密的，这样攻击者即使截取到了数据，也无法轻易地解密和阅读其中的内容。HTTPS 还能够验证服务器的身份，确保用户正在与其信任的网站通信，而不是被攻击者伪装的恶意网站。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Http 状态码</p>\n<ul>\n<li>200 OK：请求成功。服务器成功处理了请求，并返回了请求的数据。</li>\n<li>301 Moved Permanently：永久重定向。请求的资源已被永久移动到新的 URL。</li>\n<li>302 Found：临时重定向。请求的资源已被临时移动到新的 URL。</li>\n<li>400 Bad Request：错误请求。服务器无法理解请求，因为请求中包含语法错误。</li>\n<li>401 Unauthorized：未授权。请求需要用户身份验证，但用户未提供有效的身份验证信息。</li>\n<li>403 Forbidden：禁止访问。服务器拒绝了请求，因为请求者没有访问资源的权限。</li>\n<li>404 Not Found：未找到。服务器无法找到请求的资源。</li>\n<li>500 Internal Server Error：服务器内部错误。服务器遇到了意外的情况，无法完成请求。 </li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>不同层级的协议</p>\n<ul>\n<li>物理层<ul>\n<li>RS-232：用于串行通信的标准接口协议</li>\n<li>USB</li>\n</ul>\n</li>\n<li>数据链路层<ul>\n<li>WIFI</li>\n<li>VLAN：虚拟局域网</li>\n<li>PPP 协议：点对点协议</li>\n<li>ARP 协议：地址解析协议，用于将 IP 地址映射到物理地址</li>\n</ul>\n</li>\n<li>网络层<ul>\n<li>IP 协议：用于在网络中传输数据包</li>\n<li>ICMP 协议：是一种面向无连接的协议，用于传输出错报告控制信息</li>\n</ul>\n</li>\n<li>传输层<ul>\n<li>TCP 协议：一种面向连接的、可靠的、基于字节流的传输层通信协议</li>\n<li>UDP 协议：是无连接的协议，通信双方在传输数据之前不需要建立连接，也不需要进行连接的释放。每个数据包都是独立的，不会建立持久性的连接。</li>\n<li>TLS 协议：在两个通信应用程序之间提供保密性和数据完整性</li>\n</ul>\n</li>\n<li>会话层<ul>\n<li>LDAP 协议：(轻型目录访问协议)、通过 IP 协议提供访问控制和维护分布式信息的目录信息</li>\n</ul>\n</li>\n<li>表示层<ul>\n<li>LPP 协议：轻量级会话协议、描述了在某些受限条件下提供基于 TCP/IP 网络的 OSI 应用程序服务器的流线支持的方法</li>\n</ul>\n</li>\n<li>应用层<ul>\n<li>HTTP 协议：超文本传输协议，规定 web 服务端和客户端的数据传输格式</li>\n<li>HTTPS 协议：超文本传输安全协议，是 HTTP 加上 TLS/SSL 协议构成的可加密传输的网络协议</li>\n<li>DNS 协议：域名解析协议、将域名解析为 IP 地址</li>\n<li>FTP 协议：文件传输协议、网络共享文件传输</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>输入 url 到响应的整个过程</p>\n<ul>\n<li>浏览器首先检查输入的 URL 的格式是否正确。一个完整的 URL 应包含协议部分（如 HTTP 或 HTTPS）、域名或 IP 地址、以及查询参数等组成部分。</li>\n<li>如果 URL 格式正确，浏览器会解析 URL 获取域名或 IP 地址。如果用户输入的是域名，浏览器会将其解析为对应的 IP 地址，这个过程通常通过 DNS 来完成。</li>\n<li>浏览器建立与服务器的网络连接。它首先通过向目标服务器的 IP 地址发送一个 TCP 连接请求来建立一个 TCP 连接。这个过程通常使用三次握手来确保连接的可靠性。</li>\n<li>一旦建立了 TCP 连接，浏览器会发送一个 HTTP 请求到服务器。</li>\n<li>服务器接收到浏览器发送的 HTTP 请求后，会根据请求的内容进行处理。</li>\n<li>服务器处理完请求后，会生成一个 HTTP 响应。</li>\n<li>服务器过建立的 TCP 连接进行传输, 将生成的 HTTP 响应发送回浏览器。</li>\n<li>浏览器接收到 HTTP 响应后，会根据响应的内容进行处理。</li>\n<li>浏览器将解析后的页面显示给用户，用户可以看到页面内容。</li>\n<li>在 HTTP/1 中，浏览器与服务器之间的默认行为是在每个请求 - 响应周期结束后关闭连接。在 HTTP/2 中，引入了多路复用的概念，允许在同一连接上同时发送多个请求和响应。这样，连接在一个页面加载完成后并不会立即关闭，而是继续保持打开状态，以供后续请求使用。如果在一段时间内没有请求或通信发生，TCP 连接就会超时并自动关闭。</li>\n</ul>\n</li>\n</ol>\n<ol start=\"6\">\n<li>http 连接和 tcp 连接的区别<ul>\n<li>http 是一种应用层协议，它在 Web 应用中使用，用于在客户端和服务器之间传输超文本数据，HTTP 连接是基于 TCP 连接的。HTTP 协议在 TCP 连接上定义了请求和响应的格式和规则，包括请求方法、请求头、响应状态码等。TCP 负责提供可靠的数据传输，而 HTTP 负责定义应用层的通信规则和数据格式。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"操作系统\"><a href=\"# 操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><ol>\n<li><p>进程和线程的区别</p>\n<ul>\n<li>根本区别：进程是操作系统进行 <strong> 资源分配 </strong> 的最小单元，线程是操作系统进行 <strong> 运算调度 </strong> 的最小单元。</li>\n<li>从属关系不同：进程中包含了线程，线程属于进程。</li>\n<li>开销不同：进程的创建、销毁和切换的开销都远大于线程。</li>\n<li>拥有资源不同：每个进程有自己的内存和资源，一个进程中的线程会共享这些内存和资源。</li>\n<li>CPU 利用率不同：进程的 CPU 利用率较低，因为上下文切换开销较大，而线程的 CPU 的利用率较高，上下文的切换速度快。</li>\n</ul>\n</li>\n<li><p>死锁产生原因及解决办法</p>\n<ul>\n<li>死锁指多个线程在执行过程中，因争夺资源造成的一种相互等待的僵局</li>\n<li>解决方案：<ul>\n<li>互斥条件：一个资源只能被一个线程占有，当这个资源被占用后其他线程就只能等待。</li>\n<li>不可剥夺条件：当一个线程不主动释放资源时，此资源一直被拥有线程占有。</li>\n<li>请求并持有条件：线程已经拥有一个资源后仍然不满足，又尝试请求新的资源。</li>\n<li>环路等待条件：产生死锁一定是发生了线程资源环路链。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线程之间通信的方式</p>\n<ul>\n<li>共享内存（Shared Memory）：多个线程可以通过访问相同的内存区域来进行通信。线程可以读取和写入共享内存中的数据来进行信息交换。由于多个线程同时访问共享内存，因此需要使用同步机制（如互斥锁）来保证数据的一致性和避免竞态条件。</li>\n<li>信号量（Semaphore）：信号量是一个计数器，用于控制多个线程对共享资源的访问。线程在访问共享资源之前需要获取信号量，如果信号量计数器大于零，则允许访问；如果计数器为零，则线程被阻塞，直到其他线程释放信号量。通过适当的计数器设置，可以控制线程的并发访问量。</li>\n<li>互斥锁（Mutex）：互斥锁用于保护共享资源，确保在同一时间只有一个线程可以访问共享资源。线程在访问共享资源之前需要获取互斥锁，如果锁已被其他线程获取，则线程被阻塞，直到锁被释放。互斥锁可以防止多个线程同时访问共享资源，从而避免数据的不一致性和竞态条件。</li>\n<li>管道（Pipe）：管道是一种单向的、有序的数据通信机制。它可以在父进程与子进程之间或者同一进程的不同线程之间进行通信。一个线程可以将数据写入管道的写端，而另一个线程可以从管道的读端读取数据。管道可以用于在线程之间传递数据或消息。</li>\n<li>消息队列（Message Queue）：消息队列是一种在多个线程之间传递消息的通信方式。线程可以将消息放入队列中，而其他线程可以从队列中获取消息。消息队列可以按照一定的优先级和顺序来处理消息，方便线程之间的协作和通信。</li>\n</ul>\n</li>\n<li><p>进程之间的调度策略</p>\n<ul>\n<li>先来先服务（FCFS）：按照任务到达的顺序，按照先后次序分配 CPU 时间片，即先到先服务。这种策略简单直观，但可能导致长作业优先，造成短作业等待时间过长。</li>\n<li>短作业优先（SJF）：根据任务的执行时间长度，优先分配执行时间短的作业。这种策略可以减少平均等待时间，但需要预先知道任务的执行时间，不适用于实时环境。</li>\n<li>优先级调度(剥夺策略)：为每个任务分配一个优先级，按照优先级高低分配 CPU 时间片。可以根据任务的重要性、紧急程度等来设置优先级。然而，这种策略可能导致优先级较低的任务长时间等待，出现饥饿问题。</li>\n<li>时间片轮转（Round Robin）：将 CPU 时间分成若干个时间片，每个任务轮流执行一个时间片。当一个时间片用完后，任务被挂起，等待下一个时间片再次执行。这种策略可以确保公平性，但可能导致上下文切换频繁。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"实习总结\"><a href=\"# 实习总结\" class=\"headerlink\" title=\"实习总结\"></a>实习总结 </h1><h2 id=\"第一段实习\"><a href=\"# 第一段实习\" class=\"headerlink\" title=\"第一段实习\"></a> 第一段实习 </h2><h3 id=\"SparkSQL 脚本编写\"><a href=\"#SparkSQL 脚本编写\" class=\"headerlink\" title=\"SparkSQL 脚本编写\"></a>SparkSQL 脚本编写</h3><p> 由于之前有很多统计的数据是运营自行用 excel 手动统计的，后续希望改成由系统来自动运算并进行统计，所以需要编写的 sql 脚本来对对海量数据进行统计和聚合，平均一个脚本大约有 300 行代码，并可将结果导出为 excel。在写完脚本之后也会通过这样运营提供的数据进行比较来找出 sql 脚本的逻辑与运营逻辑的出入，并进行修复</p>\n<h3 id=\"支付模块\"><a href=\"# 支付模块\" class=\"headerlink\" title=\"支付模块\"></a>支付模块 </h3><p> 需求背景上这样的，当时是品牌方搞了一个品牌新用户的一个活动，这个活动是所有平台共用的，也就是说如果这个用户在淘宝上已经下单购买了，那么他将不能再到我们的小程序中使用这个新用户的资格了。于是我们在开发支付功能的时候，当时大家就在下单的界面访问了第三方系统来判断该用户是否还有新资格，但是在开发过程中，我就发现了一个漏洞，因为我们还有一个二次支付接口，也就是下单但不支付，就会落入到二次支付接口去，也就是说，如果我下单但不支付，就卡在二次支付接口这里，然后去淘宝再下单支付一次，那么我们的小程序就检测不到用户的新资格已经被消耗掉了，所以我便把漏洞讲给了项目经理听，最后我们便在二次支付接口进行了二次校验，来避免这个漏洞带来的损失。</p>\n<h3 id=\"线上问题的排查\"><a href=\"# 线上问题的排查\" class=\"headerlink\" title=\"线上问题的排查\"></a>线上问题的排查</h3><ul>\n<li>git 脏代码上线 <br> 当时的情况是这样的，我们那个时候开发完功能之后，是在周五的时候做了测试，然后本来是预计下周一来上线的，然后等周一下午上线之后，没多久就有人反应说那功能用不了，爆错了，然后我就去看那个日志打印，一看说是 unkown colmun，很明显就是 mybatisplus 去做全查询然后查了数据库中没有的字段，然后我就根据日志找到那个类，发现多了一个 app_key 的字段，然后一看提交记录，发现有人在周一上午在我们分支提交了代码，然后就找到那个人问他咋回事，他说他不小心切错分支了，也上了灰度环境，然后就在我们的代码里的一个实体类中新增了一个字段，但是我们数据库中还没有执行相应的 sql，就导致了我们把他的脏代码也带到了线上的环境，最后就产生了这个线上问题。解决方案：先执行 sql 语句把线上问题解决了再说，然后在原有的业务分支的基础上，放弃别人提交的版本，在自己最新提交的版本上重新新建一个分支出来，并且将 master 分支回滚，然后重新将 master 分支和我们的新分支进行反合，最后重新提交 merge-request 来重新将代码分支合并到 master 分支上。</li>\n<li>OOM 问题</li>\n</ul>\n<h3 id=\"排行榜\"><a href=\"# 排行榜\" class=\"headerlink\" title=\"排行榜\"></a>排行榜 </h3><p> 当时的需求是需要根据订单的信息来统计分销员的业绩，而订单信息是属于海量信息，不可能直接在 mysql 中进行处理，那样的处理效率会很慢。而订单信息的源数据也是通过大数据搜集来的，所以在大数据平台的 hive 表里也存储着订单的信息，所以我就在大数据平台使用了 Spark 来进行订单表的分销业绩的统计与聚合，最后将计算之后的结果存回 mysql 的分销员业绩表，并通过 order by 对指定字段进行排序，从而实现排行榜的功能</p>\n<h2 id=\"话费充值系统的开发\"><a href=\"# 话费充值系统的开发\" class=\"headerlink\" title=\"话费充值系统的开发\"></a>话费充值系统的开发 </h2><h2 id=\"第二段实习\"><a href=\"# 第二段实习\" class=\"headerlink\" title=\"第二段实习\"></a> 第二段实习</h2><ul>\n<li><p>策略模式的应用：</p>\n<ul>\n<li>业务场景：在做客服中心的时候，有一个需求是要将别人提交上来的工单进行处理，可以选择分配、修改等策略，而不同的策略对应不同的实现，但是在后端我只统一用了一个接口，通过传不同的参数来实现。</li>\n<li>具体实现：首先，我将所有策略的实现类都作为 bean 交给了 Spring 容器来管理，在接口层我拿到不同策略传过来的不同的参数，然后通过枚举类找到对应策略的实现类的 beanName，然后调用我 Service 层的一个方法来获取不同策略对应的 bean 的引用，而这个获取主要是通过 Map 集合来获取的。key 是 beanName，Value 是 bean 的实现类的引用，而构造这个 Map 集合是利用了 Spring 的自动装配原理来自动帮我构造的，我将这个 Map 作为对应 Service 这个 bean 的构造方法的入参，在容器启动的时候就会自动调用构造方法，而此时我的入参会由 Spring 去自动帮我完成注入。我曾 debug 去看过源码的，实际上 Spring 在帮我构造这个 Map 的时候，源码的那个核心方法就是获取到根接口及其所有策略的实现类的 beanName 和引用，beanName 都放到一个 String 的数组里去，而这个数组中所有的 beanName 都将作为我所需的 Map 的 key，而引用作为 value。由此呢，就了利用 Spring 上下文，结合策略模式，实现了多个操作，同一个入口，让整体逻辑和代码结构都变得很优雅。</li>\n</ul>\n</li>\n<li><p>TTL 的应用:<br>当调用接口未得到期望值或产生异常的时候，通常会结合 traceId 来排查，可通过 traceId 到阿里云的那个日志系统去进行一个链路追踪，通常就可以找到问题的产生原因。而 traceId 这样的标识一般来说就不允许线程上下文丢失的情况，所以就可以用 TTL 来实现</p>\n</li>\n<li><p>为什么折线图选用 ES 而不用 MySQL</p>\n<ol>\n<li>需要频繁地进行时间范围内的聚合、分析，ES 可能更适合。ES 针对时间序列数据的索引和查询做了优化，使得实时聚合和检索非常高效</li>\n<li>ES 在实时搜索和分析方面表现得非常出色。它可以快速索引新数据，并在实时的情况下提供查询结果，非常适合需要及时反馈的场景，MySQL 也可以实现实时查询，但在复杂查询的情况下，性能可能受到一定限制。</li>\n<li>ES 的扩展性更高，实际上我们业务的计算，可能在筛选条件上经常会变换，如果用 mysql 那么我们就需要建立组合索引，一旦新增了字段，就要重构索引，这个是比较低效的。而 ES 由于底层的倒排索引，所以在此业务场景下，就更具有优势了</li>\n<li>Elasticsearch 不限于固定的数据模式，适用于半结构化和非结构化数据，它允许动态添加字段，非常灵活，而 MySQL 要求定义固定的表结构，适合于结构化数据</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"项目积累\"><a href=\"# 项目积累\" class=\"headerlink\" title=\"项目积累\"></a>项目积累 </h1><h2 id=\"校疫通\"><a href=\"# 校疫通\" class=\"headerlink\" title=\"校疫通\"></a> 校疫通 </h2><h3 id=\"项目难点及解决方案\"><a href=\"# 项目难点及解决方案\" class=\"headerlink\" title=\"项目难点及解决方案\"></a> 项目难点及解决方案</h3><ul>\n<li><p>二级缓存的设置, 将它放在哪比较合适</p>\n<ul>\n<li>要将很多统计维度的数据放到缓存中去，避免每次访问首页都去查一遍 DB</li>\n<li>使用 Caffine + Redis 构建二级缓存，使用 SpringAOP 将其独立出来</li>\n<li>因为是按天统计的，所以对于一致性的要求只需要按天来同步信息就好</li>\n</ul>\n</li>\n<li><p>如何优雅地使用 SpringSecurity 来实现用户的鉴权和认证</p>\n<ul>\n<li>采用 RBAC0 权限模型、将管理员用户、角色、权限、受保护的 URL 都放入到 MySQL 中并建立相应联系</li>\n<li>合理使用 SpringSecurity 的过滤链，使用数据源、管理器等资源实现系统的权限及认证管理</li>\n</ul>\n</li>\n<li><p>如何让前端更方便地测试</p>\n<ul>\n<li>Swagger 写接口文档</li>\n<li>部署到云服务器</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"项目板块\"><a href=\"# 项目板块\" class=\"headerlink\" title=\"项目板块\"></a>项目板块</h3><ul>\n<li>登录注册板块： 使用 SpringSecurity，通过实现 UserDeatilSertvice 组件来自定义自己的登录逻辑</li>\n<li>鉴权板块: 利用 SpringSecurity 的过滤链，合理使用其中的组件，包括动态权限管理器、包括数据元数据源，包括权限拦截器等</li>\n<li>CRUD 板块：其中包括车辆出入管理、核酸检测管理、疫苗管理等，主要就是直接使用的 MybatisPlus 封装好的方法，构造不同的 wrapper 来实现</li>\n<li>项目优化板块：<ul>\n<li>二级缓存模块：采用的双写模式，updateDB、updateRedis、updateCaffine，如果缓存更新失败，也有补偿机制：重试（在需要进行重试的方法上添加 @Retryable 注解，可指定了最大重试次数，和重试的间隔时间）</li>\n<li>全局异常处理模块</li>\n<li>接口测试模块</li>\n<li>日志模块<ul>\n<li>每个人对日志的操作都会记录在我们的 mysql 里，有一张日志表</li>\n<li>日志表字段：主键、操作人、操作模块、操作时间、sessionId、客户端 Id、服务端 Id、服务器端口、请求 URL 等</li>\n<li>日志归档：使用定时任务，每个礼拜都将日志进行归档，以文件的形式保存在计算机中，然后清空日志表</li>\n<li>分批处理：每次生成的文件最多有 5000 条记录，如果数据量过大则分多次读取，然后用 BufferWriter 以文件的形式保存日志，缓冲区默认是 8kb，足够写入 5000 条记录了，因为每条记录差不多 100 个字符</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"话费充值系统\"><a href=\"# 话费充值系统\" class=\"headerlink\" title=\"话费充值系统\"></a>话费充值系统 </h2><h3 id=\"架构图\"><a href=\"# 架构图\" class=\"headerlink\" title=\"架构图\"></a> 架构图</h3><img src = \"http://xtzl.wentexl.cn/%E8%AF%9D%E8%B4%B9%E5%85%85%E5%80%BC%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.png\"/>\n\n<h3 id=\"项目难点\"><a href=\"# 项目难点\" class=\"headerlink\" title=\"项目难点\"></a>项目难点 </h3><h4 id=\"项目简述\"><a href=\"# 项目简述\" class=\"headerlink\" title=\"项目简述\"></a> 项目简述</h4><ul>\n<li>流程简述：整个系统是由两大系统组成，一个系统是推单系统，主要负责接收订单、一个系统是配单系统，主要负责处理订单，最开始的流程是这样的：pdd 商户将订单推送到推单系统中，推单系统落库之后将订单推送给配单服务，而配单服务会去调用运营商代理提供的第三方接口来获取一个支付凭证，并将这个凭证传给下游，下游拿到这个凭证之后将回调配单系统，然后配单系统重新回调推单系统， 推单系统又会回调 pdd 商户，但是整个流程都基于同步实现的。</li>\n</ul>\n<h4 id=\"项目并发问题\"><a href=\"# 项目并发问题\" class=\"headerlink\" title=\"项目并发问题\"></a>项目并发问题</h4><ul>\n<li>问题描述：最初整个系统都是同步调用的，如果说由于网络抖动等原因，就可能导致大量线程被阻塞，从而不断滚雪球，导致服务崩溃。而且如果一旦请求出了问题，难以定位到问题所在的地方。</li>\n<li>问题解决方案：拆异步，搞批量</li>\n</ul>\n<p><strong>1. OOM 问题</strong></p>\n<ul>\n<li>问题描述：在配单系统与运营商代理这块，前期是基于同步调用的，如果发生的网络抖动，哪怕是一两分钟，就可能造成成百上千的线程阻塞，jvm 不断的新建线程，就像滚雪球一样，从而导致内存溢出的问题</li>\n<li>解决方案：拆一个推送服务出来，异步调用第三方系统的接口<ul>\n<li>具体实施：配单系统将订单信息推送到 Redis 中去，然后推送服务会开启定时任务，我们设置的是 1s，也就是说每秒钟都会去拉取我们 redis 中的订单信息，并批量地向第三方系统发起请求调用，获取支付凭证，并将获取到的支付凭证都统一存回 redis 中，以便于下游调用</li>\n</ul>\n</li>\n</ul>\n<p><strong>2. 解决死锁问题</strong></p>\n<ul>\n<li>问题描述：当配单系统回调推单系统的时候，推单系统会做两件事，第一件事是通知上游，第二件事是修改配单系统的回调状态，那就有可能存在，在通知上游成功之后，我们去 redis 里拉回订单的时候，不是我们推过去 的顺序，就可能导致死锁问题的发生</li>\n<li>解决方案：将 redis 换成消息中间件，保证消息一定是按顺序消费的</li>\n</ul>\n<p><strong>3. token 重复刷新问题</strong></p>\n<ul>\n<li>问题描述: 我们去调用运营商接口的时候是有一个密钥 token 的，这个 token 是有过期时间的，过期时间是半个小时，过了这个过期时间之后就需要刷新一次，但是如果在过期之后同时有多个请求到达，则会造成不必要的刷新次数</li>\n<li>解决方案：使用 redis 锁控制只有一个请求去刷新，加锁也需要设置其他线程最多等待的时间，并且在控制的时候需要加个时间的判断，又担心如果只有一个线程去刷新，可能意外没有刷新成功，所以我们所有的请求都会自旋三次来获取这个锁</li>\n</ul>\n<p><strong>4. Redis 的存储结构</strong></p>\n<ul>\n<li>问题描述：从推单系统到配单系统的 redis 是 set 结构，放置推重复的订单。从配单系统到下游的 redis 是 list 结构，主要是因为支付凭证是有时间限制的，3min 之后将会过期，如果支付凭证都存在 list 中，供下游一条一条地拉取处理，如果说下游处理能力不够强，或者出现了性能方面的问题，则为了尽可能的保证 list 中的支付凭证能被及时处理，我们将处理最晚入 list 的，也就是有效时间最长的那个</li>\n</ul>\n","url":"/posts/41865/","min2read":106,"word4post":"30.8k","prev_post":{"title":"","url":"/posts/0/"},"next_post":{"title":"BigData-HBase","url":"/posts/10071/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"Java 八股文\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">Java 八股文</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"Java 及 Web 基础\" href = \"#\"><span class=\"toc-number\">1.1.</span> <span class=\"toc-text\">Java 及 Web 基础</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"Spring 全家桶框架\" href = \"#\"><span class=\"toc-number\">1.2.</span> <span class=\"toc-text\">Spring 全家桶框架</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"JUC\" href = \"#\"><span class=\"toc-number\">1.3.</span> <span class=\"toc-text\">JUC</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"JVM\" href = \"#\"><span class=\"toc-number\">1.4.</span> <span class=\"toc-text\">JVM</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"JMM\" href = \"#\"><span class=\"toc-number\">1.5.</span> <span class=\"toc-text\">JMM</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"数据库\" href = \"#\"><span class=\"toc-number\">1.6.</span> <span class=\"toc-text\">数据库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"MySQL\" href = \"#\"><span class=\"toc-number\">1.6.1.</span> <span class=\"toc-text\">MySQL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"Redis\" href = \"#\"><span class=\"toc-number\">1.6.2.</span> <span class=\"toc-text\">Redis</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"MQ\" href = \"#\"><span class=\"toc-number\">1.7.</span> <span class=\"toc-text\">MQ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"RabbitMQ\" href = \"#\"><span class=\"toc-number\">1.7.1.</span> <span class=\"toc-text\">RabbitMQ</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"Kafka\" href = \"#\"><span class=\"toc-number\">1.7.2.</span> <span class=\"toc-text\">Kafka</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"基础学科\" href = \"#\"><span class=\"toc-number\">1.8.</span> <span class=\"toc-text\">基础学科 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"数据结构\" href = \"#\"><span class=\"toc-number\">1.8.1.</span> <span class=\"toc-text\"> 数据结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"计算机网络\" href = \"#\"><span class=\"toc-number\">1.8.2.</span> <span class=\"toc-text\">计算机网络</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"操作系统\" href = \"#\"><span class=\"toc-number\">1.8.3.</span> <span class=\"toc-text\">操作系统</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"实习总结\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">实习总结 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"第一段实习\" href = \"#\"><span class=\"toc-number\">2.1.</span> <span class=\"toc-text\"> 第一段实习 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"SparkSQL 脚本编写\" href = \"#\"><span class=\"toc-number\">2.1.1.</span> <span class=\"toc-text\">SparkSQL 脚本编写</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"支付模块\" href = \"#\"><span class=\"toc-number\">2.1.2.</span> <span class=\"toc-text\">支付模块 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"线上问题的排查\" href = \"#\"><span class=\"toc-number\">2.1.3.</span> <span class=\"toc-text\">线上问题的排查</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"排行榜\" href = \"#\"><span class=\"toc-number\">2.1.4.</span> <span class=\"toc-text\">排行榜 </span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"话费充值系统的开发\" href = \"#\"><span class=\"toc-number\">2.2.</span> <span class=\"toc-text\">话费充值系统的开发 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"第二段实习\" href = \"#\"><span class=\"toc-number\">2.3.</span> <span class=\"toc-text\"> 第二段实习</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"项目积累\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\">项目积累 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"校疫通\" href = \"#\"><span class=\"toc-number\">3.1.</span> <span class=\"toc-text\"> 校疫通 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"项目难点及解决方案\" href = \"#\"><span class=\"toc-number\">3.1.1.</span> <span class=\"toc-text\"> 项目难点及解决方案</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"项目板块\" href = \"#\"><span class=\"toc-number\">3.1.2.</span> <span class=\"toc-text\">项目板块</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"话费充值系统\" href = \"#\"><span class=\"toc-number\">3.2.</span> <span class=\"toc-text\">话费充值系统 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"架构图\" href = \"#\"><span class=\"toc-number\">3.2.1.</span> <span class=\"toc-text\"> 架构图</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"项目难点\" href = \"#\"><span class=\"toc-number\">3.2.2.</span> <span class=\"toc-text\">项目难点 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"项目简述\" href = \"#\"><span class=\"toc-number\">3.2.2.1.</span> <span class=\"toc-text\"> 项目简述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"项目并发问题\" href = \"#\"><span class=\"toc-number\">3.2.2.2.</span> <span class=\"toc-text\">项目并发问题</span></a></li></ol></li></ol></li></ol></li></ol>","categories":[{"name":"Interview","path":"api/categories/Interview.json","url":"/categories/Interview/"}],"tags":[]}