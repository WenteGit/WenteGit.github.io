{"title":"Interview-MeiTuan","slug":"Interview-MeiTuan","date":"2023-03-16","updated":"2023-03-26","comments":true,"path":"api/posts/41865.json","excerpt":"<blockquote><p> 关于美团的面试，及其面经积累 </p></blockquote>","cover":null,"covers":null,"content":"<blockquote>\n<p>关于美团的面试，及其面经积累</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"Java 八股文\"><a href=\"#Java 八股文\" class=\"headerlink\" title=\"Java 八股文\"></a>Java 八股文</h1><h2 id=\"Java 及 Web 基础\"><a href=\"#Java 及 Web 基础\" class=\"headerlink\" title=\"Java 及 Web 基础\"></a>Java 及 Web 基础</h2><ol>\n<li><p>元空间: Java 8 中引入了元空间的概念，将类元数据存储在本地内存中，而不再是永久代。这种方式使得类元数据的管理更加灵活和高效，可以避免永久代出现的问题，如内存溢出、GC 时间过长等。</p>\n</li>\n<li><p>Get、Post、Put 的区别</p>\n<ul>\n<li>数据位置：GET 方法将请求参数附加在 URL 的查询字符串中，而 POST 方法将请求参数放在请求的消息体中。由于 URL 长度的限制，GET 方法的参数传输通常会受到一定的限制。</li>\n<li>安全性：由于 GET 方法将请求参数暴露在 URL 中，因此请求的安全性较低，容易被攻击者截获和窃取。而 POST 方法将请求参数放在消息体中，相对来说更为安全。</li>\n<li>可缓存性：GET 方法通常可以被缓存，因为它的请求参数以及 URL 是不变的。而 POST 方法的请求参数会影响服务器的状态，不能被缓存。</li>\n<li>幂等性：GET 方法是幂等的，即多次请求同一个 URL 的结果相同，不会对服务器状态产生影响。而 POST 方法通常不是幂等的，多次请求同一个 URL 可能会导致服务器状态的改变。</li>\n<li>用途：GET 方法主要用于获取资源，POST 方法主要用于提交数据。例如，用 GET 方法可以请求一个 HTML 页面或图像文件，用 POST 方法可以提交一个表单。</li>\n<li>PUT 请求：<ul>\n<li>如果服务器上已经存在了一个资源，并且客户端发送了一个 PUT 请求，那么服务器将用客户端上传的新资源替换原有的资源。如果服务器上不存在该资源，则会创建一个新的资源。</li>\n<li>PUT 请求通常需要在请求头中指定上传的资源的 URI 和一些元数据，以便服务器正确处理请求。</li>\n<li>与 POST 请求不同，PUT 请求的请求体中通常包含完整的资源内容，而不是仅包含部分数据或请求参数。</li>\n<li>PUT 请求可能会导致服务器上的数据被覆盖或删除，因此在使用 PUT 请求时需要谨慎处理，避免意外修改或删除重要数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Cookie 和 Session 的区别</p>\n<ul>\n<li>存储位置：Cookie 是保存在客户端浏览器中的，而 Session 是保存在服务器端的。</li>\n<li>安全性：Cookie 中的数据可以被客户端浏览器拦截并篡改，因此不适合保存敏感数据，而 Session 保存在服务器端，可以保证数据的安全性。</li>\n<li>存储容量：Cookie 存储容量比较小，通常只能存储几 KB 的数据，而 Session 存储容量较大，可以存储几 MB 的数据。</li>\n<li>生命周期：Cookie 有一个过期时间，如果没有设置过期时间，则默认为浏览器关闭时失效，而 Session 的生命周期由服务器管理，默认情况下，Session 在 30 分钟内无任何操作时会失效。</li>\n</ul>\n</li>\n<li><p>动态代理</p>\n<ul>\n<li>jdk 动态代理 : 适用于代理那些实现了接口的类， 使用 Java 自带的反射机制</li>\n<li>cglib 动态代理: 适用于代理未实现接口的类, 动态代理的效率较低，但具有广泛的适用范围，使用的第三方库 ASM 的字节码生成技术</li>\n<li>客户端访问的是代理对象，代理对象负责将调用请求委托给目标对象并应用横切关注点</li>\n</ul>\n</li>\n<li><p>面向对象和面向过程</p>\n<ul>\n<li>面向对象(Java): 将现实世界中的事物抽象成一个个对象，对象包括属性和方法。对象的属性用来描述对象的状态，方法用来描述对象的行为。在面向对象编程中，程序员将不同的对象进行组合，形成一个完整的系统。</li>\n<li>面向过程(C 语言): 是一种基于函数的编程方法，将一个大问题分解为一系列小问题，每个小问题都可以使用一个函数来解决。在面向过程编程中，程序员关注的是程序中的函数，函数之间通过参数传递数据，函数中的变量也只在函数内部有效。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Spring 全家桶框架\"><a href=\"#Spring 全家桶框架\" class=\"headerlink\" title=\"Spring 全家桶框架\"></a>Spring 全家桶框架</h2><ol>\n<li><p>SpringIOC 和 SpringAOP 的原理</p>\n<ul>\n<li>IOC<ul>\n<li>DI 依赖注入: 通过构造函数、属性或方法参数等方式，将一个对象所依赖的其他对象传递给它，而不是由这个对象自己去创建或查找依赖的对象。这样做的好处是，我们可以更灵活地管理和替换这些依赖</li>\n<li>IC 控制反转: 控制反转的核心思想是将对象的创建和管理交给容器或框架，而不是由程序员自己手动创建和管理对象。这样做的好处是可以将对象的生命周期和作用域管理交给框架或容器，从而避免了一些常见的问题，比如对象的重复创建、对象的生命周期管理等等。</li>\n</ul>\n</li>\n<li>AOP<ul>\n<li>面向切面的技术：所谓“切面”，简单说就是那些与业务无关，却被业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Spring 的三级缓存</p>\n<ul>\n<li>一级缓存：存放已经创建完成的 Bean</li>\n<li>二级缓存：存放早起创建但是未填充属性的 Bean</li>\n<li>三级缓存：存放 ObjectFactory 这样的 Bean 的工厂对象，负责动态的创建和管理 Bean</li>\n<li>主要通过三级缓存可解决循环依赖、Bean 的重复创建等问题</li>\n</ul>\n</li>\n<li><p>Spring 占位符</p>\n<ul>\n<li>‘#’ : #占位符会对输入的参数值进行类型转换，防止 SQL 注入攻击。</li>\n<li>‘$’ : $ 占位符在 SQL 语句中直接替换成输入的参数值，它不会对输入的参数值进行类型转换，也不会防止 SQL 注入攻击</li>\n</ul>\n</li>\n<li><p>RPC 框架</p>\n<ul>\n<li>SpringCloud<ul>\n<li>注册中心: Ereuka、Zookeeper、Nacos、Consul</li>\n<li>服务调用: restTemplate、OpenFeign</li>\n<li>服务降级：Hystrix、Sentinel</li>\n<li>服务配置：Nacos、Config</li>\n<li>服务网关：GateWay</li>\n<li>服务总线：Bus、Nacos</li>\n</ul>\n</li>\n<li>Hadoop<ul>\n<li>HDFS</li>\n<li>MapReduce</li>\n</ul>\n</li>\n<li>Spark<ul>\n<li>执行流程：<ol>\n<li>根据 RDD 依赖关系 -&gt; DAG 流程图 —(DAGScheduler)–&gt; Stage —-(TaskScheduler)–&gt; tasks</li>\n<li>Executor  —(申请任务)–&gt; SparkContext、 任务调度器 —-(分发任务)—&gt; Executor</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>设计模式</p>\n<ul>\n<li>工厂模式（Factory Pattern）：Spring 中使用工厂模式来实现对象的创建和管理，例如 BeanFactory 和 ApplicationContext 就是工厂模式的典型实现。</li>\n<li>代理模式（Proxy Pattern）：Spring 中使用代理模式来实现 AOP，通过动态代理技术在不改变原有类结构的前提下，对类的方法进行增强或切面操作。</li>\n<li>观察者模式（Observer Pattern）：Spring 中使用观察者模式来实现事件监听器的功能，例如 ApplicationListener 接口就是观察者模式的实现。</li>\n<li>模板模式（Template Pattern）：Spring 中使用模板模式来实现 JdbcTemplate 等模板类，将通用的数据访问逻辑封装在模板类中，提高了代码复用性和可维护性。</li>\n<li>单例模式（Singleton Pattern）：Spring 中大量使用了单例模式，确保在整个应用中只有一个实例对象被创建和共享，提高了应用的性能和效率。</li>\n<li>适配器模式（Adapter Pattern）：Spring 中使用适配器模式来适配各种数据源，例如 JDBC 适配器可以将不同厂商的 JDBC 驱动进行统一适配。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"JUC\"><a href=\"#JUC\" class=\"headerlink\" title=\"JUC\"></a>JUC</h2><ol>\n<li><p>Synchronized </p>\n<ul>\n<li>原理:synchronized 是 Java 中用于实现同步的关键字，它可以应用于方法或代码块中。其主要原理是通过对一个对象或类进行加锁来保证多个线程之间的互斥访问。当一个线程获取了锁，其他线程就必须等待锁被释放后才能进入被锁定的代码块。 </li>\n<li>锁升级<ul>\n<li>偏向锁：线程 A 第一次竞争到资源，加的是偏向锁,MarkWord 存的是偏向线程 ID，之后只需检查是否是偏向线程访问即可，效率最高。</li>\n<li>轻量级锁：线程 B 来和线程 A 竞争资源且竞争成功，则偏向锁切换偏向线程，竞争失败，则偏向锁升级为轻量级锁, 轻量级锁本质就是自旋锁 CAS</li>\n<li>重量级锁：大量线程参与竞争或 CAS 多次自旋未成功，升级为重量级锁，效率最低</li>\n</ul>\n</li>\n<li>区别于 ReentrantLock:<ul>\n<li>ReentrantLock 显示地获得、释放锁，synchronized 隐式获得、释放锁</li>\n<li>ReentrantLock 可响应中断，可轮回，synchronized 是不可以响应中断的</li>\n<li>ReentrantLock 可以实现公平锁</li>\n<li>ReentrantLock 通过 Condition 可以绑定多个条件</li>\n<li>Lock 是一个接口，而 synchronized 是 java 中的关键字，synchronized 是内置的语言实现</li>\n<li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。</li>\n<li>底层实现不一样，synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线程池</p>\n<ul>\n<li>七大参数<ul>\n<li>核心线程数 corePoolSize </li>\n<li>最大线程数 maximumPoolSize   </li>\n<li>空闲线程的存活时间 keepAliveTime </li>\n<li>存活时间单位 TimeUnit</li>\n<li>阻塞队列 workQueue </li>\n<li>线程工厂 threadFactory </li>\n<li>拒绝策略 handler<ul>\n<li>抛出异常</li>\n<li>任务调回</li>\n<li>丢弃任务</li>\n<li>与最老任务竞争</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>参数设置<ul>\n<li>I/O 通常是对数据库的操作, 线程数如果不多的话，在处理 IO 的时候不能用 CPU，导致 CPU 的使用率较低。</li>\n<li>CPU 密集型：<ul>\n<li>核心线程 = CPU 核心</li>\n<li>最大线程 = CPU 核心 + 1</li>\n</ul>\n</li>\n<li>IO 密集型<ul>\n<li>核心线程 = 2*CPU 核心</li>\n<li>最大线程 = 2*CPU 核心 + 1</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>运行流程<ul>\n<li>任务提交给线程池，先判断核心线程数是否已满，如果满了再判断阻塞队列是否已满，如果没满则进入阻塞队列，如果阻塞队列满了则执行拒绝策略 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>volatile</p>\n<ul>\n<li>概念：volatile 关键字用于标记变量，指示编译器和运行时系统每次访问该变量时都必须从内存中读取值，而不是使用缓存的值。在多线程编程中</li>\n<li>作用：使用 volatile 可以保证可见性和禁止指令重排，从而保证线程安全。</li>\n<li>补充解释：具体来说，当一个线程修改 volatile 变量的值时，其他线程将立即看到该变量的新值，因为该值是从内存中读取的。此外，由于 volatile 变量不能被缓存，因此在对该变量进行读取和写入操作时，不会发生指令重排，从而避免了线程安全问题。需要注意的是，volatile 仅保证单个操作的原子性，而不是多个操作的原子性。如果需要保证多个操作的原子性，应该使用其他机制，如锁、原子操作等。</li>\n</ul>\n</li>\n<li><p>线程的创建方式</p>\n<ul>\n<li>继承 Thread 类并重写 run()方法</li>\n<li>实现 Runnable 接口或者 Callable 接口</li>\n<li>使用线程池创建接口</li>\n</ul>\n</li>\n<li><p>CAS 可能出现的问题</p>\n<ul>\n<li>ABA 问题：CAS 操作在进行比较时，只会比较原值和期望值是否相等，但是在并发环境下，可能会存在 A-&gt;B-&gt;A 的情况，这时候 CAS 就无法检测出这种情况，导致并发安全问题。</li>\n<li>自旋开销：在使用 CAS 进行无锁编程时，由于 CAS 是一个自旋操作，需要不断地进行尝试和比较，从而可能会带来一定的 CPU 开销和性能损失。</li>\n<li>公平性：CAS 操作无法像锁机制一样保证公平性，可能会导致一些线程一直无法获取资源。</li>\n</ul>\n</li>\n<li><p>线程的同步方式</p>\n<ul>\n<li>synchronized: 采用互斥锁的方式来实现同步，当一个线程进入同步方法时，它会自动获取该方法所属对象的锁，其他线程需要等待该线程释放锁后才能进入该方法。</li>\n<li>ReentrantLock: 是一个可重入的互斥锁，与 synchronized 相比，ReentrantLock 提供了更灵活的锁定机制和更多的功能，如可实现公平锁、可用 condition 绑定很多条件等。</li>\n<li>Semaphore: 是一种计数信号量，用于控制对共享资源的访问。类似线程池的思想</li>\n<li>CountDownLatch: 多个线程并行执行完之后统计执行主线程</li>\n<li>CyclicBarrier: 多线线程并行执行完之后单开一个线程去执行</li>\n</ul>\n</li>\n<li><p>零拷贝</p>\n<ul>\n<li>概念: 是指在数据传输过程中，数据在不经过中间缓存（如用户态缓存）的情况下，直接从发送端复制到接收端，避免了数据在内存之间的多次复制，从而提高了数据传输的效率。</li>\n</ul>\n</li>\n<li><p>ThreadLocal</p>\n<ul>\n<li>概念：某个线程的私有变量集合</li>\n</ul>\n</li>\n<li><p>NIO</p>\n<ul>\n<li>NIO: 是 Java 的一种 I/O 处理方式，它支持同步非阻塞操作。</li>\n<li>同步：在同步 I/O 中，一个线程会等待另一个线程完成某个操作，直到得到结果后再继续执行。</li>\n<li>非阻塞：调用线程不会被阻塞，它会立即返回一个结果。如果结果是立即可用的，则可以继续进行操作；如果结果不可用，则线程可以立即返回并执行其他操作。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><ol>\n<li><p>垃圾回收算法</p>\n<ul>\n<li>标记清除算法: 这是一种最基本的垃圾回收算法。它的核心思想是先标记所有可达对象，然后清除所有未被标记的对象。标记和清除分别需要扫描整个堆，效率较低，同时可能会产生内存碎片。</li>\n<li>标记整理算法: 这种算法在标记阶段与标记 - 清除算法类似，但在清除阶段不是简单地删除未被标记的对象，而是将所有存活对象都向一端移动，然后将另一端的空间全部释放，从而避免了内存碎片的问题。</li>\n<li>复制算法: 这种算法将堆分为两个区域，每次只使用其中的一部分。当当前区域用完后，将存活对象复制到另一个区域中，然后将当前区域中的所有对象清除。复制算法的特点是效率高，但需要两倍的空间。</li>\n<li>分代算法: 这种算法认为对象的生命周期具有不同的阶段，将堆分为多个代，一般将新生代和老年代分开处理。新生代中的对象生命周期较短，采用复制算法；老年代中的对象生命周期较长，采用标记 - 整理算法。分代算法充分利用了对象的生命周期分布规律，提高了垃圾回收效率。</li>\n</ul>\n</li>\n<li><p>垃圾回收器</p>\n<ul>\n<li>CMS 收集器：是一种基于标记 - 清除算法的垃圾回收器，该收集器采用并发收集算法，具有低延迟、高并发等特点。</li>\n<li>G1 收集器: 是一种基于标记 - 整理算法的垃圾回收器，将堆空间分成多个区域，每个区域独立进行垃圾回收, 采用分代收集算法，具有高效、低延迟、可预测等特点。</li>\n<li>可作为 GCROOT 对象<ul>\n<li>长期存活的对象：比如线程池、I/O 等系统资源对象，它们通常需要在整个应用生命周期中持续存在。</li>\n<li>静态变量和常量：静态变量和常量是在类加载时被初始化的，它们的生命周期通常很长。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>新生代晋升到老年代的策略</p>\n<ul>\n<li>对象年龄阈值策略:JVM 中每个对象都有一个年龄计数器，当一个对象在新生代中经历了一定数量的垃圾收集后仍然存活，它的年龄计数器就会增加 1。当一个对象的年龄超过一定阈值时，它就会被晋升到老年代中。可以通过调整年龄阈值来控制对象晋升的速度。</li>\n<li>空间不足：如果新生代的可用空间不足以存放新的对象，JVM 会先尝试触发一次垃圾回收，如果回收后仍然无法获得足够的空间，JVM 就会尝试将部分存活的对象直接晋升到老年代中，以腾出新生代的空间。</li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>内存模型</p>\n<ul>\n<li><p>堆 (线程共享): 存储对象实例、为对象分配内存空间、GC 主要作用区域</p>\n</li>\n<li><p>方法区(线程共享): 存储类的元数据信息，如类名、方法名、字段名等。方法区还用于存储运行时常量池、静态变量、即时编译器编译后的代码等信息。</p>\n</li>\n<li><p>Java 虚拟机栈: 用于存放 Java 方法执行时的栈帧。每个栈帧包含局部变量表、动态链接、返回地址等信息。当线程调用 Java 方法时，JVM 会在 Java 虚拟机栈中为该方法分配一个栈帧，在方法返回时，该栈帧会被弹出并销毁。</p>\n</li>\n<li><p>本地方法栈: 本地方法栈和 Java 虚拟机栈类似，用于存储本地方法 (其他语言编写的) 的栈帧。</p>\n</li>\n<li><p>程序计数器: 用于指示 JVM 正在执行哪个线程的字节码指令</p>\n</li>\n<li><p>堆的分区</p>\n<ul>\n<li>新生代(1/3) : Eden(8/10) 幸存区 1(1/10) 幸存区 2(1/10)  [通常采用复制算法]</li>\n<li>老年代(2/3) : 存放存活时间较长的对象，这些对象可能是长时间存活的业务数据、缓存对象、连接池等 [通常采用标记整理算法]</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Java 的常量池、字符串池、对象池</p>\n<ul>\n<li>常量池：Java 中的常量池是一种特殊的存储区域，用于存储编译期间确定的常量。常量池分为两种类型，一种是类常量池，用于存储类中的常量，另一种是运行时常量池，用于存储每个线程的常量。常量池中存储的常量包括基本类型、字符串、类、方法和字段等。</li>\n<li>字符串池：Java 中的字符串池是用于存储字符串的缓存区域，它可以避免重复创建相同字符串对象。字符串池可以通过 String 类的 intern()方法来访问，当调用 intern()方法时，如果字符串池中已经存在相同的字符串，则返回已存在的字符串对象，否则将该字符串对象添加到字符串池中，并返回该字符串对象的引用。</li>\n<li>对象池：Java 中的对象池是一种重复使用对象的机制，它可以减少对象创建和销毁的开销，提高程序的性能。对象池通常用于创建、缓存和重复使用频繁创建和销毁的对象，如线程池、连接池和对象缓存池等。</li>\n<li>总结： 总的来说，常量池、字符串池和对象池都是 Java 虚拟机中的重要概念，它们都是为了提高 Java 程序的性能和节省内存而设计的。常量池用于存储常量，字符串池用于缓存字符串对象，对象池用于重复使用对象，以减少创建和销毁对象的开销。</li>\n</ul>\n</li>\n<li><p>如何减少 Full GC</p>\n<ul>\n<li>尽量少创建一些临时对象</li>\n<li>增加堆的大小</li>\n<li>使用对象池, 提高对象的利用率</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"数据库\"><a href=\"# 数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><ol>\n<li><p>四大特性(ACID)</p>\n<ul>\n<li>原子性 ： 每个操作不可再分</li>\n<li>一致性 ： 一个事务可以让数据从一种一致状态切换到另一种一致性状态</li>\n<li>隔离性 ： 事务并行执行互不影响，最后结果和串行执行的结果相同</li>\n<li>持久性 : 一个事务一旦被提交，在数据库中的改变就是永久的，提交后就不能再回滚</li>\n</ul>\n</li>\n<li><p>三大问题</p>\n<ul>\n<li>脏读：读到了未提交的数据</li>\n<li>不可重复读：同一个事务两次读到的数据值不同</li>\n<li>幻读：同一个事务两次读到的数据记录数量不同</li>\n</ul>\n</li>\n<li><p>隔离级别</p>\n<ul>\n<li>READ UNCOMMITTED: 读未提交</li>\n<li>READ COMMITTED: 读已提交</li>\n<li>REPEATABLE READ: 可重复读</li>\n<li>SERIALIZABLE: 可串行化</li>\n</ul>\n</li>\n<li><p>SQL 执行顺序</p>\n<ul>\n<li>from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt; order by -&gt; limit</li>\n</ul>\n</li>\n<li><p>事务的传播行为</p>\n</li>\n<li><p>MVCC 原理</p>\n<ul>\n<li>作用:<ul>\n<li>解决脏读、不可重复读的事务读写问题</li>\n<li>在保证隔离性的基础上，提升了读取效率和并发性</li>\n</ul>\n</li>\n<li>描述：在执行 Update 和 Delete 操作的时候，会将每次操作记录记录在 UndoLog 中, 每条记录都有唯一的事务 ID, 而 ReadView 记录了数据版本链的一些统计值，包括活跃事务集，当前事务 ID 等，然后通过四步判断法进行判断，遍历整个版本链，最终得到一个符合所有要求的数据版本。</li>\n<li>四步判断法：第一步主要判断是否是同一个读取的当前事务修改的数据，第二三步是判断是否是读到的未来的数据，第四步是判断是否是读的已提交的数据</li>\n<li>作用解释：因为保证了读到的都是已提交的数据，所以避免了脏读，因为同一个事务使用的都是同一个 Readview，所以保证同一个事务匹配到的是同一个版本的数据，所以避免了不可重复读的问题。</li>\n</ul>\n</li>\n<li><p>日志 Log</p>\n<ul>\n<li>bin log（二进制日志）：记录所有对 MySQL 数据库的更改操作，例如 INSERT、UPDATE、DELETE 等，以二进制格式存储。binlog 文件可以用于数据备份和恢复，数据复制和数据同步。</li>\n<li>undo log（回滚日志）：在事务中，如果执行了 UPDATE 或 DELETE 操作，MySQL 会先将修改前的数据记录到 undo log 中，然后再对数据进行修改。如果事务回滚，则 MySQL 可以使用 undo log 来撤销已经进行的修改。</li>\n<li>redo log（重做日志）：在事务中，MySQL 会先将对数据的修改记录到 redo log 中，然后再进行实际的修改。如果 MySQL 在执行修改操作后崩溃，MySQL 可以使用 redo log 来恢复数据。</li>\n</ul>\n</li>\n<li><p>MySQL 慢查询</p>\n<ul>\n<li>概念：慢查询是指执行时间较长、响应时间较慢的 SQL 查询语句。通常来说，如果一条 SQL 查询语句的执行时间超过了一定的阈值（例如几秒钟），就可以将其视为慢查询。</li>\n<li>定位：可以使用 MySQL 的慢查询日志文件</li>\n<li>影响：它们可能会导致服务器资源的过度占用，影响系统的响应速度和稳定性。</li>\n<li>解决方案<ul>\n<li>使用索引：确保表的索引能够覆盖查询的列，这将使 MySQL 能够快速找到需要的数据。</li>\n<li>优化查询语句：使用合适的查询语句可以提高性能。使用 JOIN 时，应该尽可能使用 INNER JOIN 而不是 LEFT JOIN 或 RIGHT JOIN，因为后者可能会导致较慢的查询速度。</li>\n<li>优化表结构：可以改善查询性能。例如，避免使用过多的 JOIN，使用正确的数据类型，避免使用过多的 NULL 值等等。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>聚簇索引和非聚簇索引</p>\n<ul>\n<li>区别：<ul>\n<li>物理存储方式不同: 前者的数据存在同一块物理存储区域，后者是建立索引值与行记录映射关系，有点像顺序存储和链式存储</li>\n<li>适用范围不同: 聚簇索引适合于频繁查询范围较小的数据、后者适用于频繁查询单个或少量的记录, 因为每个索引条目只需要查询一次就可以找到相应的行记录。</li>\n<li>字段数量不同: 每张表前者只能有一个，后者可以有多个</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>MySQL 索引</p>\n<ul>\n<li>如何判断 MySQL 中的索引有没有生效: 在 select 语句前面加上 explain 就可以了</li>\n<li>主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值</li>\n<li>唯一索引：唯一索引不能有相同值，但允许为空</li>\n<li>普通索引：允许出现重复值</li>\n<li>组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则</li>\n<li>全文索引：通过建立倒排索引提升检索效率，广泛用于搜索引擎</li>\n</ul>\n</li>\n</ol>\n<ol start=\"11\">\n<li>MySQL 索引的应用场景</li>\n</ol>\n<ul>\n<li>适合：<ul>\n<li>频繁作为查询的字段</li>\n<li>查询作为和其他表关联的字段</li>\n<li>查询中常作为排序条件的字段</li>\n</ul>\n</li>\n<li>不适合：<ul>\n<li>频繁更新的字段</li>\n<li>表的记录不多的字段</li>\n<li>数据重复且分布平均的字段</li>\n</ul>\n</li>\n</ul>\n<ol start=\"12\">\n<li><p>MySQL 索引失效场景</p>\n<ul>\n<li>or 的左右两边不全是索引字段</li>\n<li>% 开头的模糊查询</li>\n<li>违背最左匹配原则</li>\n<li>索引列参与计算</li>\n<li>索引列发生类型转换的时候</li>\n<li>order by 的字段未能出现在 where 条件中</li>\n</ul>\n</li>\n<li><p>MySQL 的基本数据类型</p>\n<ul>\n<li>整型（xxxint）</li>\n<li>位类型(bit)</li>\n<li>浮点型（float 和 double、real）</li>\n<li>日期时间类型（date,time,datetime,year）</li>\n<li>字符串（char,varchar,xxxtext）</li>\n<li>二进制数据（xxxBlob、xxbinary）</li>\n<li>定点数（decimal,numeric）</li>\n<li>枚举（enum）</li>\n<li>集合（set）</li>\n</ul>\n</li>\n<li><p>MySQL 回表</p>\n<ul>\n<li>概念：一般是对于非主键索引而言的, 查询完得到的结果是主键索引的值，然后不但要遍历非主键索引的 B+ 树，还要重新遍历一遍主键索引的 B+ 树，叫做回表</li>\n<li>解决：可以通过覆盖索引的方式解决，即索引的字段中已经包含了需要查询的字段</li>\n</ul>\n</li>\n<li><p>MySQL 锁</p>\n<ul>\n<li>共享锁: 共享锁允许多个事务同时读取同一资源，但是不能进行修改操作。这个语句会给查询的结果集上共享锁，其他事务可以读取这个结果集，但是不能进行修改操作，直到释放锁为止。<ul>\n<li><code>sql SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE; </code></li>\n</ul>\n</li>\n<li>排他锁: 排他锁是最高级别的锁，它禁止其他事务对资源的任何读取和写入操作，只有当前事务可以对资源进行读取和写入操作。<ul>\n<li><code>sql SELECT * FROM table_name WHERE ... FOR UPDATE; </code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>SQL 执行流程</p>\n<ul>\n<li>建立连接校验用户名密码 -&gt; 查询缓存 -&gt; 词法分析语法分析 -&gt; 优化器判断是否有索引 -&gt; 执行器判断是否有权限 -&gt; 执行语句并返回结果集</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><ol>\n<li>缓存故障<ul>\n<li>缓存穿透<ul>\n<li>概念：是用户访问的数据既不在缓存当中，也不在数据库中。当高并发或有人利用不存在的 Key 频繁攻击时，数据库的压力骤增，甚至崩溃，这就是缓存穿透问题。</li>\n<li>解决方法：可以通过布隆过滤器等方式，在缓存中添加一个不存在的数据时，先判断其是否存在于布隆过滤器中，如果不存在则直接返回，避免大量的请求直接访问数据库。</li>\n</ul>\n</li>\n<li>缓存击穿<ul>\n<li>概念：指一个存在的 key，在缓存过期的一刻，同时有大量的请求访问这个 key，由于缓存失效，请求会穿透缓存直接访问数据库，造成数据库压力过大。</li>\n<li>解决方案：可以采用永不过期的方式或者在缓存中添加短暂的二级缓存等方式来解决缓存击穿问题。</li>\n</ul>\n</li>\n<li>缓存雪崩<ul>\n<li>概念：指缓存中的大量数据同时过期失效，导致大量请求直接访问数据库，造成数据库压力过大。</li>\n<li>解决方案：可采用数据预热，提前将缓存数据加载到缓存中，还可以设置多级缓存, 还可采用使用分布式锁控制只有一个请求来重新加载缓存数据，避免缓存雪崩。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li>数据库缓存一致性<ul>\n<li>双写模式: 通常使用的是“先更新数据库，立马更新缓存”的顺序，以确保数据一致性。如果更新缓存失败，可以将缓存标记为失效，让下一次查询时重新从数据库中获取数据。(每次写入都要写入两个地方，可能造成更新操作变慢)</li>\n<li>延时双删：在更新数据库时，先将缓存中的数据标记为无效，然后等待一定时间后再删除缓存数据。(一定时候后才更新缓存，让数据库读写操作更快一点)</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>Redis 的持久化策略</p>\n<ul>\n<li>RDB 持久化 : Redis 会周期性地将内存中的数据集快照写入磁盘，即生成一个 RDB 文件，可能会丢失最后一次快照以后的所有修改。</li>\n<li>AOF 持久化 : Redis 会将执行的每个写命令都记录到一个追加的文件中，在 Redis 重启时，会重新执行 AOF 文件中的所有写命令，以便恢复原始数据集，但会导致更高的磁盘空间占用和更慢的写入性能。</li>\n</ul>\n</li>\n<li><p>Redis 的数据类型</p>\n<ul>\n<li>字符串类型（string）：用于存储单个值，例如整数、浮点数、字符串等。</li>\n<li>列表类型（list）：用于存储一系列有序的值，可以从两端插入或删除元素，支持列表的查找和修剪。</li>\n<li>哈希类型（hash）：用于存储一些字段和值的映射，例如存储用户信息时，可以使用哈希类型存储用户的 ID、姓名、年龄等信息。</li>\n<li>集合类型（set）：用于存储不重复的元素集合，支持交、并、差集等操作。</li>\n<li>有序集合类型（sorted set）：类似于集合类型，但每个元素都有一个分数（score）与之关联，支持按照分数排序。</li>\n</ul>\n</li>\n<li><p>Redis 的数据淘汰策略</p>\n<ul>\n<li>LRU(最少使用): Redis 会根据键最后一次被访问的时间来删除最近最少使用的键。当内存达到限制时，Redis 会优先删除最久未被访问的键，以释放更多的内存空间。</li>\n<li>LFU（最不经常使用）：Redis 会根据键被访问的次数来删除最不经常使用的键。当内存达到限制时，Redis 会优先删除被访问次数最少的键，以释放更多的内存空间。</li>\n<li>TTL（生存时间）：Redis 会根据键的生存时间来删除过期键。每个键都可以设置一个生存时间，当键的生存时间到期时，Redis 会自动删除该键。</li>\n<li>Random（随机）：Redis 会随机删除一些键来释放内存空间。这种策略没有考虑键的访问时间或频率，因此可能会删除一些有用的键。</li>\n<li>Maxmemory-policy（最大内存策略）：这是一种基于多个淘汰策略的组合策略。Redis 会根据当前内存使用量和内存限制来选择合适的淘汰策略。例如，在内存使用量接近内存限制时，Redis 会使用 LRU 或 LFU 策略来删除最近或最不经常使用的键，以保留更多的内存空间。 </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><ol>\n<li><p>交换机类型</p>\n<ul>\n<li>fanoutExchange : 广播交换机，适用于简单模式、订阅模式、工作队列模式</li>\n<li>directExchange : 路由定向交换机，适用于路由模式</li>\n<li>headersExchange: 头交换机，适用于路由模式, 路由交换机的路由是基于路由键，头交换机的路由值基于消息的 header 数据。</li>\n<li>topicExchange : 主题交换机，适用于通配符模式</li>\n</ul>\n</li>\n<li><p>如何解决重复消费问题</p>\n<ul>\n<li>开启手动 ACK 的机制，当消费端消费成功之后会给服务端发送一条确定信息，当收到确认信息之后，我们在服务端才让下一个消息进行消费。默认是自动 ACK，也就是消费端消费成功了不会发送信息给服务端。</li>\n<li>使用唯一的消息 ID，并存到数据库中，每次消费者消费之前都去检查一下这条消息是否被消费过，如果没有才进行消费</li>\n<li>使用分布式锁的方式，比如说 redis 的分布式锁命令 setNX</li>\n</ul>\n</li>\n<li><p>如何保证消费顺序</p>\n<ul>\n<li>在生产端可以给每个消息一个序号，然后消费端按照排序的序号进行消费</li>\n<li>采用单队列单消费者的模式，将同一消息类型的消息放到一个队列中去，因为消费顺序主要是由于不同消费端对不同消息的处理能力不同导致的</li>\n</ul>\n</li>\n<li><p>如何保证消息不丢失</p>\n<ul>\n<li>confirm 模式 ： 保证生产端到交换机这段路，消息无论是否成功被交换机拿到，都要返回一个确认消息</li>\n<li>return 模式： 保证交换机到队列这段路，消息没能到队列才发送一个返回消息。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"基础学科\"><a href=\"# 基础学科\" class=\"headerlink\" title=\"基础学科\"></a>基础学科 </h2><h3 id=\"数据结构\"><a href=\"# 数据结构\" class=\"headerlink\" title=\"数据结构\"></a> 数据结构</h3><ol>\n<li><p>HashMap 的原理</p>\n<ul>\n<li>jdk1.7 与 jdk1.8 的区别：<ul>\n<li>1.7 是单链表，1.8 加入了红黑树</li>\n<li>1.7 是头插法，1.8 使用了尾插法，避免了环形链表死循环的问题</li>\n</ul>\n</li>\n<li>数据结构：数组 + 链表 + 红黑树<ul>\n<li>链表转红黑树条件：数组容量大于 64 且链表长度大于 8, 若数组容量不够则会扩容</li>\n</ul>\n</li>\n<li>为什么使用红黑树<ul>\n<li>AVL 树和红黑树都具有良好的平衡性，但 AVL 树对平衡性的要求比较高，每次插入或删除操作可能需要进行多次旋转操作来保持平衡，这会造成一定的性能开销。而红黑树对平衡性的要求相对较低，可以在一定程度上减少旋转操作的次数，提高插入和删除的性能。</li>\n</ul>\n</li>\n<li>多线程导致的问题<ul>\n<li>线程安全问题：HashMap 不是线程安全的，多个线程同时对 HashMap 进行操作可能会导致数据的不一致性，例如 put 和 remove 操作可能导致元素丢失或重复等问题。</li>\n<li>性能问题：当多个线程同时对 HashMap 进行操作时，由于需要进行锁竞争或者 CAS 操作，可能会导致性能下降，尤其是在高并发情况下。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Concurrenthashmap 原理</p>\n<ul>\n<li>ConcurrentHashMap 采用了分段锁技术来保证并发访问的线程安全性，并且采用了 CAS 操作和 volatile 变量来保证数据的可见性和线程安全性。</li>\n<li>ConcurrentHashMap 将整个存储空间分成若干个小的 Segment 段，每个 Segment 段相当于一个小的 HashMap。</li>\n<li>ConcurrentHashMap 在 Segment 段上加锁，每个线程在访问时只需要锁定对应的 Segment 段，而不需要锁定整个 Map。</li>\n<li>ConcurrentHashMap 在 put、get 等方法中会先根据 key 的 hash 值找到对应的 Segment 段，然后在该 Segment 段内进行操作，从而保证了多线程访问的线程安全性。</li>\n<li>ConcurrentHashMap 在扩容时只需要对 Segment 段进行扩容，而不需要对整个 Map 进行扩容，因此扩容的代价相对较小。</li>\n<li>ConcurrentHashMap 对于读操作和写操作进行了分离，对于读操作没有加锁，可以实现读取的高并发性。</li>\n<li>CAS 和 sychronize 分别在什么时候使用<ul>\n<li>CAS: 被用于实现 ConcurrentHashMap 的 put()和 remove()方法。当多个线程同时对 ConcurrentHashMap 进行 put 或 remove 操作时，CAS 可以确保只有一个线程能够成功地执行该操作。</li>\n<li>synchronize: 被用于实现 ConcurrentHashMap 的 get()方法。当多个线程同时访问 ConcurrentHashMap 中的同一条记录时，需要确保它们访问的是相同的记录，并且在访问过程中不会被其他线程修改。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>B 树和 B+ 树之间的区别</p>\n<ul>\n<li><p>B 树</p>\n<ul>\n<li>它是一种多路的平衡搜索树。</li>\n<li>它跟普通的平衡二叉树的不同是，B 树的每个节点可以存储多个数据，而且每个节点不止有两个子节点，最多可以有上千个子节点。</li>\n<li>B 树中每个节点都存放着索引和数据，数据遍布整个树结构，搜索可能在非叶子节点结束，最好的情况是 O(1)。</li>\n</ul>\n</li>\n<li><p>B+ 树</p>\n<ul>\n<li>B+ 树的层级更少：相较于 B 树 B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快。</li>\n<li>B+ 树查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比 B 树更稳定</li>\n<li>B+ 树区间查询更方便：B+ 树所有的叶子节点数据构成了一个双向链表，在查询大小区间的数据时候更方便，数据紧密性很高。</li>\n<li>B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>\n</ul>\n</li>\n<li><p>InnoDB 为什么选择 B+ 树</p>\n<ul>\n<li>扫库、扫表能力更强：如果我们要对表进行全表扫描，只需要遍历叶子节点就可以了，不需要遍历整棵 B+ 树</li>\n<li>数据连续可达：叶子节点上有下一个数据区的指针，数据形成了链表</li>\n<li>效率稳定：B+ 树永远是在叶子节点拿到数据，所以 IO 次数是稳定的，而 B 树运气好的话根节点就能拿到数据，运气不好就要到叶子节点才能拿到数据，所花费的时间会有差异。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>队列和堆栈</p>\n<ul>\n<li>队列<ul>\n<li>顺序：先入先出</li>\n<li>可在一端插入，另一端删除</li>\n<li>可基于地址指针，从头部或者尾部来遍历，且不需要开辟临时空间，遍历速度更快</li>\n<li>场景：任务调度、消息传递等场景</li>\n</ul>\n</li>\n<li>栈<ul>\n<li>顺序：后入先出</li>\n<li>插入和删除在同一端</li>\n<li>只能从顶部取数据，且需要开辟临时空间，如若要取栈底的元素，得先把所有元素给取出来一遍才行，遍历速度更慢</li>\n<li>场景：回溯、表达式求值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"计算机网络\"><a href=\"# 计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h3><ol>\n<li><p>TCP 和 UDP (传输层协议)</p>\n<ul>\n<li>连接方式<ul>\n<li>TCP 是面向连接的协议，通信双方在传输数据之前需要先建立一个连接。连接的建立需要进行三次握手，确保通信双方能够相互通信，并确认双方都已准备好开始数据传输。数据传输完成后，需要进行四次挥手，正式关闭连接。</li>\n<li>UDP 是无连接的协议，通信双方在传输数据之前不需要建立连接，也不需要进行连接的释放。每个数据包都是独立的，不会建立持久性的连接。</li>\n</ul>\n</li>\n<li>优缺点比较<ul>\n<li>TCP 可靠性高且具有有序性，发送的数据包会按照顺序进行接收，UDP 的可靠性不高且不保证有序性</li>\n<li>TCP 需要提前建立连接，所以传输速度比 UDP 慢, 且实时性也不如 UDP</li>\n<li>TCP 可通过拥塞控制算法避免网络拥堵，但是 UDP 无法避免</li>\n</ul>\n</li>\n<li>总结: TCP 可靠性、有序性、避免网络拥堵,UDP 实时性、传输快</li>\n</ul>\n</li>\n<li><p>http 与 https(应用层协议)</p>\n<ul>\n<li>http<ul>\n<li>概念：HTTP 代表超文本传输协议，它是用于在 Web 浏览器和 Web 服务器之间传输数据的协议。</li>\n<li>机制：HTTP 协议是明文传输数据的，这种明文传输数据的方式存在一定的风险，特别是在传输敏感信息时。</li>\n</ul>\n</li>\n<li>https<ul>\n<li>概念：HTTPS 代表安全超文本传输协议，它是 HTTP 协议的安全版本。</li>\n<li>机制：在 HTTPS 下，传输的数据是通过 SSL 或 TLS 加密的，这样攻击者即使截取到了数据，也无法轻易地解密和阅读其中的内容。HTTPS 还能够验证服务器的身份，确保用户正在与其信任的网站通信，而不是被攻击者伪装的恶意网站。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Http 状态码</p>\n<ul>\n<li>200 OK：请求成功。服务器成功处理了请求，并返回了请求的数据。</li>\n<li>301 Moved Permanently：永久重定向。请求的资源已被永久移动到新的 URL。</li>\n<li>302 Found：临时重定向。请求的资源已被临时移动到新的 URL。</li>\n<li>400 Bad Request：错误请求。服务器无法理解请求，因为请求中包含语法错误。</li>\n<li>401 Unauthorized：未授权。请求需要用户身份验证，但用户未提供有效的身份验证信息。</li>\n<li>403 Forbidden：禁止访问。服务器拒绝了请求，因为请求者没有访问资源的权限。</li>\n<li>404 Not Found：未找到。服务器无法找到请求的资源。</li>\n<li>500 Internal Server Error：服务器内部错误。服务器遇到了意外的情况，无法完成请求。 </li>\n</ul>\n</li>\n<li><p>TCP 粘包问题</p>\n<ul>\n<li>概念：当发送方在短时间内连续发送多个数据包时，接收方在接收数据时可能会将多个数据包合并成一个数据包，从而导致数据包大小超过了接收缓冲区的大小，这就是所谓的粘包问题。</li>\n<li>导致原因：<ul>\n<li>数据发送过快</li>\n<li>接收缓冲区大小不够</li>\n</ul>\n</li>\n<li>解决方案：<ul>\n<li>采用特定的分隔符。发送方在发送数据包之前，在数据包中加入特定的分隔符，接收方在接收数据包时根据分隔符将数据包进行分割。</li>\n<li>采用消息头和消息体。发送方在发送数据包之前，在数据包中加入消息头和消息体，消息头用于标识消息体的长度和类型，接收方在接收数据包时根据消息头将数据包进行分割。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"操作系统\"><a href=\"# 操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><ol>\n<li>进程和线程的区别<ul>\n<li>根本区别：进程是操作系统进行 <strong> 资源分配 </strong> 的最小单元，线程是操作系统进行 <strong> 运算调度 </strong> 的最小单元。</li>\n<li>从属关系不同：进程中包含了线程，线程属于进程。</li>\n<li>开销不同：进程的创建、销毁和切换的开销都远大于线程。</li>\n<li>拥有资源不同：每个进程有自己的内存和资源，一个进程中的线程会共享这些内存和资源。</li>\n<li>CPU 利用率不同：进程的 CPU 利用率较低，因为上下文切换开销较大，而线程的 CPU 的利用率较高，上下文的切换速度快。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"项目积累\"><a href=\"# 项目积累\" class=\"headerlink\" title=\"项目积累\"></a>项目积累 </h1><h2 id=\"项目初衷\"><a href=\"# 项目初衷\" class=\"headerlink\" title=\"项目初衷\"></a> 项目初衷</h2><ul>\n<li>做一个项目来把我所学的技术栈都尽量用起来，主要目的是想在开发项目中不断积累经验达到一个自学的目的。</li>\n</ul>\n<h2 id=\"项目难点及解决方案\"><a href=\"# 项目难点及解决方案\" class=\"headerlink\" title=\"项目难点及解决方案\"></a>项目难点及解决方案</h2><ul>\n<li><p>二级缓存的设置, 将它放在哪比较合适</p>\n<ul>\n<li>使用 Caffine + Redis 构建二级缓存，使用 SpringAOP 将其独立出来</li>\n</ul>\n</li>\n<li><p>如何优雅地使用 SpringSecurity 来实现用户的鉴权和认证</p>\n<ul>\n<li>采用 RBAC0 权限模型、将管理员用户、角色、权限、受保护的 URL 都放入到 MySQL 中并建立相应联系</li>\n<li>合理使用 SpringSecurity 的过滤链，使用数据源、管理器等资源实现系统的权限及认证管理</li>\n</ul>\n</li>\n<li><p>如何让前端更方便地测试</p>\n<ul>\n<li>Swagger 写接口文档</li>\n<li>部署到云服务器</li>\n</ul>\n</li>\n</ul>\n","url":"/posts/41865/","min2read":38,"word4post":"11k","prev_post":{"title":"","url":"/posts/0/"},"next_post":{"title":"BigData-HBase","url":"/posts/10071/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"Java 八股文\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">Java 八股文</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"Java 及 Web 基础\" href = \"#\"><span class=\"toc-number\">1.1.</span> <span class=\"toc-text\">Java 及 Web 基础</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"Spring 全家桶框架\" href = \"#\"><span class=\"toc-number\">1.2.</span> <span class=\"toc-text\">Spring 全家桶框架</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"JUC\" href = \"#\"><span class=\"toc-number\">1.3.</span> <span class=\"toc-text\">JUC</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"JVM\" href = \"#\"><span class=\"toc-number\">1.4.</span> <span class=\"toc-text\">JVM</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"数据库\" href = \"#\"><span class=\"toc-number\">1.5.</span> <span class=\"toc-text\">数据库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"MySQL\" href = \"#\"><span class=\"toc-number\">1.5.1.</span> <span class=\"toc-text\">MySQL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"Redis\" href = \"#\"><span class=\"toc-number\">1.5.2.</span> <span class=\"toc-text\">Redis</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"RabbitMQ\" href = \"#\"><span class=\"toc-number\">1.5.3.</span> <span class=\"toc-text\">RabbitMQ</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"基础学科\" href = \"#\"><span class=\"toc-number\">1.6.</span> <span class=\"toc-text\">基础学科 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"数据结构\" href = \"#\"><span class=\"toc-number\">1.6.1.</span> <span class=\"toc-text\"> 数据结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"计算机网络\" href = \"#\"><span class=\"toc-number\">1.6.2.</span> <span class=\"toc-text\">计算机网络</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"操作系统\" href = \"#\"><span class=\"toc-number\">1.6.3.</span> <span class=\"toc-text\">操作系统</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"项目积累\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">项目积累 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"项目初衷\" href = \"#\"><span class=\"toc-number\">2.1.</span> <span class=\"toc-text\"> 项目初衷</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"项目难点及解决方案\" href = \"#\"><span class=\"toc-number\">2.2.</span> <span class=\"toc-text\">项目难点及解决方案</span></a></li></ol></li></ol>","categories":[{"name":"Interview","path":"api/categories/Interview.json","url":"/categories/Interview/"}],"tags":[]}