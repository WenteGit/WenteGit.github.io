{"title":"Interview","slug":"Interview","date":"2023-03-16","updated":"2023-07-17","comments":true,"path":"api/posts/41865.json","excerpt":"<blockquote><p> 面试八股文与项目介绍 </p></blockquote>","cover":null,"covers":null,"content":"<blockquote>\n<p>面试八股文与项目介绍</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"Java 八股文\"><a href=\"#Java 八股文\" class=\"headerlink\" title=\"Java 八股文\"></a>Java 八股文</h1><h2 id=\"Java 及 Web 基础\"><a href=\"#Java 及 Web 基础\" class=\"headerlink\" title=\"Java 及 Web 基础\"></a>Java 及 Web 基础</h2><ol>\n<li><p>元空间: Java 8 中引入了元空间的概念，将类元数据存储在本地内存中，而不再是永久代。这种方式使得类元数据的管理更加灵活和高效，可以避免永久代出现的问题，如内存溢出、GC 时间过长等。</p>\n</li>\n<li><p>Get、Post、Put 的区别</p>\n<ul>\n<li>数据位置：GET 方法将请求参数附加在 URL 的查询字符串中，而 POST 方法将请求参数放在请求的消息体中。由于 URL 长度的限制，GET 方法的参数传输通常会受到一定的限制。</li>\n<li>安全性：由于 GET 方法将请求参数暴露在 URL 中，因此请求的安全性较低，容易被攻击者截获和窃取。而 POST 方法将请求参数放在消息体中，相对来说更为安全。</li>\n<li>可缓存性：GET 方法通常可以被缓存，因为它的请求参数以及 URL 是不变的。而 POST 方法的请求参数会影响服务器的状态，不能被缓存。</li>\n<li>幂等性：GET 方法是幂等的，即多次请求同一个 URL 的结果相同，不会对服务器状态产生影响。而 POST 方法通常不是幂等的，多次请求同一个 URL 可能会导致服务器状态的改变。</li>\n<li>用途：GET 方法主要用于获取资源，POST 方法主要用于提交数据。例如，用 GET 方法可以请求一个 HTML 页面或图像文件，用 POST 方法可以提交一个表单。</li>\n<li>PUT 请求：<ul>\n<li>如果服务器上已经存在了一个资源，并且客户端发送了一个 PUT 请求，那么服务器将用客户端上传的新资源替换原有的资源。如果服务器上不存在该资源，则会创建一个新的资源。</li>\n<li>PUT 请求通常需要在请求头中指定上传的资源的 URI 和一些元数据，以便服务器正确处理请求。</li>\n<li>与 POST 请求不同，PUT 请求的请求体中通常包含完整的资源内容，而不是仅包含部分数据或请求参数。</li>\n<li>PUT 请求可能会导致服务器上的数据被覆盖或删除，因此在使用 PUT 请求时需要谨慎处理，避免意外修改或删除重要数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Cookie 和 Session 的区别</p>\n<ul>\n<li>存储位置：Cookie 是保存在客户端浏览器中的，而 Session 是保存在服务器端的。</li>\n<li>安全性：Cookie 中的数据可以被客户端浏览器拦截并篡改，因此不适合保存敏感数据，而 Session 保存在服务器端，可以保证数据的安全性。</li>\n<li>存储容量：Cookie 存储容量比较小，通常只能存储几 KB 的数据，而 Session 存储容量较大，可以存储几 MB 的数据。</li>\n<li>生命周期：Cookie 有一个过期时间，如果没有设置过期时间，则默认为浏览器关闭时失效，而 Session 的生命周期由服务器管理，默认情况下，Session 在 30 分钟内无任何操作时会失效。</li>\n</ul>\n</li>\n<li><p>动态代理</p>\n<ul>\n<li>jdk 动态代理 : 适用于代理那些实现了接口的类， 使用 Java 自带的反射机制</li>\n<li>cglib 动态代理: 适用于代理未实现接口的类, 动态代理的效率较低，但具有广泛的适用范围，使用的第三方库的字节码生成技术来实现的</li>\n<li>客户端访问的是代理对象，代理对象负责将调用请求委托给目标对象并应用横切关注点</li>\n<li>Spring 中的使用<ul>\n<li>SpringAoP(jdk 动态代理)：使用 jdk 动态代理来实现横切关注点的切入。通过代理生成机制，Spring 可以在运行时动态地为目标对象创建代理对象，并在目标对象的方法执行前后插入额外的逻辑，如日志记录、性能监控。</li>\n<li>事务管理(jdk 动态代理)：Spring 的声明式事务管理就是通过动态代理来实现的。通过在配置文件或注解中声明事务管理的规则，Spring 会在运行时为标记了事务注解的方法创建代理对象，在方法执行前后进行事务的开启、提交或回滚操作。</li>\n<li>缓存管理(cglib 动态代理)：Spring 的缓存管理模块也使用了动态代理。通过在方法上添加缓存注解，Spring 会在运行时为带有缓存注解的方法生成代理对象，并在方法执行前先从缓存中查找数据或将执行结果存入缓存中，从而提高系统的性能。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>面向对象和面向过程</p>\n<ul>\n<li>面向对象(Java): 将现实世界中的事物抽象成一个个对象，对象包括属性和方法。对象的属性用来描述对象的状态，方法用来描述对象的行为。在面向对象编程中，程序员将不同的对象进行组合，形成一个完整的系统。</li>\n<li>面向过程(C 语言): 是一种基于函数的编程方法，将一个大问题分解为一系列小问题，每个小问题都可以使用一个函数来解决。在面向过程编程中，程序员关注的是程序中的函数，函数之间通过参数传递数据，函数中的变量也只在函数内部有效。</li>\n</ul>\n</li>\n<li><p>Java 的四大引用</p>\n<ul>\n<li>强引用（Strong Reference）：当程序中存在一个强引用时，垃圾回收器将不会回收该对象，只有在该对象的所有强引用都被释放时，垃圾回收器才会将该对象回收。通常使用的对象都是强引用。</li>\n<li>软引用（Soft Reference）：软引用是一种比较弱化的强引用，当内存不足时，垃圾回收器会根据一定的策略（通常是 LRU 算法）来回收软引用所指向的对象。软引用通常用于实现内存敏感的缓存。</li>\n<li>弱引用（Weak Reference）：当一个对象只被弱引用引用时，垃圾回收器在进行垃圾回收时，如果该对象没有被任何强引用引用，那么就会将该对象回收。弱引用通常用于解决内存泄漏问题。</li>\n<li>虚引用（Phantom Reference）：虚引用是 Java 中最弱的一种引用类型，它的作用是在对象被垃圾回收器回收时，收到一个系统通知。虚引用通常用于跟踪对象被垃圾回收器回收的时机，或者在对象被回收时执行一些自定义的清理操作。</li>\n</ul>\n</li>\n<li><p>重写和重载</p>\n<ul>\n<li>重写<ul>\n<li>要求方法名，方法参数，方法返回值类型都要与父类相同，方法返回类型可以是被重写方法返回值类型的子类</li>\n<li>访问修饰符不能比被重写方法的访问修饰符更严格。例如，如果被重写方法是公共方法，则重写方法不能是私有方法。</li>\n<li>重写方法不能抛出更广泛的异常。如果被重写方法抛出一个异常，那么重写方法必须抛出相同的异常或其子类型异常。但是，重写方法可以抛出未检查的异常，即 RuntimeException 以及其子类型异常。</li>\n</ul>\n</li>\n<li>重载<ul>\n<li>同一个类中定义的多个方法，它们具有相同的方法名</li>\n<li>参数列表必须不同，返回类型可以不同</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>String、StringBuffer、StringBuilder</p>\n<ul>\n<li>可变性<ul>\n<li>String 是定长字符串，不可变</li>\n<li>StringBuffer 和 StringBuilder 可变</li>\n</ul>\n</li>\n<li>线程安全性<ul>\n<li>String 是定长字符串，线程安全</li>\n<li>StringBuffer 线程安全，因为每个操作都用 synchronized 同步关键字修饰</li>\n<li>StringBuilder 线程不安全</li>\n</ul>\n</li>\n<li>性能效率<ul>\n<li>String 的性能最低，因为每次发生字符串拼接和修改的时候，都需要创建新的对象和分配内存</li>\n<li>StringBuilder 在单线程的性能更高，多线程的性能低于 StringBuffer</li>\n</ul>\n</li>\n<li>存储位置<ul>\n<li>String 存储在字符串常量池</li>\n<li>StringBuffer 和 StringBuilder 存储在堆内存中</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Java 的 IO 模型</p>\n<ul>\n<li>IO 阻塞模型：当一个线程执行 IO 操作时，它将被阻塞，直到 IO 操作完成。在阻塞状态下，线程无法执行其他任务，因此一个线程只能处理一个 IO 操作。</li>\n<li>IO 非阻塞模型：当进行 IO 操作时，线程可以继续执行其他任务而不需要等待 IO 操作的完成，需要使用循环轮询的方式不断地检查 IO 操作的状态，以确定是否已经完成</li>\n<li>IO 多路复用模型：多路复用是一种通过管理多个 IO 操作来提高效率的技术。在多路复用模型中，一个线程可以同时处理多个 IO 操作，而不需要为每个 IO 操作创建一个单独的线程。</li>\n<li>异步 IO 模型：IO 操作的启动和完成是由系统内核来处理，而不需要应用程序的线程主动参与。当应用程序发起一个异步 IO 操作后，它可以继续执行其他任务，而无需等待 IO 操作的完成。</li>\n</ul>\n</li>\n<li><p>Java 的三大特性</p>\n<ul>\n<li>封装：封装是指将数据和对数据的操作封装在一个类中，通过访问修饰符来控制对数据的访问。封装可以隐藏数据的实现细节，提供统一的接口来访问和操作数据，增加代码的可维护性和安全性。</li>\n<li>继承：继承是指一个类可以继承另一个类的属性和方法。通过继承，子类可以重用父类的代码，并且可以在父类的基础上进行扩展和修改。继承可以建立类之间的层次关系，提高代码的可重用性和扩展性。  </li>\n<li>多态：多态是指同一个方法可以在不同的对象上表现出不同的行为。多态通过方法的重写（覆盖）和方法的重载来实现。通过多态，可以编写更加灵活和通用的代码，提高代码的可扩展性和可维护性。</li>\n</ul>\n</li>\n<li><p>Java 的线程调度</p>\n<ul>\n<li>线程优先级：Java 线程可以设置优先级，优先级越高，操作系统在调度时倾向于给予该线程更多的 CPU 时间片。通过 Thread.setPriority(int priority)方法设置线程的优先级。</li>\n<li>yield()方法：线程可以调用 yield()方法，暗示给操作系统一个提示，表示该线程愿意放弃当前的 CPU 时间片，让其他线程执行。操作系统可以选择忽略该提示。</li>\n<li>sleep()方法：线程可以调用 sleep()方法，使线程暂停执行一段时间，让其他线程有机会获得执行。</li>\n</ul>\n</li>\n<li><p>Java 的常量池、字符串池、对象池</p>\n<ul>\n<li>常量池：Java 中的常量池是一种特殊的存储区域，用于存储编译期间确定的常量。常量池分为两种类型，一种是类常量池，用于存储类中的常量，另一种是运行时常量池，用于存储每个线程的常量。常量池中存储的常量包括基本类型、字符串、类、方法和字段等。</li>\n<li>字符串池：Java 中的字符串池是用于存储字符串的缓存区域，它可以避免重复创建相同字符串对象。字符串池可以通过 String 类的 intern()方法来访问，当调用 intern()方法时，如果字符串池中已经存在相同的字符串，则返回已存在的字符串对象，否则将该字符串对象添加到字符串池中，并返回该字符串对象的引用。</li>\n<li>对象池：Java 中的对象池是一种重复使用对象的机制，它可以减少对象创建和销毁的开销，提高程序的性能。对象池通常用于创建、缓存和重复使用频繁创建和销毁的对象，如线程池、连接池和对象缓存池等。</li>\n<li>总结： 总的来说，常量池、字符串池和对象池都是 Java 虚拟机中的重要概念，它们都是为了提高 Java 程序的性能和节省内存而设计的。常量池用于存储常量，字符串池用于缓存字符串对象，对象池用于重复使用对象，以减少创建和销毁对象的开销。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Spring 全家桶框架\"><a href=\"#Spring 全家桶框架\" class=\"headerlink\" title=\"Spring 全家桶框架\"></a>Spring 全家桶框架</h2><ol>\n<li><p>SpringIOC 和 SpringAOP 的原理</p>\n<ul>\n<li>IOC<ul>\n<li>DI 依赖注入: 通过构造函数、属性或方法参数等方式，将一个对象所依赖的其他对象传递给它，而不是由这个对象自己去创建或查找依赖的对象。这样做的好处是，我们可以更灵活地管理和替换这些依赖</li>\n<li>IC 控制反转: 控制反转的核心思想是将对象的创建和管理交给容器或框架，而不是由程序员自己手动创建和管理对象。这样做的好处是可以将对象的生命周期和作用域管理交给框架或容器，从而避免了一些常见的问题，比如对象的重复创建、对象的生命周期管理等等。</li>\n</ul>\n</li>\n<li>AOP<ul>\n<li>面向切面的技术：所谓“切面”，简单说就是那些与业务无关，却被业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Spring 的三级缓存</p>\n<ul>\n<li>一级缓存：存放已经创建完成的 Bean</li>\n<li>二级缓存：存放早起创建但是未填充属性的 Bean</li>\n<li>三级缓存：存放 ObjectFactory 这样的 Bean 的工厂对象，负责动态的创建和管理 Bean</li>\n<li>主要通过三级缓存可解决循环依赖、Bean 的重复创建等问题</li>\n</ul>\n</li>\n<li><p>Spring 占位符</p>\n<ul>\n<li>‘#’ : #占位符会对输入的参数值进行类型转换，防止 SQL 注入攻击。</li>\n<li>‘$’ : $ 占位符在 SQL 语句中直接替换成输入的参数值，它不会对输入的参数值进行类型转换，也不会防止 SQL 注入攻击</li>\n</ul>\n</li>\n<li><p>RPC 框架</p>\n<ul>\n<li>理解：RPC 是一种用于实现分布式系统间通信的协议和技术，通过隐藏底层的网络通信细节，它允许一个服务通过网络请求另一个计算机上的服务或函数，在使应用程序能够像调用本地函数一样调用远程服务, 并获取结果，实现协同工作和资源共享。和 http 不同的是，HTTP 是一种用于客户端和服务器之间的通信的协议，主要用于 Web 应用程序的数据传输。</li>\n<li>好处：<ul>\n<li>抽象化通信：RPC 隐藏了底层网络通信的细节，使得开发者可以将重点放在业务逻辑上，而不用关心底层的网络通信实现。</li>\n<li>分布式系统的协作：RPC 可以方便地在分布式系统中调用远程服务，使得不同的系统能够协同工作，共享资源和功能。</li>\n<li>跨语言和跨平台支持：RPC 协议可以在不同的编程语言和平台上使用，使得不同技术栈的系统能够互相通信。</li>\n</ul>\n</li>\n<li>SpringCloud<ul>\n<li>注册中心: Ereuka、Zookeeper、Nacos、Consul</li>\n<li>服务调用: restTemplate、OpenFeign</li>\n<li>服务降级：Hystrix、Sentinel</li>\n<li>服务配置：Nacos、Config</li>\n<li>服务网关：GateWay</li>\n<li>服务总线：Bus、Nacos</li>\n</ul>\n</li>\n<li>Hadoop<ul>\n<li>HDFS</li>\n<li>MapReduce</li>\n</ul>\n</li>\n<li>Spark<ul>\n<li>执行流程：<ol>\n<li>根据 RDD 依赖关系 -&gt; DAG 流程图 —(DAGScheduler)–&gt; Stage —-(TaskScheduler)–&gt; tasks</li>\n<li>Executor  —(申请任务)–&gt; SparkContext、 任务调度器 —-(分发任务)—&gt; Executor</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>设计模式</p>\n<ul>\n<li>工厂模式（Factory Pattern）：Spring 中使用工厂模式来实现对象的创建和管理，例如 BeanFactory 和 ApplicationContext 就是工厂模式的典型实现。</li>\n<li>代理模式（Proxy Pattern）：Spring 中使用代理模式来实现 AOP，通过动态代理技术在不改变原有类结构的前提下，对类的方法进行增强或切面操作。</li>\n<li>观察者模式（Observer Pattern）：Spring 中使用观察者模式来实现事件监听器的功能，例如 ApplicationListener 接口就是观察者模式的实现。</li>\n<li>模板模式（Template Pattern）：Spring 中使用模板模式来实现 JdbcTemplate 等模板类，将通用的数据访问逻辑封装在模板类中，提高了代码复用性和可维护性。</li>\n<li>单例模式（Singleton Pattern）：Spring 中大量使用了单例模式，确保在整个应用中只有一个实例对象被创建和共享，提高了应用的性能和效率。</li>\n<li>适配器模式（Adapter Pattern）：Spring 中使用适配器模式来适配各种数据源，例如 JDBC 适配器可以将不同厂商的 JDBC 驱动进行统一适配。</li>\n</ul>\n</li>\n<li><p>Spring 事务</p>\n<ul>\n<li>@Transaction 失效场景<ul>\n<li>事务方法所在的类没有加载到容器中</li>\n<li>事务方法不是 public 类型</li>\n<li>同一类中，一个没有添加事务的方法调用另外以一个添加事务的方法，事务不生效</li>\n<li>抛出异常且手动捕获异常</li>\n<li>Spring 默认抛出了未检查 unchecked 异常（继承自 RuntimeException 的异常）或者 Error 才回滚事务，其他异常需要指定 rollbackFor 才能回滚事务，如果不指定又抛出了其他异常(IOException)，比如说 FileNotFoundException，则事务失效</li>\n</ul>\n</li>\n<li>传播行为<ul>\n<li>Required ： 内外事务合为一个</li>\n<li>New-Required : 内外事务隔离</li>\n<li>Supported : 有事务就按事务执行，没事务就按无事务的方式执行</li>\n<li>Not-Supported : 采用非事务的方式执行</li>\n</ul>\n</li>\n<li>隔离级别<ul>\n<li>RU</li>\n<li>RC</li>\n<li>RR</li>\n<li>可串行化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Bean 的作用域</p>\n<ul>\n<li>singleton : 容器中以单实例存在</li>\n<li>prototype : 容器中以多实例存在</li>\n<li>request   : 在同一个请求内共享</li>\n<li>session   : 在同一个 Session 内存共享</li>\n<li>globalSession : 全局的 Session 都共享同一个 Bean 实例</li>\n</ul>\n</li>\n<li><p>BeanFactory 和 FactoryBean</p>\n<ul>\n<li>BeanFactory : 所有 Bean 的根接口，我把它看做制作 Bean 的图纸的工厂，它在产生 Bean 的同时也提供了依赖注入的能力 </li>\n<li>FactoryBean : 动态生成一个实例 Bean 的工厂，我把它看做按照图纸生成一个实实在在的组件，可加载到容器中去。</li>\n</ul>\n</li>\n<li><p>Bean 的生命周期</p>\n<ul>\n<li>实例化</li>\n<li>属性赋值</li>\n<li>初始化</li>\n<li>销毁</li>\n</ul>\n</li>\n<li><p>分布式事务</p>\n<ul>\n<li><p>CAP 理论：一致性（数据）C、可用性（整个服务）A、分区容忍性 P</p>\n<ul>\n<li>分区：一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。</li>\n<li>分区容忍性：当一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，由于数据项就可能分布到各个区里，所以我们仍然是可以访问的到这个数据的，容忍性就提高了。</li>\n<li>一致性的问题：然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题，因为长时间的阻塞等待会导致我们的服务性能降低，严重的甚至可能导致我们服务崩溃</li>\n</ul>\n</li>\n<li><p>BASE 理论：是对 CAP 的一种解决思路，主要包含三个思想</p>\n<ul>\n<li>Basically Available （基本可用）：系统在面对故障或部分故障时，仍然能够保持基本的可用性，即系统仍然能够对外提供服务，并能够及时响应请求。</li>\n<li>Soft State（软状态）：系统中的数据状态可以在一段时间内是不稳定的，即系统中的数据可能存在中间状态，而不是绝对一致的状态。这种中间状态可能是由于数据复制、缓存等原因导致的。</li>\n<li>Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，系统可以通过一定的机制来保证最终数据的一致性，例如异步复制、定期数据同步等，最终达到数据一致。</li>\n</ul>\n</li>\n<li><p>Seata：<a href=\"https://blog.csdn.net/m0_58600248/article/details/126271252?spm=1001.2014.3001.5506\">https://blog.csdn.net/m0_58600248/article/details/126271252?spm=1001.2014.3001.5506</a></p>\n</li>\n<li><p>XA 模式和 AT 模式的比较</p>\n<ul>\n<li>XA 模式是强一致性，因为所有的本地事务都会等待 TC 发起提交命令之后才会提交自己的事务，对数据的修改才会持久化到磁盘中去</li>\n<li>AT 模式是最终一致性的，因为本地事务执行完 SQL 之后，会先提交，然后才会向 TC 报告自己的状态，如果存在一些本地事务故障，则会导致短暂的不一致的情况，需要第二阶段的回滚这样的补偿机制来保证最终一致性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"JUC\"><a href=\"#JUC\" class=\"headerlink\" title=\"JUC\"></a>JUC</h2><ol>\n<li><p>Synchronized </p>\n<ul>\n<li>原理:synchronized 是 Java 中用于实现同步的关键字，它可以应用于方法或代码块中。其主要原理是通过对一个对象或类进行加锁来保证多个线程之间的互斥访问。当一个线程获取了锁，其他线程就必须等待锁被释放后才能进入被锁定的代码块。 </li>\n<li>锁对象<ul>\n<li>修饰的是普通方法：锁的是实例对象</li>\n<li>修饰的是静态方法：锁的是类 class 对象</li>\n<li>修饰的是代码块：锁的是代码块之前，括号之内的实例对象</li>\n</ul>\n</li>\n<li>锁升级<ul>\n<li>偏向锁：线程 A 第一次竞争到资源，加的是偏向锁,MarkWord 存的是偏向线程 ID，之后只需检查是否是偏向线程访问即可，效率最高。</li>\n<li>轻量级锁：线程 B 来和线程 A 竞争资源且竞争成功，则偏向锁切换偏向线程，竞争失败，则偏向锁升级为轻量级锁, 轻量级锁本质就是自旋锁 CAS</li>\n<li>重量级锁：大量线程参与竞争或 CAS 多次自旋未成功，升级为重量级锁，效率最低</li>\n</ul>\n</li>\n<li>区别于 ReentrantLock:<ul>\n<li>ReentrantLock 显示地获得、释放锁，synchronized 隐式获得、释放锁</li>\n<li>ReentrantLock 可响应中断，可轮回，synchronized 是不可以响应中断的</li>\n<li>ReentrantLock 可以实现公平锁</li>\n<li>ReentrantLock 通过 Condition 可以绑定多个条件</li>\n<li>Lock 是一个接口，而 synchronized 是 java 中的关键字，synchronized 是内置的语言实现</li>\n<li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。</li>\n<li>底层实现不一样，synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线程池</p>\n<ul>\n<li><p>线程池实际上就是，可以通过预先创建一定数量的线程来管理任务执行，并重用线程以减少创建和销毁线程的开销，从而提高程序的性能和效率。但是如果线程池大小设置不当，可能会导致资源浪费或者系统负载过高的问题。如果任务队列中的任务数量过多，或者线程池中的线程数量过少，也可能会导致任务执行的延迟。  </p>\n</li>\n<li><p>七大参数</p>\n<ul>\n<li>核心线程数 corePoolSize </li>\n<li>最大线程数 maximumPoolSize   </li>\n<li>空闲线程的存活时间 keepAliveTime </li>\n<li>存活时间单位 TimeUnit</li>\n<li>阻塞队列 workQueue </li>\n<li>线程工厂 threadFactory </li>\n<li>拒绝策略 handler<ul>\n<li>抛出异常</li>\n<li>任务调回</li>\n<li>丢弃任务</li>\n<li>与最老任务竞争</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>参数设置</p>\n<ul>\n<li>I/O 通常是对数据库的操作, 线程数如果不多的话，在处理 IO 的时候不能用 CPU，导致 CPU 的使用率较低。</li>\n<li>CPU 密集型：<ul>\n<li>核心线程 = CPU 核心</li>\n<li>最大线程 = CPU 核心 + 1</li>\n</ul>\n</li>\n<li>IO 密集型<ul>\n<li>核心线程 = 2*CPU 核心</li>\n<li>最大线程 = 2*CPU 核心 + 1</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>运行流程</p>\n<ul>\n<li>初始化线程池：需要指定线程池的参数，线程池会根据这些参数创建一定数量的线程，并初始化线程池的内部数据结构。</li>\n<li>接收任务：线程池会一直处于运行状态，等待接收任务。当有任务到达时，线程池会接收任务并将其放入任务队列中。</li>\n<li>线程分配任务：线程池中的线程会从任务队列中取出任务。如果核心线程数尚未达到设定的值，线程池会创建新的线程来处理任务。如果核心线程数已满，但还有任务到达，任务会被放入任务队列中等待执行。</li>\n<li>任务执行：线程不断从任务队列中取出任务，并执行任务的逻辑。</li>\n<li>关闭线程池：当不再需要线程池时，可以显式地关闭线程池。一般是先调用 shutdown()方法停止接收新任务，然后再调用 awaitTermination()方法等待任务执行完毕，最后再调用 shutdownNow()方法强制关闭线程池，以确保任务能够顺利完成</li>\n</ul>\n</li>\n<li><p>阻塞队列</p>\n<ul>\n<li>如果需要一个有界队列，且并发读写较多，可以选择使用 ArrayBlockingQueue</li>\n<li>如果需要一个无界队列，或者对阻塞策略有特殊需求，可以选择使用 LinkedBlockingQueue。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>volatile(建议从 JMM 中引入)</p>\n<ul>\n<li>概念：volatile 关键字用于标记变量，指示编译器和运行时系统每次访问该变量时都必须从内存中读取值，而不是使用缓存的值。在多线程编程中</li>\n<li>作用：使用 volatile 可以保证可见性和禁止指令重排，从而保证线程安全。</li>\n<li>补充解释：具体来说，当一个线程修改 volatile 变量的值时，其他线程将立即看到该变量的新值，因为该值是从内存中读取的。此外，由于 volatile 变量不能被缓存，因此在对该变量进行读取和写入操作时，不会发生指令重排，从而避免了线程安全问题。需要注意的是，volatile 仅保证单个操作的原子性，而不是多个操作的原子性。如果需要保证多个操作的原子性，应该使用其他机制，如锁、原子操作等。</li>\n</ul>\n</li>\n<li><p>线程的创建方式</p>\n<ul>\n<li>继承 Thread 类并重写 run()方法</li>\n<li>实现 Runnable 接口或者 Callable 接口</li>\n<li>使用线程池创建接口</li>\n</ul>\n</li>\n<li><p>CAS 可能出现的问题</p>\n<ul>\n<li>ABA 问题：CAS 操作在进行比较时，只会比较原值和期望值是否相等，但是在并发环境下，可能会存在 A-&gt;B-&gt;A 的情况，这时候 CAS 就无法检测出这种情况，导致并发安全问题。</li>\n<li>自旋开销：在使用 CAS 进行无锁编程时，由于 CAS 是一个自旋操作，需要不断地进行尝试和比较，从而可能会带来一定的 CPU 开销和性能损失。</li>\n<li>公平性：CAS 操作无法像锁机制一样保证公平性，可能会导致一些线程一直无法获取资源。</li>\n</ul>\n</li>\n<li><p>线程的同步方式</p>\n<ul>\n<li>synchronized: 采用互斥锁的方式来实现同步，当一个线程进入同步方法时，它会自动获取该方法所属对象的锁，其他线程需要等待该线程释放锁后才能进入该方法。</li>\n<li>ReentrantLock: 是一个可重入的互斥锁，与 synchronized 相比，ReentrantLock 提供了更灵活的锁定机制和更多的功能，如可实现公平锁、可用 condition 绑定很多条件等。</li>\n<li>Semaphore: 是一种计数信号量，用于控制对共享资源的访问。类似线程池的思想</li>\n<li>CountDownLatch: 多个线程并行执行完之后统一地执行主线程</li>\n<li>CyclicBarrier: 多线线程并行执行完之后单开一个线程去执行</li>\n</ul>\n</li>\n<li><p>零拷贝</p>\n<ul>\n<li>概念: 是指在数据传输过程中，数据在不经过中间缓存（如用户态缓存）的情况下，直接从发送端复制到接收端，避免了数据在内存之间的多次复制，从而提高了数据传输的效率。</li>\n</ul>\n</li>\n<li><p>ThreadLocal</p>\n<ul>\n<li>概念：每个线程内部都维护了一个 ThreadLocalMap(懒加载的)，key 为 threadLocal 实例，value 为要保存的副本，说白了就是保存的线程的私有变量, 它允许在多线程环境下，每个线程都拥有自己独立的变量副本，这样就可以避免线程之间的数据互相干扰。</li>\n<li>问题：但是使用 ThreadLocal 会存在内存泄露问题，因为 key(ThreadLocal 这个实例)为弱引用，而 value(存到 ThreadLocal 的实际对象)为强引用，每次 GC 时 key 都会回收，而 value 不会被回收，导致有大量的垃圾对象都无法被回收，从而导致内存没有及时的被释放，从而导致了内存泄漏的问题。所以为了解决内存泄漏问题，可以在每次使用完后删除 value。</li>\n<li>应用场景<ul>\n<li>避免不必要的参数传递：将对象数据存储到 ThreadLocal 中，在本线程任何位置遇到的时候，都可以直接调用 get 方法来取</li>\n<li>线程间数据隔离：每个线程在自己线程里使用自己的局部变量，各线程间的 ThreadLocal 对象互不影响，例子就是 Spring 在 Dao 层，单例对象却可以有多个连接，多个连接都是每个线程自己的副本</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"9\">\n<li><p>线程的五种状态</p>\n<ul>\n<li>新建、就绪、运行、阻塞、死亡</li>\n</ul>\n</li>\n<li><p>sleep()和 wait()的区别</p>\n<ul>\n<li>wait()是 Object 的方法，sleep()是 Thread 类的方法</li>\n<li>wait()会释放锁，sleep()不会释放锁</li>\n<li>wait()要在同步方法或者同步代码块中执行，sleep()没有限制</li>\n<li>wait()要调用 notify()或 notifyall()唤醒,sleep()自动唤醒</li>\n</ul>\n</li>\n<li><p>线程池 execute 和 submit 的区别</p>\n<ul>\n<li>返回值类型不同：execute() 方法返回值为 void，而 submit() 方法返回一个 Future 对象，可以通过该对象获取任务执行的结果。</li>\n<li>对于提交的任务类型不同：execute() 方法只能提交 Runnable 类型的任务，而 submit() 方法可以提交 Runnable 和 Callable 类型的任务。Runnable 代表一个不带返回值的任务，Callable 则代表一个带返回值的任务。</li>\n<li>阻塞行为不同：execute() 方法是一种无阻塞的提交方式，它会立即返回，并将任务提交给线程池中的一个线程执行；而 submit() 方法是一种阻塞的提交方式，它会等待线程池中有一个线程可用时再执行任务，如果线程池中没有可用线程，则任务会等待，直到有线程可用。</li>\n<li>异常处理方式不同：execute() 方法无法处理任务执行过程中抛出的异常，而 submit() 方法可以捕获任务执行过程中抛出的异常，并将其封装到 Future 对象中，以便后续处理。</li>\n</ul>\n</li>\n<li><p>锁分类</p>\n<ul>\n<li>乐观锁 ： 通过 CAS + 版本号</li>\n<li>悲观锁 : 每次获取到资源之后都加锁</li>\n<li>公平锁 ：多个线程按顺序平均都能分到资源 </li>\n<li>非公平锁： 无顺序一直竞争资源</li>\n<li>自旋锁：当锁被占用时，线程不会被阻塞，而是通过不断重试的方式获取锁</li>\n<li>偏向锁：当只有一个线程访问时，该线程可以直接获得锁，不需要进行同步</li>\n<li>可重入锁: 同一个线程能连续获得同一个资源的锁</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><ol>\n<li><p>垃圾回收算法</p>\n<ul>\n<li>标记清除算法: 这是一种最基本的垃圾回收算法。它的核心思想是先标记所有可达对象，然后清除所有未被标记的对象。标记和清除分别需要扫描整个堆，效率较低，同时可能会产生内存碎片。</li>\n<li>标记整理算法: 这种算法在标记阶段与标记 - 清除算法类似，但在清除阶段不是简单地删除未被标记的对象，而是将所有存活对象都向一端移动，然后将另一端的空间全部释放，从而避免了内存碎片的问题。</li>\n<li>复制算法: 这种算法将堆分为两个区域，每次只使用其中的一部分。当当前区域用完后，将存活对象复制到另一个区域中，然后将当前区域中的所有对象清除。复制算法的特点是效率高，但需要两倍的空间。</li>\n<li>分代算法: 这种算法认为对象的生命周期具有不同的阶段，将堆分为多个代，一般将新生代和老年代分开处理。新生代中的对象生命周期较短，采用复制算法；老年代中的对象生命周期较长，采用标记 - 整理算法。分代算法充分利用了对象的生命周期分布规律，提高了垃圾回收效率。</li>\n</ul>\n</li>\n<li><p>垃圾回收器</p>\n<ul>\n<li><p>CMS 收集器</p>\n<ul>\n<li>针对老年代，采用标记 - 清除法，容易产生内存碎片</li>\n<li>以获取最短回收停顿时间为目标</li>\n<li>对 CPU 资源敏感、无法处理浮动垃圾</li>\n</ul>\n</li>\n<li><p>G1 收集器: JDK1.9 以后的默认垃圾回收器</p>\n<ul>\n<li>分代收集，针对不同的分代结果，采用不同的收集算法，包括新生代和老年代</li>\n<li>采用标记 - 整理 + 复制算法回收内存，使用可达性分析法来判断对象是否可以被回收</li>\n<li>能充分利用多 CPU、多核环境下的硬件优势、注重响应速度<ul>\n<li>原理：<ul>\n<li>并行处理：G1 收集器采用了多线程并行处理来加速垃圾回收过程。在收集过程中，G1 将整个堆空间分成多个区域（Region），每个区域都可以被多个线程并行处理。这样，每个线程只需要处理一小部分的垃圾，从而减少了单个线程的工作量，提高了垃圾回收的效率。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>可作为 GCROOT 对象</p>\n<ul>\n<li>长期存活的对象：比如线程池、I/O 等系统资源对象，它们通常需要在整个应用生命周期中持续存在。</li>\n<li>静态变量和常量：静态变量和常量是在类加载时被初始化的，它们的生命周期通常很长。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>新生代晋升到老年代的策略</p>\n<ul>\n<li>对象年龄阈值策略：JVM 中每个对象都有一个年龄计数器，当一个对象在新生代中经历了一定数量的垃圾收集后仍然存活，它的年龄计数器就会增加 1。当一个对象的年龄超过一定阈值时，它就会被晋升到老年代中。可以通过调整年龄阈值来控制对象晋升的速度。</li>\n<li>空间不足：如果新生代的可用空间不足以存放新的对象，JVM 会先尝试触发一次垃圾回收，如果回收后仍然无法获得足够的空间，JVM 就会尝试将部分存活的对象直接晋升到老年代中，以腾出新生代的空间。</li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li>内存结构<ul>\n<li>堆 (线程共享): 存储对象实例、为对象分配内存空间、GC 主要作用区域</li>\n<li>方法区(线程共享): 存储类的元数据信息，如类名、方法名、字段名等。方法区还用于存储运行时常量池、静态变量、即时编译器编译后的代码等信息。</li>\n<li>Java 虚拟机栈: 用于存放 Java 方法执行时的栈帧。每个栈帧包含局部变量表、动态链接、返回地址等信息。当线程调用 Java 方法时，JVM 会在 Java 虚拟机栈中为该方法分配一个栈帧，在方法返回时，该栈帧会被弹出并销毁。</li>\n<li>本地方法栈: 本地方法栈和 Java 虚拟机栈类似，用于存储本地方法 (其他语言编写的) 的栈帧。</li>\n<li>程序计数器: 用于指示 JVM 正在执行哪个线程的字节码指令</li>\n<li>堆的分区<ul>\n<li>新生代(1/3) : Eden(8/10) 幸存区 1(1/10) 幸存区 2(1/10)  [通常采用复制算法]</li>\n<li>老年代(2/3) : 存放存活时间较长的对象，这些对象可能是长时间存活的业务数据、缓存对象、连接池等 [通常采用标记整理算法]</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p>如何减少 Full GC</p>\n<ul>\n<li>尽量少创建一些临时对象</li>\n<li>增加堆的大小</li>\n<li>使用对象池, 提高对象的利用率</li>\n</ul>\n</li>\n<li><p>什么情况下会内存溢出</p>\n<ul>\n<li>堆内存溢出<ol>\n<li>加载的类越来越多时</li>\n<li>当对象一直创建而不被回收时</li>\n<li>虚拟机栈的线程越来越多时</li>\n</ol>\n</li>\n<li>栈溢出<ul>\n<li>方法调用次数过多，一般是递归不当造成</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"7\">\n<li>类加载器<ul>\n<li>概念：类加载机制是 Java 虚拟机（JVM）加载类文件到内存中的过程。</li>\n<li>双亲委派模型: 它首先将这个请求委派给它的父类加载器去完成，如果父类加载器还存在父类加载器，它会将请求一直传递给更高级的父类加载器，直到顶层的父类加载器。</li>\n<li>好处：双亲委派模型保证了类的唯一性，避免了类的重复加载，从而保证 Java 程序的稳定性和安全性。</li>\n<li>种类<ul>\n<li>引导类加载器：也称为根加载器，是最顶层的类加载器，用来加载 Java 的核心库，如 java.lang 包中的类。</li>\n<li>扩展类加载器：负责加载 Java 平台扩展库，默认加载 JAVA_HOME/lib/ext 目录下的 jar 包。</li>\n<li>应用程序类加载器：负责加载应用程序 classpath 目录下的所有类，即我们自己编写的 Java 类。</li>\n<li>自定义类加载器：我们可以通过继承 java.lang.ClassLoader 类实现自己的类加载器，用于实现特定的类加载需求，如从网络上加载类文件等。</li>\n<li>总结：每个类加载器都有自己的加载范围，即它能够加载哪些类。当一个类加载器需要加载一个类时，它会先查找自己已经加载的类，如果没有找到，则向上委托给父类加载器，直到顶层的引导类加载器，如果仍然没有找到，先判断自己是否能加载这个类，如果不能，则会向下委托给子类加载器去加载，总结起来就是自下而上去查找，又自上而下来加载。这样的加载方式构成了 Java 类加载器的双亲委派模型。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h2><ul>\n<li><p>概念：JMM 是指的是 Java 内存模型，它是一种规范，它规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）, 线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。同时，不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。</p>\n</li>\n<li><p>特性</p>\n<ul>\n<li>原子性：一个操作不能被打断，要么全部执行完毕，要么不执行。</li>\n<li>可见性：一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量的这种修改（变化）。</li>\n<li>有序性: 在单线程程序里，确实顺序执行；但是在多线程并发时，程序的执行就有可能出现乱序。</li>\n</ul>\n</li>\n<li><p>有序性和可见性的保证</p>\n<ul>\n<li>synchronized：既保证了多线程的并发有序性，又保证了多线程的内存可见性。<ol>\n<li>获得同步锁</li>\n<li>清空工作内存</li>\n<li>从主内存拷贝对象副本到工作内存</li>\n<li>执行代码(计算或者输出等)</li>\n<li>刷新主内存数据</li>\n<li>释放同步锁</li>\n</ol>\n</li>\n<li>volatile：可以保证内存可见性，不能保证并发有序性(不具有原子性)，可禁止指令重排。<ol>\n<li>将变量 i 从主内存拷贝到工作内存</li>\n<li>刷新主内存数据</li>\n<li>改变 i 的值</li>\n<li>将变量 j 从主内存拷贝到工作内存</li>\n<li>刷新主内存数据</li>\n<li>改变 j 的值</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>volatile 的原理：会生成一个内存 lock 前缀指令，相当于一个内存屏障</p>\n<ul>\n<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>\n<li>它会强制将对缓存的修改操作立即写入主存；</li>\n<li>如果是写操作，它会导致其他 CPU 中对应的缓存行无效。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据库\"><a href=\"# 数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><ol>\n<li><p>四大特性(ACID)</p>\n<ul>\n<li>原子性 ： 每个操作不可再分</li>\n<li>一致性 ： 一个事务可以让数据从一种一致状态切换到另一种一致性状态</li>\n<li>隔离性 ： 事务并行执行互不影响，最后结果和串行执行的结果相同</li>\n<li>持久性 : 一个事务一旦被提交，在数据库中的改变就是永久的，提交后就不能再回滚</li>\n</ul>\n</li>\n<li><p>三大问题</p>\n<ul>\n<li>脏读：读到了未提交的数据</li>\n<li>不可重复读：同一个事务两次读到的数据值不同</li>\n<li>幻读：同一个事务两次读到的数据记录数量不同</li>\n</ul>\n</li>\n<li><p>隔离级别</p>\n<ul>\n<li>READ UNCOMMITTED: 读未提交</li>\n<li>READ COMMITTED: 读已提交</li>\n<li>REPEATABLE READ: 可重复读</li>\n<li>SERIALIZABLE: 可串行化</li>\n</ul>\n</li>\n<li><p>SQL 执行顺序</p>\n<ul>\n<li>from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt; order by -&gt; limit</li>\n</ul>\n</li>\n<li><p>MVCC 原理</p>\n<ul>\n<li>作用:<ul>\n<li>解决脏读、不可重复读的事务读写问题</li>\n<li>在保证隔离性的基础上，提升了读取效率和并发性</li>\n</ul>\n</li>\n<li>描述：在执行 Update 和 Delete 操作的时候，会将每次操作记录记录在 UndoLog 中, 每条记录都有唯一的事务 ID, 而 ReadView 记录了数据版本链的一些统计值，包括活跃事务集，当前事务 ID 等，然后通过四步判断法进行判断，遍历整个版本链，最终得到一个符合所有要求的数据版本。</li>\n<li>四步判断法：第一步主要判断是否是同一个读取的当前事务修改的数据，第二三步是判断是否是读到的未来的数据，第四步是判断是否是读的已提交的数据</li>\n<li>作用解释：因为保证了读到的都是已提交的数据，所以避免了脏读，因为同一个事务使用的都是同一个 Readview，所以保证同一个事务匹配到的是同一个版本的数据，所以避免了不可重复读的问题。</li>\n</ul>\n</li>\n<li><p>日志 Log</p>\n<ul>\n<li>bin log（二进制日志）：记录所有对 MySQL 数据库的更改操作，例如 INSERT、UPDATE、DELETE 等，以二进制格式存储。binlog 文件可以用于数据备份和恢复，数据复制和数据同步。</li>\n<li>undo log（回滚日志）：在事务中，如果执行了 UPDATE 或 DELETE 操作，MySQL 会先将修改前的数据记录到 undo log 中，然后再对数据进行修改。如果事务回滚，则 MySQL 可以使用 undo log 来撤销已经进行的修改。</li>\n<li>redo log（重做日志）：在事务中，MySQL 会先将对数据的修改记录到 redo log 中，然后再进行实际的修改。如果 MySQL 在执行修改操作后崩溃，MySQL 可以使用 redo log 来恢复数据。</li>\n<li>慢查询日志：MySQL 的慢查询日志是一种记录执行时间超过一定阈值的查询语句的日志。可以记录查询语句、执行时间、锁等待时间等信息</li>\n</ul>\n</li>\n<li><p>MySQL 慢查询</p>\n<ul>\n<li>概念：慢查询是指执行时间较长、响应时间较慢的 SQL 查询语句。通常来说，如果一条 SQL 查询语句的执行时间超过了一定的阈值（例如 1 秒钟），就可以将其视为慢查询。</li>\n<li>定位：可以使用 MySQL 的慢查询日志文件</li>\n<li>影响：它们可能会导致服务器资源的过度占用，影响系统的响应速度和稳定性。</li>\n<li>解决方案<ul>\n<li>使用索引：确保表的索引能够覆盖查询的列，这将使 MySQL 能够快速找到需要的数据。</li>\n<li>优化查询语句：使用合适的查询语句可以提高性能。使用 JOIN 时，应该尽可能使用 INNER JOIN 而不是 LEFT JOIN 或 RIGHT JOIN，因为后者可能会导致较慢的查询速度。</li>\n<li>优化表结构：可以改善查询性能。例如，避免使用过多的 JOIN，使用正确的数据类型，避免使用过多的 NULL 值等等。</li>\n</ul>\n</li>\n<li>索引优化<ul>\n<li>索引选择：根据每个字段的特点来选择、尽量走覆盖索引，减少回表</li>\n<li>代码层面：严禁 for 循环查表、连接池参数优化、尽量避免联表查询</li>\n<li>架构层面：分库分表、索引定期维护，定期进行索引的重建、重新组织或碎片整理，可以保持索引的良好状态和性能</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>聚簇索引和非聚簇索引</p>\n<ul>\n<li>区别：<ul>\n<li>物理存储方式不同: 前者的数据存在同一块物理存储区域，后者是建立索引值与行记录映射关系，有点像顺序存储和链式存储</li>\n<li>适用范围不同: 聚簇索引适合于频繁查询范围较小的数据、后者适用于频繁查询单个或少量的记录, 因为每个索引条目只需要查询一次就可以找到相应的行记录。</li>\n<li>字段数量不同: 每张表前者只能有一个，后者可以有多个</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>MySQL 索引</p>\n<ul>\n<li>如何判断 MySQL 中的索引有没有生效: 在 select 语句前面加上 explain 就可以了</li>\n<li>主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值</li>\n<li>唯一索引：唯一索引不能有相同值，但允许为空</li>\n<li>普通索引：允许出现重复值</li>\n<li>组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则</li>\n<li>全文索引：通过建立倒排索引提升检索效率，广泛用于搜索引擎</li>\n</ul>\n</li>\n</ol>\n<ol start=\"10\">\n<li>MySQL 索引的应用场景</li>\n</ol>\n<ul>\n<li>适合：<ul>\n<li>频繁作为查询的字段</li>\n<li>查询作为和其他表关联的字段</li>\n<li>查询中常作为排序条件的字段</li>\n</ul>\n</li>\n<li>不适合：<ul>\n<li>频繁更新的字段</li>\n<li>表的记录不多的字段</li>\n<li>数据重复且分布平均的字段</li>\n</ul>\n</li>\n</ul>\n<ol start=\"11\">\n<li><p>索引是越多越好吗？优缺点在何处？</p>\n<ul>\n<li>优点<ul>\n<li>快速访问：索引可以加速数据访问，使得查询数据更快速。</li>\n<li>提高性能：索引可以提高数据库性能，使得数据的读取更快。</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>索引的成本：索引需要额外的存储空间来存储数据，这可能会占用大量磁盘空间。</li>\n<li>增加写入负担：索引的维护需要一定的时间和计算资源，因此在数据量大且经常写入的情况下，索引的创建和更新可能会带来一定的负担。</li>\n<li>复杂性增加：如果过多的索引被创建，可能会使得数据结构变得更加复杂和难以管理，增加了维护的难度。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>MySQL 索引失效场景</p>\n<ul>\n<li>or 的左右两边不全是索引字段</li>\n<li>% 开头的模糊查询</li>\n<li>违背最左匹配原则</li>\n<li>索引列参与计算</li>\n<li>索引列发生类型转换的时候</li>\n<li>order by 的字段未能出现在 where 条件中</li>\n</ul>\n</li>\n</ol>\n<ol start=\"13\">\n<li>如果索引不合适，会删除吗，是什么流程<ul>\n<li>如果索引不合适，通常会进行重新设计和重建索引，而不是直接删除索引。这是因为索引是数据库中非常重要的组成部分，它们帮助加速查询和提高数据库性能。</li>\n<li>重建索引的流程通常包括以下步骤：<ol>\n<li>确定需要重建索引的表和索引：通过分析数据库性能和查询计划，确定哪些表和索引需要重建。</li>\n<li>停止对表的写操作：停止对需要重建索引的表的写入操作，以确保在重建过程中不会发生数据丢失或数据不一致的情况。</li>\n<li>删除旧的索引：删除需要重建的索引。</li>\n<li>重建索引：根据设计好的新索引结构，重新创建索引。</li>\n<li>重新启用写操作：重建索引完成后，重新启用对表的写入操作。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"14\">\n<li><p>MySQL 的基本数据类型</p>\n<ul>\n<li>整型（xxxint）</li>\n<li>位类型(bit)</li>\n<li>浮点型（float 和 double、real）</li>\n<li>日期时间类型（date,time,datetime,year）</li>\n<li>字符串（char,varchar,xxxtext）</li>\n<li>二进制数据（xxxBlob、xxbinary）</li>\n<li>定点数（decimal,numeric）</li>\n<li>枚举（enum）</li>\n<li>集合（set）</li>\n</ul>\n</li>\n<li><p>MySQL 回表</p>\n<ul>\n<li>概念：一般是对于非主键索引而言的, 查询完得到的结果是主键索引的值，然后不但要遍历非主键索引的 B+ 树，还要重新遍历一遍主键索引的 B+ 树，叫做回表</li>\n<li>解决：可以通过覆盖索引的方式解决，即索引的字段中已经包含了需要查询的字段</li>\n</ul>\n</li>\n<li><p>MySQL 锁</p>\n<ul>\n<li>共享锁: 共享锁允许多个事务同时读取同一资源，但是不能进行修改操作。这个语句会给查询的结果集上共享锁，其他事务可以读取这个结果集，但是不能进行修改操作，直到释放锁为止。<ul>\n<li><code>sql SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE; </code></li>\n</ul>\n</li>\n<li>排他锁: 排他锁是最高级别的锁，它禁止其他事务对资源的任何读取和写入操作，只有当前事务可以对资源进行读取和写入操作。<ul>\n<li><code>sql SELECT * FROM table_name WHERE ... FOR UPDATE; </code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>SQL 执行流程</p>\n<ul>\n<li>建立连接校验用户名密码 -&gt; 查询缓存 -&gt; 词法分析语法分析 -&gt; 优化器判断是否有索引 -&gt; 执行器判断是否有权限 -&gt; 执行语句并返回结果集</li>\n</ul>\n</li>\n</ol>\n<ol start=\"18\">\n<li>SQL 优化<ul>\n<li>查询 SQL 尽量不要使用 select *，而是具体字段</li>\n<li>避免在 where 子句中使用 or 来连接条件</li>\n<li>使用 varchar 代替 char</li>\n<li>查询尽量避免返回大量数据</li>\n<li>尽量使用数值替代字符串类型</li>\n</ul>\n</li>\n</ol>\n<ol start=\"19\">\n<li><p>防止 SQL 注入</p>\n<ul>\n<li>使用 mybatis 的”#{}“预编译，将传入的值按照字符串的形式进行处理</li>\n<li>利用工具进行 SQL 注入检测</li>\n<li>对进入数据库的特殊字符进行转义处理，或编码转换</li>\n<li>校验参数的数据格式是否合法(可以使用正则或特殊字符的判断)</li>\n</ul>\n</li>\n<li><p>存储引擎</p>\n<ul>\n<li>Myisam<ul>\n<li>不支持事务</li>\n<li>不支持外键</li>\n<li>仅支持表锁</li>\n<li>在并发操作时需要加锁，可能导致读写冲突，有性能瓶颈，并发性能较低</li>\n<li>没有缓冲池机制</li>\n<li>叶子结点保存的是数据的地址</li>\n</ul>\n</li>\n<li>innoDB<ul>\n<li>支持事务</li>\n<li>支持外键</li>\n<li>可支持行锁</li>\n<li>具有 MVCC 机制，可以实现读取操作不阻塞写入操作，提供了更好的并发性能</li>\n<li>InnoDB 采用了缓冲池机制，将数据和索引缓存到内存中，加快数据的访问速度。</li>\n<li>叶子结点保存的就是数据</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数据库主键是否可以用 string 类型，比如说 UUID，优缺点是什么</p>\n<ul>\n<li>断言：可以，有优势有劣势，需要做取舍</li>\n<li>优势<ul>\n<li>全局唯一性：UUID 是一个由 128 位数字组成的字符串，几乎可以保证在不同系统和数据库之间的唯一性。这对于分布式系统和多个独立数据库之间的数据一致性非常重要。</li>\n<li>无需数据库自增：可以方便地在分布式环境中生成主键，而无需额外的同步机制</li>\n</ul>\n</li>\n<li>劣势<ul>\n<li>存储空间占用：相比于整数类型的主键，string 类型的主键会占用更多的存储空间</li>\n<li>索引效率低下：string 类型的主键会导致索引文件变大、需要更多的磁盘 IO 和内存消耗，会降低我们的索引效率，也就降低了我们的查询效率</li>\n<li>不适合作为聚焦索引：聚集索引的顺序会对数据的存储和访问效率产生影响，而 UUID 的无序性会导致频繁的数据页分裂和不均匀的存储</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Mysql 集群</p>\n<ul>\n<li>主从复制<ul>\n<li>原理：主服务器上的写操作会立即被记录到二进制日志，并通过网络传输到从服务器，然后在从服务器上执行相同的操作来复制数据。复制过程是异步的，主服务器上的写操作并不会等待从服务器的执行完成。 但是如果主服务器发生故障或网络中断，复制会暂时停止。当主服务器恢复后，从服务器会自动重新连接并继续复制。</li>\n<li>优点<ul>\n<li>读写分离：主服务器负责处理写操作，而从服务器可以处理读操作。</li>\n<li>故障恢复：当主服务器发生故障时，可以将其中一个从服务器提升为新的主服务器，实现快速的故障转移和自动恢复，降低业务中断时间。</li>\n<li>扩展性：通过添加更多的从服务器，可以水平扩展数据库系统，处理更大规模的并发请求和数据量。</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>数据延迟：由于主从复制是异步的过程，从服务器上的数据复制存在一定的延迟。这意味着从服务器上的数据可能不是实时的，可能存在一小段时间的数据不一致。</li>\n<li>单点故障：从复制架构中的主服务器仍然是单点故障的风险。如果主服务器发生故障，需要手动切换到一个备用的从服务器来代替主服务器，可能导致一定的停机时间和数据丢失。</li>\n<li>无法水平扩展写操作：主从复制只能将写操作限制在主服务器上，从服务器只能进行读操作。这限制了系统的写操作扩展性，主服务器的性能成为瓶颈</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>双主模式<ul>\n<li>优点<ul>\n<li>高可用性：双主模式提供了更高的可用性，因为系统不会出现单点故障。如果其中一个主服务器发生故障，另一个主服务器可以继续处理写操作，从而实现故障转移并保持业务的连续性。</li>\n<li>数据一致性：在双主模式下，每个主服务器都可以接收和处理写操作，写操作会同时在两个主服务器上执行。这意味着数据在两个主服务器之间具有更高的一致性，不会出现主从复制的延迟和不一致性问题。</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>冲突处理：在双主模式下，同时在两个主服务器上执行写操作可能会导致数据冲突的问题。例如，如果两个主服务器同时修改相同的数据行，就会出现冲突，需要解决冲突并确保数据一致性。</li>\n<li>配置和管理复杂性：双主模式的配置和管理相对复杂。需要确保双主服务器之间的复制设置正确，并处理可能出现的冲突和同步问题。<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>缓存故障</p>\n<ul>\n<li>缓存穿透<ul>\n<li>概念：是用户访问的数据既不在缓存当中，也不在数据库中。当高并发或有人利用不存在的 Key 频繁攻击时，数据库的压力骤增，甚至崩溃，这就是缓存穿透问题。</li>\n<li>解决方法：可以通过布隆过滤器等方式，在缓存中添加一个不存在的数据时，先判断其是否存在于布隆过滤器中，如果不存在则直接返回，避免大量的请求直接访问数据库。</li>\n</ul>\n</li>\n<li>缓存击穿<ul>\n<li>概念：指一个存在的 key，在缓存过期的一刻，同时有大量的请求访问这个 key，由于缓存失效，请求会穿透缓存直接访问数据库，造成数据库压力过大。</li>\n<li>解决方案：可以采用永不过期的方式或者在缓存中添加短暂的二级缓存等方式来解决缓存击穿问题。</li>\n</ul>\n</li>\n<li>缓存雪崩<ul>\n<li>概念：指缓存中的大量数据同时过期失效，导致大量请求直接访问数据库，造成数据库压力过大。</li>\n<li>解决方案：可采用数据预热，提前将缓存数据加载到缓存中，还可以设置多级缓存, 还可采用使用分布式锁控制只有一个请求来重新加载缓存数据，避免缓存雪崩。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li>数据库缓存一致性<ul>\n<li>双写模式: 通常使用的是“先更新数据库，立马更新缓存”的顺序，以确保数据一致性。如果更新缓存失败，可以将缓存标记为失效，让下一次查询时重新从数据库中获取数据。(每次写入都要写入两个地方，可能造成更新操作变慢)</li>\n<li>延时双删：在更新数据库时，先给缓存中的数据设置过期时间，然后等待一定时间后再删除缓存数据。(一定时候后才更新缓存，让数据库读写操作更快一点)</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>Redis 的持久化策略</p>\n<ul>\n<li>RDB 持久化 : Redis 会周期性地将内存中的数据集快照写入磁盘，即生成一个 RDB 文件，可能会丢失最后一次快照以后的所有修改。</li>\n<li>AOF 持久化 : Redis 会将执行的每个写命令都记录到一个追加的文件中，在 Redis 重启时，会重新执行 AOF 文件中的所有写命令，以便恢复原始数据集，但会导致更高的磁盘空间占用和更慢的写入性能。</li>\n</ul>\n</li>\n<li><p>Redis 的数据类型</p>\n<ul>\n<li>字符串类型(string)：用于存储单个值，例如整数、浮点数、字符串等。</li>\n<li>列表类型（list）：用于存储一系列有序的值，可以从两端插入或删除元素，支持列表的查找和修剪。</li>\n<li>哈希类型（hash）：用于存储一些字段和值的映射，例如存储用户信息时，可以使用哈希类型存储用户的 ID、姓名、年龄等信息。</li>\n<li>集合类型（set）：用于存储不重复的元素集合，支持交、并、差集等操作。</li>\n<li>有序集合类型（sorted set）：类似于集合类型，但每个元素都有一个分数（score）与之关联，支持按照分数排序。<ul>\n<li>zset 原理：基于跳表和哈希表实现的，跳跃列表主要用于提供有序性和支持范围查询等操作，而哈希表则用于提供快速的插入、删除和查找操作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Redis 的数据淘汰策略</p>\n<ul>\n<li>LRU (最近最少使用): Redis 会根据键最后一次被访问的时间来删除最近最少使用的键。当内存达到限制时，Redis 会优先删除最久未被访问的键，以释放更多的内存空间。</li>\n<li>LFU (最不经常使用)：Redis 会根据键被访问的次数来删除最不经常使用的键。当内存达到限制时，Redis 会优先删除被访问次数最少的键，以释放更多的内存空间。</li>\n<li>TTL (生存时间)：Redis 会根据键的生存时间来删除过期键。每个键都可以设置一个生存时间，当键的生存时间到期时，Redis 会自动删除该键。</li>\n<li>Random (随机)：Redis 会随机删除一些键来释放内存空间。这种策略没有考虑键的访问时间或频率，因此可能会删除一些有用的键。</li>\n<li>Maxmemory-policy（最大内存策略）：这是一种基于多个淘汰策略的组合策略。Redis 会根据当前内存使用量和内存限制来选择合适的淘汰策略。例如，在内存使用量接近内存限制时，Redis 会使用 LRU 或 LFU 策略来删除最近或最不经常使用的键，以保留更多的内存空间。</li>\n</ul>\n</li>\n<li><p>Redis 为什么快</p>\n<ul>\n<li>完全基于内存，通过磁盘 IO 读取到内存这部分的开销</li>\n<li>数据结构简单，对数据操作也简单，主要使用 string、list、hash、set、zset 这几种数据结构</li>\n<li>采用单线程来处理，省去了很多上下文切换的时间以及 CPU 消耗</li>\n<li>使用基于 IO 多路复用机制的线程模型，可以处理并发的链接</li>\n</ul>\n</li>\n<li><p>Redis 分布式锁</p>\n<ul>\n<li>背景<br>  为什么要有分布式锁：传统的锁，包括 sychronized、包括 ReentrantLock 都只能锁单机，只能控制多线程对单机的访问，但是如果基于分布式架构，比如说在我们的微服务应用当中，不同的服务部署在不同的机器上，且各个服务之间也有交互，则传统的锁就会失效，所以需要一个能够在分布式架构中也能起到访问控制的锁出现，也就是我们的分布式锁，而其中 redis 分布式锁就是其中的一种</li>\n<li>原理<ul>\n<li>基于 setNx：setNx 是 Redis 的一个原子操作，用于设置一个键值对，但只在键不存在时才执行。要获取锁，客户端可以使用 SETNX 命令在 Redis 中创建一个特定的键，并设置一个随机的唯一标识作为值。如果 SETNX 操作返回 1，表示客户端成功获取到锁；如果返回 0，表示锁已被其他客户端持有。在释放锁时，客户端可以使用 DEL 命令删除对应的键。</li>\n</ul>\n</li>\n<li>命令<ul>\n<li>SET key value [EX seconds] [PX milliseconds] [NX|XX]: 尝试给指定的 key 设置一个对应的 value。该指令可以用于获取锁。参数 EX 和 PX 用于设置键的过期时间，NX 表示只在键不存在时设置值（用于获取锁），XX 表示只在键已经存在时设置值（用于释放锁）。</li>\n<li>GETSET key value: 设置给定 key 的 value 并返回旧的 value。该指令可用于检查并更新锁的值。</li>\n<li>DEL key: 删除指定的 key。该指令可用于释放锁。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Zookeeper 锁</p>\n</li>\n</ol>\n<ul>\n<li><p>原理</p>\n<ul>\n<li><p>创建锁节点：当一个进程或线程需要获取锁时，它会在 ZooKeeper 上创建一个有序临时节点（例如：/locks/lock-000000001）。</p>\n</li>\n<li><p>检查前一个节点：进程会获取当前创建的有序节点的序号，并检查是否它是当前锁下的最小序号节点。如果是最小节点，表示当前进程获取到了锁，可以执行相关操作。否则，进程会监听前一个节点（例如：/locks/lock-000000000）的删除事件。</p>\n</li>\n<li><p>监听前一个节点：进程在 ZooKeeper 上对前一个节点进行注册监听器。如果前一个节点被删除（即前一个进程释放了锁），ZooKeeper 会通知当前进程。</p>\n</li>\n<li><p>锁释放：当进程完成了任务，它会删除自己创建的节点，从而释放锁。这会触发 ZooKeeper 通知下一个等待的进程。</p>\n</li>\n</ul>\n</li>\n<li><p>总结</p>\n<ul>\n<li><p>通过这个基本的原理，ZooKeeper 锁可以实现互斥访问，保证在任意时刻只有一个进程能够获取到锁，其他进程需要等待。同时，ZooKeeper 的有序临时节点保证了节点创建的顺序，进程可以根据节点的序号判断自己是否是当前锁下的最小节点。</p>\n</li>\n<li><p>需要注意的是，使用 ZooKeeper 锁时要处理会话过期和网络分区等异常情况。当一个进程的会话过期或与 ZooKeeper 服务器失去连接时，它创建的临时节点会被自动删除，从而释放锁。此外，由于 ZooKeeper 是一个分布式系统，网络分区或 ZooKeeper 服务器故障可能会导致锁的不可用性或不确定性。因此，在使用 ZooKeeper 锁时，需要考虑这些异常情况并进行相应的处理和恢复机制。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ol start=\"8\">\n<li><p>Redis 集群</p>\n<ul>\n<li><p>主从复制</p>\n<ul>\n<li>作用：对读写能力扩展，采用读写分离的方式解决性能瓶颈</li>\n<li>原理：运行新的服务器（简称为从服务器），从服务器与主服务器进行连接，主服务器发送数据副本，从服务器通过网络根据主服务器的数据副本进行准实时更新（具体的更新速度取决于网络带宽），主服务器可以进行读写操作，当写操作导致数据发生变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。</li>\n<li>优势<ul>\n<li>读写分离：主从复制，主机会自动将数据同步到从机，实现了读写分离</li>\n<li>分担主服务器压力：从服务器同样可以接受其他从服务器的连接和同步请求，这样可以有效的分载主服务器的同步压力</li>\n<li>非阻塞提供服务：主服务器是以非阻塞的方式为从服务器提供服务，所以在主从同步期间，客户端依然可以提交查询或修改请求，从服务器也是以非阻塞的方式完成数据同步的，在同步期间，如果有客户端提供查询请求，Redis 则返回同步之前的数据。</li>\n</ul>\n</li>\n<li>劣势<ul>\n<li>容易发生单点故障的问题，主机宕机之后，则无法进行写请求，需要人工干预来选择新的主节点</li>\n<li>主机宕机后如果有部分数据没有及时同步到从机，更换主机 IP 后会导致数据不一致的问题</li>\n<li>如果多个从机断线，需要重启的时候，如果在同一时间段进行重启，多个 slave 重启，都会发送 sync 请求 (redis2.8 之后是 psync) 并进行主机全量同步，那就会导致主机 IO 剧增从而主机宕机</li>\n<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容就会变得艰难</li>\n</ul>\n</li>\n<li>psync 和 sync 的区别：psync 是只同步掉线期间的数据，sync 是全量同步</li>\n</ul>\n</li>\n<li><p>哨兵机制</p>\n<ul>\n<li>作用：用一个哨兵来监控所有的服务器状态，一旦发现某个主服务器宕机或故障了，就自动让从服务器顶上去</li>\n<li>原理：哨兵是一个独立的进程，会独立运行，哨兵进程通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器当哨兵进程检测到某个主机宕机后，会自动将 slave 切换为 master，然后通过发布订阅模式同之其他从服务器，修改配置文件，让他们切换主机</li>\n<li>服务器下线认定<ul>\n<li>主观下线：如果一个服务器没有在 master-down-after-milliseconds 选项所指定的时间内，对向它发送 PING 命令的哨兵返回一个有效的回复，那么哨兵就会将这个服务器标记为主观下线</li>\n<li>客观下线：客观下线的评判由多个哨兵完成，一个主机是否下线，由多个哨兵投票完成，当多个哨兵说该主机下线了，那么它就是下线了</li>\n<li>主观切换到客观标准：如果哨兵在给定范围内，从其他哨兵那里接收到了足够数量的主服务器下线报告，那么哨兵就会将主服务器的状态从主观下线切换为客观下线</li>\n<li>下线标记去除：如果没有足够的哨兵进程同意主服务器下线，那么主服务器的客观下线状态标记就会被移除，如果主服务器重新向哨兵发送的 PING 命令返回了有效的回复，主服务器的主观下线状态就会被移除</li>\n<li>补充：客观下线只适用于主服务器，对于其他类型的 Redis 实例，哨兵在将它们判断为下线前不需要进行协商，所以从服务器或其他哨兵不会达到客观下线条件。</li>\n</ul>\n</li>\n<li>任务<ul>\n<li>监控（Monitoring）： 哨兵会不断检查主服务器和从服务以及其他哨兵是否运作正常</li>\n<li>提醒（Notification）: 当被监控的某个服务器出现问题时，哨兵可以通过 API 向管理员或其他应用程序发送通知</li>\n<li>自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时，哨兵会开始一次自动故障转移操作，它会将失效的主服务器的其中一个从服务器升级为新的主服务器，并让失效的主服务器的其他从服务器知晓新的主服务器。当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。</li>\n</ul>\n</li>\n<li>优势<ul>\n<li>从上文可以看出，哨兵机制集群模式是基于主从复制模式的，所以它有主从复制的所有优点</li>\n<li>主从服务器可以自动切换，系统更加健壮，可用性更高</li>\n</ul>\n</li>\n<li>劣势<ul>\n<li>内存浪费：每台 Redis 服务器都存储了相同的数据，非常浪费内存</li>\n<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容就会变得很复杂</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Cluster 模式(Redis 内置集群)</p>\n<ul>\n<li>架构图 <img src = \"http://xtzl.wentexl.cn/redis%E7%9A%84cluster.png\"/></li>\n<li>作用：每台 Redis 节点上存储了不同的内容</li>\n<li>原理：任意两个节点之间都是相互连通的（采用的是 PING-PONG 机制），内部使用二进制协议优化传输速度和带宽。客户端可以与任意一个节点相连，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作，Redis 集群使用的是哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 Key 通过 CRC16 校验后对 16384 取模来决定放置在那个槽。集群中的每个节点负责一部分的 hash 槽，意思是无论有多少个节点，都只有 16384 个槽来分</li>\n<li>保证高可用：Redis-Cluster 集群引入了主从复制模型，一个主节点对应一个或多个从节点，当主节点宕机后，就会启用从节点</li>\n<li>对主机的宕机判断：采用的是投票方式，当其它主节点 ping 一个主节点时，如果半数以上的主节点与其通信超时，那么就认为该主节点宕机了，为了得出投票结果，主节点个数一般是奇数。</li>\n<li>优势<ul>\n<li>使用这种架构很容易添加或删除节点，比如如果想删除某个节点，那么就将该节点的槽移动到其他节点上，然后将没有任何槽的节点移除</li>\n<li>在一定程度上节约了内存空间</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>reids 判断键已过期</p>\n<ul>\n<li>定期删除：Redis 服务器会周期性地（默认每秒钟 10 次）随机检查一部分设置了过期时间的键，并删除其中已经过期的键。这个过程是通过 Redis 的『定时器』来完成的，每次执行一小部分过期键的删除操作，以避免对服务器的性能产生明显的影响。</li>\n<li>惰性删除：当客户端访问一个设置了过期时间的键时，Redis 会先检查这个键是否已经过期，如果过期则立即删除。这种方式确保了过期键能够在被访问时立即被删除。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"MQ\"><a href=\"#MQ\" class=\"headerlink\" title=\"MQ\"></a>MQ</h2><h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><blockquote>\n<p>优秀博文：<a href=\"https://baijiahao.baidu.com/s?id=1737713844357727373&amp;wfr=spider&amp;for=pc\">https://baijiahao.baidu.com/s?id=1737713844357727373&amp;wfr=spider&amp;for=pc</a></p>\n<hr>\n<ul>\n<li>消息消费失败，由于 retry 重试机制，重新入队又将消息发送出去。</li>\n<li>消息确认机制影响性能，非必要不使用；</li>\n<li>消费者先保证消息能签收，业务处理失败可以人工补偿。</li>\n</ul>\n<hr>\n</blockquote>\n<ol>\n<li><p>交换机类型</p>\n<ul>\n<li>FanoutExchange : 广播交换机，适用于简单模式、订阅模式、工作队列模式</li>\n<li>DirectExchange : 路由定向交换机，适用于路由模式</li>\n<li>HeadersExchange: 头交换机，适用于路由模式, 路由交换机的路由是基于路由键，头交换机的路由值基于消息的 header 数据。</li>\n<li>TopicExchange : 主题交换机，适用于通配符模式</li>\n</ul>\n</li>\n<li><p>重复消费问题</p>\n<ul>\n<li>产生原因   <ul>\n<li>消息消费成功: 事务已提交，签收时结果服务器宕机或网络原因导致签收失败，消息状态会由 unack 转变为 ready，重新发送给其他消费方</li>\n<li>消息消费失败: 由于 retry 重试机制，重新入队又将消息发送出去。</li>\n</ul>\n</li>\n<li>解决方案<ul>\n<li>开启手动 ACK 的机制，当消费端消费成功之后会给服务端发送一条确定信息，当收到确认信息之后，我们在服务端才让下一个消息进行消费。默认是自动 ACK，也就是消费端消费成功了不会发送信息给服务端。</li>\n<li>使用唯一的消息 ID，并存到数据库中，每次消费者消费之前都去检查一下这条消息是否被消费过，如果没有才进行消费</li>\n<li>使用分布式锁的方式，比如说 redis 的分布式锁命令 setNX</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何保证消费顺序</p>\n<ul>\n<li>在生产端可以给每个消息一个序号，然后消费端按照排序的序号进行消费</li>\n<li>采用单队列单消费者的模式，将同一消息类型的消息放到一个队列中去，因为消费顺序主要是由于不同消费端对不同消息的处理能力不同导致的</li>\n</ul>\n</li>\n<li><p>消息丢失</p>\n<ul>\n<li>产生原因<ul>\n<li>消息发出后，中途网络故障，服务器没收到；</li>\n<li>消息发出后，服务器收到了，消费方还未处理业务逻辑，服务却挂掉了，而消息也自动签收，等于啥也没干。</li>\n</ul>\n</li>\n<li>解决方案<ul>\n<li>confirm 模式 ： 保证生产端到交换机这段路，消息无论是否成功被交换机拿到，都要返回一个确认消息</li>\n<li>return 模式： 保证交换机到队列这段路，消息没能到队列才发送一个返回消息。</li>\n<li>手动 ACK 模式：消费成功才将消息移除，失败或因异常情况而尚未处理，就重新入队。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><ol>\n<li><p>消息丢失</p>\n<ul>\n<li>解决方案<ul>\n<li>服务端持久化设置为同步刷盘：消息投递到 broker 的时候，需要将消息进行持久化，分同步刷盘和异步刷盘，同步刷盘的话可保证消息一定不丢失，就算丢失了也可以选择即时补偿，也就是重新发一次</li>\n<li>生产者设置为同步投递：使用带有回调通知的 send 方法，并且设置 acks = all，则可保证是同步方式，也就是说必须要让服务器确认收到消息之后才会继续往下执行。如果服务器没来得及接收就宕机了，也可以保证消息不丢失，因为生产者在投递消息的时候会有记录日志，等服务器重启之后，可以通过日志信息去完成对消息的补偿</li>\n<li>消费者设置成手动 ack 提交: kafka 中，消息消费完成之后不会立即删除，而是使用定时的清除策略，当我们确保消息成功消费之后，我们要进行手动的 ack 提交，如果消息失败，则要不断重试</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>消息顺序</p>\n<ul>\n<li>触发场景<ul>\n<li>一个 topic 有多个 partition，producer 生产者将一组有序的消息被分散发送到了不同的 partition</li>\n<li>多个消费者消费了同一个 partition 的消息</li>\n</ul>\n</li>\n<li>解决方案<ul>\n<li>单线程发送消息到 MQ，单线程对 MQ 进行消费，即消费者和生产者都是单线程的，且 Topic 中只有一个 partition</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>重复消费</p>\n<ul>\n<li>触发场景<ul>\n<li>消费者宕机且还未来得及向 GroupCoordinator 的_consumer_offsets 提交位移，默认是每 5s 提交一次，重启后会导致重复消费的问题</li>\n<li>消费端处理性能较低，在默认的 5 分钟以内没办法处理完消息，则会触发 Rebalance 机制，原分区交给其他的消费者消费了，但是由于_consumer_offsets 的滞后性，所以原分区仍然会存在一部分消息会被新的消费者重复消费</li>\n</ul>\n</li>\n<li>解决方案<ul>\n<li>采用异步的方式处理消息，缩短消息的消费时长</li>\n<li>调整消息处理的默认时间，可以拉长一点，避免触发 rebalance 机制</li>\n<li>对每个消息都设置一个唯一键，可以保存在 mysql 或者 redis 中，在消费消息之前先去 mysql 或者 redis 中判断是否该消息已经被消费，如果被消费了则跳过消费</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Kafka 的选举策略</p>\n<ul>\n<li>Controller 的选举<ul>\n<li>原理：所有的 broker 都尝试去在 zookeeper 中创建一个临时的节点 controller，谁先创建成功，谁就担任了 controller 的角色，如果挂了或者网络出现问题，则临时节点就会消失，需要按先到先得来重新选举。</li>\n<li>职责：<ul>\n<li>监听 Broker、Topic、Partition 的变化</li>\n<li>获取和管理 Broker、Topic、Partition 的信息</li>\n<li>获取 Partition 的主从信息，并参与 leader 的选举过程</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Leader 的选举<ul>\n<li>原理：在 ISR 集合中的副本通常是与原 leader 保持数据同步的副本，具有优先被选择权，默认让 ISR 的第一个副本成为 Leader。但是如果 ISR 中没有副本，则可以通过调整设置，默认让拥有最新数据的那个副本成为 leader</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"基础学科\"><a href=\"# 基础学科\" class=\"headerlink\" title=\"基础学科\"></a>基础学科 </h2><h3 id=\"数据结构\"><a href=\"# 数据结构\" class=\"headerlink\" title=\"数据结构\"></a> 数据结构</h3><ol>\n<li><p>HashMap 的原理</p>\n<ul>\n<li>在 jdk1.7 与 jdk1.8 的区别：<ul>\n<li>数据结构：jdk1.7 是数组 + 链表，jdk1.8 引入了红黑树这样一种综合能力强的数据结构</li>\n<li>插入方法：jdk1.7 是采用的头插入法来将元素插入进链表，这可能导致链表倒置，jdk1.8 是采用的尾插法来将元素插入进链表</li>\n<li>扩容优化：数组容量大于 64 且链表长度大于 8，会首先将链表转成红黑树，并不会直接扩容</li>\n</ul>\n</li>\n<li>为什么使用红黑树<ul>\n<li>红黑树也是一种平衡二叉树，每个节点有一个储存位表示节点的颜色，可以是红色或者黑色。通过对任意一条从根到叶子的路径上各个节点着色方式的限制，红黑树确保没有任意一条从根到叶子的路径超过最短路径的两倍，因此红黑树是一种弱平衡二叉树，但是它有着良好的稳定性和完整的功能，性能表现也很不错，综合实力强。相对于 AVL 树来说，红黑树的旋转次数少，对于搜索、插入、删除多的操作下用红黑树就更为合适了。</li>\n</ul>\n</li>\n<li>多线程导致的问题<ul>\n<li>线程安全问题：HashMap 不是线程安全的，多个线程同时对 HashMap 进行操作可能会导致数据的不一致性，例如 put 和 remove 操作可能导致元素丢失或重复等问题。</li>\n<li>性能问题：当多个线程同时对 HashMap 进行操作时，由于需要进行锁竞争或者 CAS 操作，可能会导致性能下降，尤其是在高并发情况下。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Concurrenthashmap 原理</p>\n<ul>\n<li><p>数据结构</p>\n<ul>\n<li>jdk1.7：JDK 1.7 中的 ConcurrentHashMap 的每个 Segment 段中的数据结构是数组 + 链表</li>\n<li>jdk1.8：而在 JDK 1.8 中，ConcurrentHashMap 使用了更为高效的数据结构，引入了红黑树。</li>\n</ul>\n</li>\n<li><p>并发度</p>\n<ul>\n<li>jdk1.7：JDK 1.7 的 ConcurrentHashMap 的并发度是固定的，即段的数量是固定的，由构造函数中的参数指定。</li>\n<li>jdk1.8：在 JDK 1.8 中，ConcurrentHashMap 不再使用固定的段，而是根据实际数据和并发访问情况来动态地扩展和收缩哈希表的大小。</li>\n</ul>\n</li>\n<li><p>锁粒度</p>\n<ul>\n<li>jdk1.7：JDK 1.7 的 ConcurrentHashMap 使用分段锁，即每个段都有一个独立的锁来保护它的元素。这意味着不同的线程可以同时访问和修改不同的段，从而提高并发性能。</li>\n<li>jdk1.8： JDK 1.8 中，ConcurrentHashMap 引入了更细粒度的锁策略，即将锁的粒度缩小到每个桶（bucket）级别，也就是数组中的每个元素都有一个独立的锁。</li>\n</ul>\n</li>\n<li><p>锁策略(针对于 put 或者 remove 操作)</p>\n<ul>\n<li>jdk1.7：定位之后会采用自旋锁 + 锁膨胀的机制进行加锁，也就是自旋获取锁，当自旋次数超过 64 时，会发生膨胀，直接陷入阻塞状态，等待唤醒。并且在整个 put 操作期间都持有锁。</li>\n<li>jdk1.8: 采用 CAS+synchronized 的机制。如果对应下标处没有结点，说明没有发生哈希冲突，此时直接通过 CAS 进行插入，若成功，直接返回。若失败，则使用 synchronized 进行加锁插入。</li>\n</ul>\n</li>\n<li><p>和 HashMap 的区别</p>\n<ul>\n<li>ConcurrentHashMap 采用了分段锁技术来保证并发访问的线程安全性，在加锁的时候不必要锁住整个 Map</li>\n<li>ConcurrentHashMap 在扩容时只需要对 Segment 段进行扩容，而不需要对整个 Map 进行扩容，因此扩容的代价相对较小</li>\n<li>ConcurrentHashMap 对于读操作和写操作进行了分离，对于读操作没有加锁，可以实现读取的高并发性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>B 树和 B+ 树之间的区别</p>\n<ul>\n<li><p>B 树</p>\n<ul>\n<li>它是一种多路的平衡搜索树。</li>\n<li>它跟普通的平衡二叉树的不同是，B 树的每个节点可以存储多个数据，而且每个节点不止有两个子节点，最多可以有上千个子节点。</li>\n<li>B 树中每个节点都存放着索引和数据，数据遍布整个树结构，搜索可能在非叶子节点结束，最好的情况是 O(1)。</li>\n</ul>\n</li>\n<li><p>B+ 树</p>\n<ul>\n<li>B+ 树的层级更少：相较于 B 树 B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快。</li>\n<li>B+ 树查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比 B 树更稳定</li>\n<li>B+ 树区间查询更方便：B+ 树所有的叶子节点数据构成了一个双向链表，在查询大小区间的数据时候更方便，数据紧密性很高。</li>\n<li>B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历  所有的叶子节点即可，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>\n</ul>\n</li>\n<li><p>InnoDB 为什么选择 B+ 树</p>\n<ul>\n<li>扫库、扫表能力更强：如果我们要对表进行全表扫描，只需要遍历叶子节点就可以了，不需要遍历整棵 B+ 树</li>\n<li>数据连续可达：叶子节点上有下一个数据区的指针，数据形成了链表</li>\n<li>效率稳定：B+ 树永远是在叶子节点拿到数据，所以 IO 次数是稳定的，而 B 树运气好的话根节点就能拿到数据，运气不好就要到叶子节点才能拿到数据，所花费的时间会有差异。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>队列和堆栈</p>\n<ul>\n<li>队列<ul>\n<li>顺序：先入先出</li>\n<li>可在一端插入，另一端删除</li>\n<li>可基于地址指针，从头部或者尾部来遍历，且不需要开辟临时空间，遍历速度更快</li>\n<li>场景：任务调度、消息传递等场景</li>\n</ul>\n</li>\n<li>栈<ul>\n<li>顺序：后入先出</li>\n<li>插入和删除在同一端</li>\n<li>只能从顶部取数据，且需要开辟临时空间，如若要取栈底的元素，得先把所有元素给取出来一遍才行，遍历速度更慢</li>\n<li>场景：回溯、表达式求值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"计算机网络\"><a href=\"# 计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h3><ol>\n<li><p>TCP 和 UDP (传输层协议)</p>\n<ul>\n<li><p>比较</p>\n<ul>\n<li>可靠性：TCP 是一种面向连接的协议，提供可靠的数据传输。它使用确认、重传和流量控制等机制来确保数据的完整性和顺序。UDP 是一种无连接的协议，不提供可靠性保证，数据传输可能丢失、重复或乱序。</li>\n<li>连接过程：TCP 建立连接和断开连接的过程较为复杂，包括三次握手和四次挥手，确保通信双方建立可靠的连接。UDP 没有连接建立的过程，每个数据包都是独立的，可以直接发送。</li>\n<li>速度和效率：由于 TCP 提供可靠性保证和连接管理，它的开销较大，传输速度相对较慢。UDP 没有这些额外的开销，因此传输速度较快，效率较高。</li>\n<li>数据量限制：TCP 对数据包的大小有限制，因为 TCP 报文段的最大长度受到网络的最大传输单元（MTU）限制。UDP 没有这个限制，可以发送更大的数据包。</li>\n</ul>\n</li>\n<li><p>TCP 可靠性的保证</p>\n<ul>\n<li>确认机制：TCP 将每个发送的数据包进行编号（序列号），接收端通过发送确认消息来确认已经成功接收到的数据。如果发送端没有收到确认消息，就会重新发送数据。</li>\n<li>超时与重传：TCP 使用超时重传机制。如果发送端在合理的时间内没有收到确认消息，就会认为数据包丢失，触发重传机制，重新发送数据。</li>\n<li>流量控制：TCP 通过使用滑动窗口机制进行流量控制。接收端通过发送窗口大小的信息告知发送端自己的可接收数据量，以避免发送太多数据导致接收端无法处理。</li>\n</ul>\n</li>\n<li><p>TCP 粘包问题</p>\n<ul>\n<li>概念：当发送方在短时间内连续发送多个数据包时，接收方在接收数据时可能会将多个数据包合并成一个数据包，从而导致数据包大小超过了接收缓冲区的大小，这就是所谓的粘包问题。</li>\n<li>导致原因：由于数据包的边界不明确或者多个数据包连续发送导致接收端难以正确解析和处理数据</li>\n<li>解决方案：<ul>\n<li>采用特定的分隔符。发送方在发送数据包之前，在数据包中加入特定的分隔符，接收方在接收数据包时根据分隔符将数据包进行分割。</li>\n<li>采用消息头和消息体。发送方在发送数据包之前，在数据包中加入消息头和消息体，消息头用于标识消息体的长度和类型，接收方在接收数据包时根据消息头将数据包进行分割。</li>\n<li>定长包格式：可以使用定长的包格式，确保每个数据包都具有相同的长度。接收端按照固定长度进行解析，从而避免了粘包问题。但是这种方法可能会浪费一些空间，因为包中的数据长度不一定总是满载。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>http 与 https(应用层协议)</p>\n<ul>\n<li>http<ul>\n<li>概念：HTTP 代表超文本传输协议，它是用于在 Web 浏览器和 Web 服务器之间传输数据的协议。</li>\n<li>机制：HTTP 协议是明文传输数据的，这种明文传输数据的方式存在一定的风险，特别是在传输敏感信息时。</li>\n</ul>\n</li>\n<li>https<ul>\n<li>概念：HTTPS 代表安全超文本传输协议，它是 HTTP 协议的安全版本。</li>\n<li>机制：在 HTTPS 下，传输的数据是通过 SSL 或 TLS 加密的，这样攻击者即使截取到了数据，也无法轻易地解密和阅读其中的内容。HTTPS 还能够验证服务器的身份，确保用户正在与其信任的网站通信，而不是被攻击者伪装的恶意网站。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Http 状态码</p>\n<ul>\n<li>200 OK：请求成功。服务器成功处理了请求，并返回了请求的数据。</li>\n<li>301 Moved Permanently：永久重定向。请求的资源已被永久移动到新的 URL。</li>\n<li>302 Found：临时重定向。请求的资源已被临时移动到新的 URL。</li>\n<li>400 Bad Request：错误请求。服务器无法理解请求，因为请求中包含语法错误。</li>\n<li>401 Unauthorized：未授权。请求需要用户身份验证，但用户未提供有效的身份验证信息。</li>\n<li>403 Forbidden：禁止访问。服务器拒绝了请求，因为请求者没有访问资源的权限。</li>\n<li>404 Not Found：未找到。服务器无法找到请求的资源。</li>\n<li>500 Internal Server Error：服务器内部错误。服务器遇到了意外的情况，无法完成请求。 </li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>不同层级的协议</p>\n<ul>\n<li>物理层<ul>\n<li>RS-232：用于串行通信的标准接口协议</li>\n<li>USB</li>\n</ul>\n</li>\n<li>数据链路层<ul>\n<li>WIFI</li>\n<li>VLAN：虚拟局域网</li>\n<li>PPP 协议：点对点协议</li>\n<li>ARP 协议：地址解析协议，用于将 IP 地址映射到物理地址</li>\n</ul>\n</li>\n<li>网络层<ul>\n<li>IP 协议：用于在网络中传输数据包</li>\n<li>ICMP 协议：是一种面向无连接的协议，用于传输出错报告控制信息</li>\n</ul>\n</li>\n<li>传输层<ul>\n<li>TCP 协议：一种面向连接的、可靠的、基于字节流的传输层通信协议</li>\n<li>UDP 协议：是无连接的协议，通信双方在传输数据之前不需要建立连接，也不需要进行连接的释放。每个数据包都是独立的，不会建立持久性的连接。</li>\n<li>TLS 协议：在两个通信应用程序之间提供保密性和数据完整性</li>\n</ul>\n</li>\n<li>会话层<ul>\n<li>LDAP 协议：(轻型目录访问协议)、通过 IP 协议提供访问控制和维护分布式信息的目录信息</li>\n</ul>\n</li>\n<li>表示层<ul>\n<li>LPP 协议：轻量级会话协议、描述了在某些受限条件下提供基于 TCP/IP 网络的 OSI 应用程序服务器的流线支持的方法</li>\n</ul>\n</li>\n<li>应用层<ul>\n<li>HTTP 协议：超文本传输协议，规定 web 服务端和客户端的数据传输格式</li>\n<li>HTTPS 协议：超文本传输安全协议，是 HTTP 加上 TLS/SSL 协议构成的可加密传输的网络协议</li>\n<li>DNS 协议：域名解析协议、将域名解析为 IP 地址</li>\n<li>FTP 协议：文件传输协议、网络共享文件传输</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>输入 url 到响应的整个过程</p>\n<ul>\n<li>浏览器首先检查输入的 URL 的格式是否正确。一个完整的 URL 应包含协议部分（如 HTTP 或 HTTPS）、域名或 IP 地址、以及查询参数等组成部分。</li>\n<li>如果 URL 格式正确，浏览器会解析 URL 获取域名或 IP 地址。如果用户输入的是域名，浏览器会将其解析为对应的 IP 地址，这个过程通常通过 DNS 来完成。</li>\n<li>浏览器建立与服务器的网络连接。它首先通过向目标服务器的 IP 地址发送一个 TCP 连接请求来建立一个 TCP 连接。这个过程通常使用三次握手来确保连接的可靠性。</li>\n<li>一旦建立了 TCP 连接，浏览器会发送一个 HTTP 请求到服务器。</li>\n<li>服务器接收到浏览器发送的 HTTP 请求后，会根据请求的内容进行处理。</li>\n<li>服务器处理完请求后，会生成一个 HTTP 响应。</li>\n<li>服务器过建立的 TCP 连接进行传输, 将生成的 HTTP 响应发送回浏览器。</li>\n<li>浏览器接收到 HTTP 响应后，会根据响应的内容进行处理。</li>\n<li>浏览器将解析后的页面显示给用户，用户可以看到页面内容。</li>\n<li>在 HTTP/1 中，浏览器与服务器之间的默认行为是在每个请求 - 响应周期结束后关闭连接。在 HTTP/2 中，引入了多路复用的概念，允许在同一连接上同时发送多个请求和响应。这样，连接在一个页面加载完成后并不会立即关闭，而是继续保持打开状态，以供后续请求使用。如果在一段时间内没有请求或通信发生，TCP 连接就会超时并自动关闭。</li>\n</ul>\n</li>\n</ol>\n<ol start=\"6\">\n<li>http 连接和 tcp 连接的区别<ul>\n<li>http 是一种应用层协议，它在 Web 应用中使用，用于在客户端和服务器之间传输超文本数据，HTTP 连接是基于 TCP 连接的。HTTP 协议在 TCP 连接上定义了请求和响应的格式和规则，包括请求方法、请求头、响应状态码等。TCP 负责提供可靠的数据传输，而 HTTP 负责定义应用层的通信规则和数据格式。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"操作系统\"><a href=\"# 操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><ol>\n<li><p>进程和线程的区别</p>\n<ul>\n<li>根本区别：进程是操作系统进行 <strong> 资源分配 </strong> 的最小单元，线程是操作系统进行 <strong> 运算调度 </strong> 的最小单元。</li>\n<li>从属关系不同：进程中包含了线程，线程属于进程。</li>\n<li>开销不同：进程的创建、销毁和切换的开销都远大于线程。</li>\n<li>拥有资源不同：每个进程有自己的内存和资源，一个进程中的线程会共享这些内存和资源。</li>\n<li>CPU 利用率不同：进程的 CPU 利用率较低，因为上下文切换开销较大，而线程的 CPU 的利用率较高，上下文的切换速度快。</li>\n</ul>\n</li>\n<li><p>死锁产生原因及解决办法</p>\n<ul>\n<li>死锁指多个线程在执行过程中，因争夺资源造成的一种相互等待的僵局</li>\n<li>解决方案：<ul>\n<li>互斥条件：一个资源只能被一个线程占有，当这个资源被占用后其他线程就只能等待。</li>\n<li>不可剥夺条件：当一个线程不主动释放资源时，此资源一直被拥有线程占有。</li>\n<li>请求并持有条件：线程已经拥有一个资源后仍然不满足，又尝试请求新的资源。</li>\n<li>环路等待条件：产生死锁一定是发生了线程资源环路链。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线程之间通信的方式</p>\n<ul>\n<li>共享内存（Shared Memory）：多个线程可以通过访问相同的内存区域来进行通信。线程可以读取和写入共享内存中的数据来进行信息交换。由于多个线程同时访问共享内存，因此需要使用同步机制（如互斥锁）来保证数据的一致性和避免竞态条件。</li>\n<li>信号量（Semaphore）：信号量是一个计数器，用于控制多个线程对共享资源的访问。线程在访问共享资源之前需要获取信号量，如果信号量计数器大于零，则允许访问；如果计数器为零，则线程被阻塞，直到其他线程释放信号量。通过适当的计数器设置，可以控制线程的并发访问量。</li>\n<li>互斥锁（Mutex）：互斥锁用于保护共享资源，确保在同一时间只有一个线程可以访问共享资源。线程在访问共享资源之前需要获取互斥锁，如果锁已被其他线程获取，则线程被阻塞，直到锁被释放。互斥锁可以防止多个线程同时访问共享资源，从而避免数据的不一致性和竞态条件。</li>\n<li>管道（Pipe）：管道是一种单向的、有序的数据通信机制。它可以在父进程与子进程之间或者同一进程的不同线程之间进行通信。一个线程可以将数据写入管道的写端，而另一个线程可以从管道的读端读取数据。管道可以用于在线程之间传递数据或消息。</li>\n<li>消息队列（Message Queue）：消息队列是一种在多个线程之间传递消息的通信方式。线程可以将消息放入队列中，而其他线程可以从队列中获取消息。消息队列可以按照一定的优先级和顺序来处理消息，方便线程之间的协作和通信。</li>\n</ul>\n</li>\n<li><p>进程之间的调度策略</p>\n<ul>\n<li>先来先服务（FCFS）：按照任务到达的顺序，按照先后次序分配 CPU 时间片，即先到先服务。这种策略简单直观，但可能导致长作业优先，造成短作业等待时间过长。</li>\n<li>短作业优先（SJF）：根据任务的执行时间长度，优先分配执行时间短的作业。这种策略可以减少平均等待时间，但需要预先知道任务的执行时间，不适用于实时环境。</li>\n<li>优先级调度(剥夺策略)：为每个任务分配一个优先级，按照优先级高低分配 CPU 时间片。可以根据任务的重要性、紧急程度等来设置优先级。然而，这种策略可能导致优先级较低的任务长时间等待，出现饥饿问题。</li>\n<li>时间片轮转（Round Robin）：将 CPU 时间分成若干个时间片，每个任务轮流执行一个时间片。当一个时间片用完后，任务被挂起，等待下一个时间片再次执行。这种策略可以确保公平性，但可能导致上下文切换频繁。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"实习总结\"><a href=\"# 实习总结\" class=\"headerlink\" title=\"实习总结\"></a>实习总结</h1><ul>\n<li><p>项目的可持续集成：完整的项目是如何在团队开发下进行集成和发布的，体验了项目是从线下到预发，再到线上的这个过程</p>\n</li>\n<li><p>对大体量代码的阅读：项目都是基于分布式开发的，每个服务都有大量的代码，学会了如何读懂别人的代码并且将别人的写的代码变成自己的内在知识</p>\n</li>\n<li><p>对线上 bug 的排查：之前自己排自己的项目 bug 都是看看控制台打印的日志，打个本地断点就能找到，但是公司的项目都是跑在云上的，只能通过 jvm 远程 debug，要是基于同步的还好，有时候有些 bug 的问题出在异步上，或者开了一些定时任务，这些 bug 就不太好找，通常就需要去看服务的日志信息才能定位到</p>\n</li>\n<li><p>对高并发场景的了解：自己参与了公司的高并发项目的二次开发，对其中的一些设计和优化有了一些体会和自己的理解</p>\n</li>\n<li><p>开发代码的激情：感觉自己实习之后，特别是和同事一块相处，一块去思考一些问题，一块去解决问题，虽然这个过程可能有点累，解决完问题之后的那种成就感和痛快感，真的就让人感觉不到累</p>\n</li>\n</ul>\n<h1 id=\"项目积累\"><a href=\"# 项目积累\" class=\"headerlink\" title=\"项目积累\"></a>项目积累 </h1><h2 id=\"校疫通\"><a href=\"# 校疫通\" class=\"headerlink\" title=\"校疫通\"></a> 校疫通 </h2><h3 id=\"项目难点及解决方案\"><a href=\"# 项目难点及解决方案\" class=\"headerlink\" title=\"项目难点及解决方案\"></a> 项目难点及解决方案</h3><ul>\n<li><p>二级缓存的设置, 将它放在哪比较合适</p>\n<ul>\n<li>使用 Caffine + Redis 构建二级缓存，使用 SpringAOP 将其独立出来</li>\n<li>数据一致性的问题<ul>\n<li>性能开销：双写模式需要在写入数据时将数据同时写入两个缓存层，这将增加写入操作的延迟和开销，导致整体性能下降。</li>\n<li>缓存同步问题：双写模式要求两个缓存层保持同步，即在写入操作完成之前，两个缓存层都需要更新成功。这可能会引入额外的同步机制，增加系统复杂性和开销。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何优雅地使用 SpringSecurity 来实现用户的鉴权和认证</p>\n<ul>\n<li>采用 RBAC0 权限模型、将管理员用户、角色、权限、受保护的 URL 都放入到 MySQL 中并建立相应联系</li>\n<li>合理使用 SpringSecurity 的过滤链，使用数据源、管理器等资源实现系统的权限及认证管理</li>\n</ul>\n</li>\n<li><p>如何让前端更方便地测试</p>\n<ul>\n<li>Swagger 写接口文档</li>\n<li>部署到云服务器</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"项目板块\"><a href=\"# 项目板块\" class=\"headerlink\" title=\"项目板块\"></a>项目板块</h3><ul>\n<li>登录注册板块： 使用 SpringSecurity，通过实现 UserDeatilSertvice 组件来自定义自己的登录逻辑</li>\n<li>鉴权板块: 利用 SpringSecurity 的过滤链，合理使用其中的组件，包括动态权限管理器、包括数据元数据源，包括权限拦截器等</li>\n<li>CRUD 板块：其中包括车辆出入管理、核酸检测管理、疫苗管理等，主要就是直接使用的 MybatisPlus 封装好的方法，构造不同的 wrapper 来实现</li>\n<li>项目优化板块：<ul>\n<li>二级缓存模块：采用的双写模式，updateDB、updateRedis、updateCaffine，如果缓存更新失败，也有补偿机制：重试（在需要进行重试的方法上添加 @Retryable 注解，可指定了最大重试次数，和重试的间隔时间）</li>\n<li>全局异常处理模块</li>\n<li>接口测试模块</li>\n<li>日志模块<ul>\n<li>每个人对日志的操作都会记录在我们的 mysql 里，有一张日志表</li>\n<li>日志表字段：主键、操作人、操作模块、操作时间、sessionId、客户端 Id、服务端 Id、服务器端口、请求 URL 等</li>\n<li>日志归档：使用定时任务，每个礼拜都将日志进行归档，以文件的形式保存在计算机中，然后清空日志表</li>\n<li>分批处理：每次生成的文件最多有 5000 条记录，如果数据量过大则分多次读取，然后用 BufferWriter 以文件的形式保存日志，缓冲区默认是 8kb，足够写入 5000 条记录了，因为每条记录差不多 100 个字符</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"话费充值系统\"><a href=\"# 话费充值系统\" class=\"headerlink\" title=\"话费充值系统\"></a>话费充值系统 </h2><h3 id=\"架构图\"><a href=\"# 架构图\" class=\"headerlink\" title=\"架构图\"></a> 架构图</h3><img src = \"http://xtzl.wentexl.cn/%E8%AF%9D%E8%B4%B9%E5%85%85%E5%80%BC%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.png\"/>\n\n<h3 id=\"项目难点\"><a href=\"# 项目难点\" class=\"headerlink\" title=\"项目难点\"></a>项目难点 </h3><h4 id=\"项目简述\"><a href=\"# 项目简述\" class=\"headerlink\" title=\"项目简述\"></a> 项目简述</h4><ul>\n<li>流程简述：整个系统是由两大系统组成，一个系统是推单系统，主要负责接收订单、一个系统是配单系统，主要负责处理订单，最开始的流程是这样的：pdd 商户将订单推送到推单系统中，推单系统落库之后将订单推送给配单服务，而配单服务会去调用运营商代理提供的第三方接口来获取一个支付凭证，并将这个凭证传给下游，下游拿到这个凭证之后将回调配单系统，然后配单系统重新回调推单系统， 推单系统又会回调 pdd 商户，但是整个流程都基于同步实现的。</li>\n</ul>\n<h4 id=\"项目并发问题\"><a href=\"# 项目并发问题\" class=\"headerlink\" title=\"项目并发问题\"></a>项目并发问题</h4><ul>\n<li>问题描述：最初整个系统都是同步调用的，如果说由于网络抖动等原因，就可能导致大量线程被阻塞，从而不断滚雪球，导致服务崩溃。而且如果一旦请求出了问题，难以定位到问题所在的地方。</li>\n<li>问题解决方案：拆异步，搞批量</li>\n</ul>\n<p><strong>1. OOM 问题</strong></p>\n<ul>\n<li>问题描述：在配单系统与运营商代理这块，前期是基于同步调用的，如果发生的网络抖动，哪怕是一两分钟，就可能造成成百上千的线程阻塞，jvm 不断的新建线程，就像滚雪球一样，从而导致内存溢出的问题</li>\n<li>解决方案：拆一个推送服务出来，异步调用第三方系统的接口<ul>\n<li>具体实施：配单系统将订单信息推送到 Redis 中去，然后推送服务会开启定时任务，我们设置的是 1s，也就是说每秒钟都会去拉取我们 redis 中的订单信息，并批量地向第三方系统发起请求调用，获取支付凭证，并将获取到的支付凭证都统一存回 redis 中，以便于下游调用</li>\n</ul>\n</li>\n</ul>\n<p><strong>2. 解决死锁问题</strong></p>\n<ul>\n<li>问题描述：当配单系统回调推单系统的时候，推单系统会做两件事，第一件事是通知上游，第二件事是修改配单系统的回调状态，那就有可能存在，在通知上游成功之后，我们去 redis 里拉回订单的时候，不是我们推过去 的顺序，就可能导致死锁问题的发生</li>\n<li>解决方案：将 redis 换成消息中间件，保证消息一定是按顺序消费的</li>\n</ul>\n<p><strong>3. token 重复刷新问题</strong></p>\n<ul>\n<li>问题描述: 我们去调用运营商接口的时候是有一个密钥 token 的，这个 token 是有过期时间的，过期时间是半个小时，过了这个过期时间之后就需要刷新一次，但是如果在过期之后同时有多个请求到达，则会造成不必要的刷新次数</li>\n<li>解决方案：使用 redis 锁控制只有一个请求去刷新，加锁也需要设置其他线程最多等待的时间，并且在控制的时候需要加个时间的判断，又担心如果只有一个线程去刷新，可能意外没有刷新成功，所以我们所有的请求都会自旋三次来获取这个锁</li>\n</ul>\n<p><strong>4. Redis 的存储结构</strong></p>\n<ul>\n<li>问题描述：从推单系统到配单系统的 redis 是 set 结构，放置推重复的订单。从配单系统到下游的 redis 是 list 结构，主要是因为支付凭证是有时间限制的，3min 之后将会过期，如果支付凭证都存在 list 中，供下游一条一条地拉取处理，如果说下游处理能力不够强，或者出现了性能方面的问题，则为了尽可能的保证 list 中的支付凭证能被及时处理，我们将处理最晚入 list 的，也就是有效时间最长的那个</li>\n</ul>\n","url":"/posts/41865/","min2read":93,"word4post":"26.9k","prev_post":{"title":"","url":"/posts/0/"},"next_post":{"title":"BigData-HBase","url":"/posts/10071/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"Java 八股文\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">Java 八股文</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"Java 及 Web 基础\" href = \"#\"><span class=\"toc-number\">1.1.</span> <span class=\"toc-text\">Java 及 Web 基础</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"Spring 全家桶框架\" href = \"#\"><span class=\"toc-number\">1.2.</span> <span class=\"toc-text\">Spring 全家桶框架</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"JUC\" href = \"#\"><span class=\"toc-number\">1.3.</span> <span class=\"toc-text\">JUC</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"JVM\" href = \"#\"><span class=\"toc-number\">1.4.</span> <span class=\"toc-text\">JVM</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"JMM\" href = \"#\"><span class=\"toc-number\">1.5.</span> <span class=\"toc-text\">JMM</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"数据库\" href = \"#\"><span class=\"toc-number\">1.6.</span> <span class=\"toc-text\">数据库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"MySQL\" href = \"#\"><span class=\"toc-number\">1.6.1.</span> <span class=\"toc-text\">MySQL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"Redis\" href = \"#\"><span class=\"toc-number\">1.6.2.</span> <span class=\"toc-text\">Redis</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"MQ\" href = \"#\"><span class=\"toc-number\">1.7.</span> <span class=\"toc-text\">MQ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"RabbitMQ\" href = \"#\"><span class=\"toc-number\">1.7.1.</span> <span class=\"toc-text\">RabbitMQ</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"Kafka\" href = \"#\"><span class=\"toc-number\">1.7.2.</span> <span class=\"toc-text\">Kafka</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"基础学科\" href = \"#\"><span class=\"toc-number\">1.8.</span> <span class=\"toc-text\">基础学科 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"数据结构\" href = \"#\"><span class=\"toc-number\">1.8.1.</span> <span class=\"toc-text\"> 数据结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"计算机网络\" href = \"#\"><span class=\"toc-number\">1.8.2.</span> <span class=\"toc-text\">计算机网络</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"操作系统\" href = \"#\"><span class=\"toc-number\">1.8.3.</span> <span class=\"toc-text\">操作系统</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"实习总结\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">实习总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"项目积累\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\">项目积累 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"校疫通\" href = \"#\"><span class=\"toc-number\">3.1.</span> <span class=\"toc-text\"> 校疫通 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"项目难点及解决方案\" href = \"#\"><span class=\"toc-number\">3.1.1.</span> <span class=\"toc-text\"> 项目难点及解决方案</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"项目板块\" href = \"#\"><span class=\"toc-number\">3.1.2.</span> <span class=\"toc-text\">项目板块</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"话费充值系统\" href = \"#\"><span class=\"toc-number\">3.2.</span> <span class=\"toc-text\">话费充值系统 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"架构图\" href = \"#\"><span class=\"toc-number\">3.2.1.</span> <span class=\"toc-text\"> 架构图</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"项目难点\" href = \"#\"><span class=\"toc-number\">3.2.2.</span> <span class=\"toc-text\">项目难点 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"项目简述\" href = \"#\"><span class=\"toc-number\">3.2.2.1.</span> <span class=\"toc-text\"> 项目简述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"项目并发问题\" href = \"#\"><span class=\"toc-number\">3.2.2.2.</span> <span class=\"toc-text\">项目并发问题</span></a></li></ol></li></ol></li></ol></li></ol>","categories":[{"name":"Interview","path":"api/categories/Interview.json","url":"/categories/Interview/"}],"tags":[]}