[{"title":"","url":"/posts/0/","content":"function getMaxValue(str, k) {\n  let n = str.length;\n  let dp = new Array(n + 1).fill(0).map(() => new Array(k + 1).fill(Infinity));\n\n  dp[0][0] = 0;\n\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= k; j++) {\n      for (let p = i - 1; p >= 0; p--) {\n        let subStr = str.substring(p, i);\n        let uniqueChars = new Set(subStr);\n        let value = subStr.length * uniqueChars.size;\n        dp[i][j] = Math.min(dp[i][j], Math.max(dp[p][j - 1], value));\n      }\n    }\n  }\n  return dp[n][k];\n}\n","categories":[],"tags":[]},{"title":"Interview-MeiTuan","url":"/posts/41865/","content":">关于美团的面试，及其面经积累\n<!--more-->\n# Java八股文\n## Java及Web基础\n1. 元空间: Java 8中引入了元空间的概念，将类元数据存储在本地内存中，而不再是永久代。这种方式使得类元数据的管理更加灵活和高效，可以避免永久代出现的问题，如内存溢出、GC时间过长等。\n\n2. Get、Post、Put的区别\n    - 数据位置：GET方法将请求参数附加在URL的查询字符串中，而POST方法将请求参数放在请求的消息体中。由于URL长度的限制，GET方法的参数传输通常会受到一定的限制。\n    - 安全性：由于GET方法将请求参数暴露在URL中，因此请求的安全性较低，容易被攻击者截获和窃取。而POST方法将请求参数放在消息体中，相对来说更为安全。\n    - 可缓存性：GET方法通常可以被缓存，因为它的请求参数以及URL是不变的。而POST方法的请求参数会影响服务器的状态，不能被缓存。\n    - 幂等性：GET方法是幂等的，即多次请求同一个URL的结果相同，不会对服务器状态产生影响。而POST方法通常不是幂等的，多次请求同一个URL可能会导致服务器状态的改变。\n    - 用途：GET方法主要用于获取资源，POST方法主要用于提交数据。例如，用GET方法可以请求一个HTML页面或图像文件，用POST方法可以提交一个表单。\n    - PUT请求：\n        - 如果服务器上已经存在了一个资源，并且客户端发送了一个PUT请求，那么服务器将用客户端上传的新资源替换原有的资源。如果服务器上不存在该资源，则会创建一个新的资源。\n        - PUT请求通常需要在请求头中指定上传的资源的URI和一些元数据，以便服务器正确处理请求。\n        - 与POST请求不同，PUT请求的请求体中通常包含完整的资源内容，而不是仅包含部分数据或请求参数。\n        - PUT请求可能会导致服务器上的数据被覆盖或删除，因此在使用PUT请求时需要谨慎处理，避免意外修改或删除重要数据。\n    \n3. Cookie和Session的区别\n    - 存储位置：Cookie是保存在客户端浏览器中的，而Session是保存在服务器端的。\n    - 安全性：Cookie中的数据可以被客户端浏览器拦截并篡改，因此不适合保存敏感数据，而Session保存在服务器端，可以保证数据的安全性。\n    - 存储容量：Cookie存储容量比较小，通常只能存储几KB的数据，而Session存储容量较大，可以存储几MB的数据。\n    - 生命周期：Cookie有一个过期时间，如果没有设置过期时间，则默认为浏览器关闭时失效，而Session的生命周期由服务器管理，默认情况下，Session在30分钟内无任何操作时会失效。\n\n4. 动态代理\n    - jdk动态代理 : 适用于代理那些实现了接口的类， 使用Java自带的反射机制\n    - cglib动态代理: 适用于代理未实现接口的类, 动态代理的效率较低，但具有广泛的适用范围，使用的第三方库ASM的字节码生成技术\n    - 客户端访问的是代理对象，代理对象负责将调用请求委托给目标对象并应用横切关注点\n\n5. 面向对象和面向过程\n    - 面向对象(Java): 将现实世界中的事物抽象成一个个对象，对象包括属性和方法。对象的属性用来描述对象的状态，方法用来描述对象的行为。在面向对象编程中，程序员将不同的对象进行组合，形成一个完整的系统。\n    - 面向过程(C语言): 是一种基于函数的编程方法，将一个大问题分解为一系列小问题，每个小问题都可以使用一个函数来解决。在面向过程编程中，程序员关注的是程序中的函数，函数之间通过参数传递数据，函数中的变量也只在函数内部有效。\n\n\n\n\n\n\n## Spring全家桶框架\n1. SpringIOC和SpringAOP的原理\n    - IOC\n        - DI依赖注入: 通过构造函数、属性或方法参数等方式，将一个对象所依赖的其他对象传递给它，而不是由这个对象自己去创建或查找依赖的对象。这样做的好处是，我们可以更灵活地管理和替换这些依赖\n        - IC控制反转: 控制反转的核心思想是将对象的创建和管理交给容器或框架，而不是由程序员自己手动创建和管理对象。这样做的好处是可以将对象的生命周期和作用域管理交给框架或容器，从而避免了一些常见的问题，比如对象的重复创建、对象的生命周期管理等等。\n    - AOP\n        - 面向切面的技术：所谓“切面”，简单说就是那些与业务无关，却被业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。\n\n2. Spring的三级缓存\n    - 一级缓存：存放已经创建完成的Bean\n    - 二级缓存：存放早起创建但是未填充属性的Bean\n    - 三级缓存：存放ObjectFactory这样的Bean的工厂对象，负责动态的创建和管理Bean\n    - 主要通过三级缓存可解决循环依赖、Bean的重复创建等问题\n\n3. Spring占位符\n    - '#' : #占位符会对输入的参数值进行类型转换，防止SQL注入攻击。\n    - '$' : $占位符在SQL语句中直接替换成输入的参数值，它不会对输入的参数值进行类型转换，也不会防止SQL注入攻击\n\n4. RPC框架\n    - SpringCloud\n        - 注册中心: Ereuka、Zookeeper、Nacos、Consul\n        - 服务调用: restTemplate、OpenFeign\n        - 服务降级：Hystrix、Sentinel\n        - 服务配置：Nacos、Config\n        - 服务网关：GateWay\n        - 服务总线：Bus、Nacos\n    - Hadoop\n        - HDFS\n        - MapReduce\n    - Spark\n        - 执行流程：\n            1. 根据RDD依赖关系 -> DAG流程图 ---(DAGScheduler)--> Stage ----(TaskScheduler)--> tasks\n            2. Executor  ---(申请任务)--> SparkContext、 任务调度器 ----(分发任务)---> Executor\n\n5. 设计模式\n    - 工厂模式（Factory Pattern）：Spring中使用工厂模式来实现对象的创建和管理，例如BeanFactory和ApplicationContext就是工厂模式的典型实现。\n    - 代理模式（Proxy Pattern）：Spring中使用代理模式来实现AOP，通过动态代理技术在不改变原有类结构的前提下，对类的方法进行增强或切面操作。\n    - 观察者模式（Observer Pattern）：Spring中使用观察者模式来实现事件监听器的功能，例如ApplicationListener接口就是观察者模式的实现。\n    - 模板模式（Template Pattern）：Spring中使用模板模式来实现JdbcTemplate等模板类，将通用的数据访问逻辑封装在模板类中，提高了代码复用性和可维护性。\n    - 单例模式（Singleton Pattern）：Spring中大量使用了单例模式，确保在整个应用中只有一个实例对象被创建和共享，提高了应用的性能和效率。\n    - 适配器模式（Adapter Pattern）：Spring中使用适配器模式来适配各种数据源，例如JDBC适配器可以将不同厂商的JDBC驱动进行统一适配。\n\n\n## JUC\n1. Synchronized \n    - 原理:synchronized是Java中用于实现同步的关键字，它可以应用于方法或代码块中。其主要原理是通过对一个对象或类进行加锁来保证多个线程之间的互斥访问。当一个线程获取了锁，其他线程就必须等待锁被释放后才能进入被锁定的代码块。 \n    - 锁升级\n        - 偏向锁：线程A第一次竞争到资源，加的是偏向锁,MarkWord存的是偏向线程ID，之后只需检查是否是偏向线程访问即可，效率最高。\n        - 轻量级锁：线程B来和线程A竞争资源且竞争成功，则偏向锁切换偏向线程，竞争失败，则偏向锁升级为轻量级锁,轻量级锁本质就是自旋锁CAS\n        - 重量级锁：大量线程参与竞争或CAS多次自旋未成功，升级为重量级锁，效率最低\n    - 区别于ReentrantLock:\n        - ReentrantLock显示地获得、释放锁，synchronized隐式获得、释放锁\n        - ReentrantLock可响应中断，可轮回，synchronized是不可以响应中断的\n        - ReentrantLock可以实现公平锁\n        - ReentrantLock通过Condition可以绑定多个条件\n        - Lock是一个接口，而synchronized是java中的关键字，synchronized是内置的语言实现\n        - synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。\n        - 底层实现不一样，synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略。\n\n2. 线程池\n    - 七大参数\n        - 核心线程数 corePoolSize \n        - 最大线程数 maximumPoolSize   \n        - 空闲线程的存活时间 keepAliveTime \n        - 存活时间单位 TimeUnit\n        - 阻塞队列 workQueue \n        - 线程工厂 threadFactory \n        - 拒绝策略 handler\n            - 抛出异常\n            - 任务调回\n            - 丢弃任务\n            - 与最老任务竞争\n    - 参数设置\n        - I/O通常是对数据库的操作,线程数如果不多的话，在处理IO的时候不能用CPU，导致CPU的使用率较低。\n        - CPU密集型：\n            - 核心线程 = CPU核心\n            - 最大线程 = CPU核心 + 1\n        - IO密集型\n            - 核心线程 = 2*CPU核心\n            - 最大线程 = 2*CPU核心 + 1\n    - 运行流程\n        - 任务提交给线程池，先判断核心线程数是否已满，如果满了再判断阻塞队列是否已满，如果没满则进入阻塞队列，如果阻塞队列满了则执行拒绝策略 \n\n3. volatile\n    - 概念：volatile 关键字用于标记变量，指示编译器和运行时系统每次访问该变量时都必须从内存中读取值，而不是使用缓存的值。在多线程编程中\n    - 作用：使用 volatile 可以保证可见性和禁止指令重排，从而保证线程安全。\n    - 补充解释：具体来说，当一个线程修改 volatile 变量的值时，其他线程将立即看到该变量的新值，因为该值是从内存中读取的。此外，由于 volatile 变量不能被缓存，因此在对该变量进行读取和写入操作时，不会发生指令重排，从而避免了线程安全问题。需要注意的是，volatile 仅保证单个操作的原子性，而不是多个操作的原子性。如果需要保证多个操作的原子性，应该使用其他机制，如锁、原子操作等。\n\n4. 线程的创建方式\n    - 继承Thread类并重写run()方法\n    - 实现Runnable接口或者Callable接口\n    - 使用线程池创建接口\n    \n5. CAS可能出现的问题\n    - ABA问题：CAS操作在进行比较时，只会比较原值和期望值是否相等，但是在并发环境下，可能会存在A->B->A的情况，这时候CAS就无法检测出这种情况，导致并发安全问题。\n    - 自旋开销：在使用CAS进行无锁编程时，由于CAS是一个自旋操作，需要不断地进行尝试和比较，从而可能会带来一定的CPU开销和性能损失。\n    - 公平性：CAS操作无法像锁机制一样保证公平性，可能会导致一些线程一直无法获取资源。\n\n6. 线程的同步方式\n    - synchronized: 采用互斥锁的方式来实现同步，当一个线程进入同步方法时，它会自动获取该方法所属对象的锁，其他线程需要等待该线程释放锁后才能进入该方法。\n    - ReentrantLock: 是一个可重入的互斥锁，与 synchronized 相比，ReentrantLock 提供了更灵活的锁定机制和更多的功能，如可实现公平锁、可用condition绑定很多条件等。\n    - Semaphore: 是一种计数信号量，用于控制对共享资源的访问。类似线程池的思想\n    - CountDownLatch: 多个线程并行执行完之后统计执行主线程\n    - CyclicBarrier: 多线线程并行执行完之后单开一个线程去执行\n\n7. 零拷贝\n    - 概念: 是指在数据传输过程中，数据在不经过中间缓存（如用户态缓存）的情况下，直接从发送端复制到接收端，避免了数据在内存之间的多次复制，从而提高了数据传输的效率。\n\n8. ThreadLocal\n    - \n\n## JVM\n1. 垃圾回收算法\n    - 标记清除算法: 这是一种最基本的垃圾回收算法。它的核心思想是先标记所有可达对象，然后清除所有未被标记的对象。标记和清除分别需要扫描整个堆，效率较低，同时可能会产生内存碎片。\n    - 标记整理算法: 这种算法在标记阶段与标记-清除算法类似，但在清除阶段不是简单地删除未被标记的对象，而是将所有存活对象都向一端移动，然后将另一端的空间全部释放，从而避免了内存碎片的问题。\n    - 复制算法: 这种算法将堆分为两个区域，每次只使用其中的一部分。当当前区域用完后，将存活对象复制到另一个区域中，然后将当前区域中的所有对象清除。复制算法的特点是效率高，但需要两倍的空间。\n    - 分代算法: 这种算法认为对象的生命周期具有不同的阶段，将堆分为多个代，一般将新生代和老年代分开处理。新生代中的对象生命周期较短，采用复制算法；老年代中的对象生命周期较长，采用标记-整理算法。分代算法充分利用了对象的生命周期分布规律，提高了垃圾回收效率。\n\n2. 垃圾回收器\n    - CMS收集器：是一种基于标记-清除算法的垃圾回收器，该收集器采用并发收集算法，具有低延迟、高并发等特点。\n    - G1收集器: 是一种基于标记-整理算法的垃圾回收器，将堆空间分成多个区域，每个区域独立进行垃圾回收,采用分代收集算法，具有高效、低延迟、可预测等特点。\n    - 可作为GCROOT对象\n        - 长期存活的对象：比如线程池、I/O 等系统资源对象，它们通常需要在整个应用生命周期中持续存在。\n        - 静态变量和常量：静态变量和常量是在类加载时被初始化的，它们的生命周期通常很长。\n\n3. 新生代晋升到老年代的策略\n    - 对象年龄阈值策略:JVM中每个对象都有一个年龄计数器，当一个对象在新生代中经历了一定数量的垃圾收集后仍然存活，它的年龄计数器就会增加1。当一个对象的年龄超过一定阈值时，它就会被晋升到老年代中。可以通过调整年龄阈值来控制对象晋升的速度。\n    - 空间不足：如果新生代的可用空间不足以存放新的对象，JVM会先尝试触发一次垃圾回收，如果回收后仍然无法获得足够的空间，JVM就会尝试将部分存活的对象直接晋升到老年代中，以腾出新生代的空间。\n\n\n4. 内存模型\n    - 堆 (线程共享): 存储对象实例、为对象分配内存空间、GC主要作用区域\n    - 方法区(线程共享): 存储类的元数据信息，如类名、方法名、字段名等。方法区还用于存储运行时常量池、静态变量、即时编译器编译后的代码等信息。\n    - Java虚拟机栈: 用于存放 Java 方法执行时的栈帧。每个栈帧包含局部变量表、动态链接、返回地址等信息。当线程调用 Java 方法时，JVM 会在 Java 虚拟机栈中为该方法分配一个栈帧，在方法返回时，该栈帧会被弹出并销毁。\n    - 本地方法栈: 本地方法栈和 Java 虚拟机栈类似，用于存储本地方法(其他语言编写的)的栈帧。\n    - 程序计数器: 用于指示 JVM 正在执行哪个线程的字节码指令\n\n    - 堆的分区\n        - 新生代(1/3) : Eden(8/10) 幸存区1(1/10) 幸存区2(1/10)  [通常采用复制算法]\n        - 老年代(2/3) : 存放存活时间较长的对象，这些对象可能是长时间存活的业务数据、缓存对象、连接池等 [通常采用标记整理算法]\n    \n\n5. Java的常量池、字符串池、对象池\n    - 常量池：Java中的常量池是一种特殊的存储区域，用于存储编译期间确定的常量。常量池分为两种类型，一种是类常量池，用于存储类中的常量，另一种是运行时常量池，用于存储每个线程的常量。常量池中存储的常量包括基本类型、字符串、类、方法和字段等。\n    - 字符串池：Java中的字符串池是用于存储字符串的缓存区域，它可以避免重复创建相同字符串对象。字符串池可以通过String类的intern()方法来访问，当调用intern()方法时，如果字符串池中已经存在相同的字符串，则返回已存在的字符串对象，否则将该字符串对象添加到字符串池中，并返回该字符串对象的引用。\n    - 对象池：Java中的对象池是一种重复使用对象的机制，它可以减少对象创建和销毁的开销，提高程序的性能。对象池通常用于创建、缓存和重复使用频繁创建和销毁的对象，如线程池、连接池和对象缓存池等。\n    - 总结： 总的来说，常量池、字符串池和对象池都是Java虚拟机中的重要概念，它们都是为了提高Java程序的性能和节省内存而设计的。常量池用于存储常量，字符串池用于缓存字符串对象，对象池用于重复使用对象，以减少创建和销毁对象的开销。\n\n6. 如何减少Full GC\n    - 尽量少创建一些临时对象\n    - 增加堆的大小\n    - 使用对象池,提高对象的利用率\n\n\n\n## 数据库\n### MySQL\n1. 四大特性(ACID)\n    - 原子性 ： 每个操作不可再分\n    - 一致性 ： 一个事务可以让数据从一种一致状态切换到另一种一致性状态\n    - 隔离性 ： 事务并行执行互不影响，最后结果和串行执行的结果相同\n    - 持久性 : 一个事务一旦被提交，在数据库中的改变就是永久的，提交后就不能再回滚\n\n2. 三大问题\n    - 脏读：读到了未提交的数据\n    - 不可重复读：同一个事务两次读到的数据值不同\n    - 幻读：同一个事务两次读到的数据记录数量不同\n\n3. 隔离级别\n    - READ UNCOMMITTED: 读未提交\n    - READ COMMITTED: 读已提交\n    - REPEATABLE READ: 可重复读\n    - SERIALIZABLE: 可串行化\n\n4. SQL执行顺序\n    - from -> where -> group by -> having -> select -> order by -> limit\n\n5. 事务的传播行为\n\n6. MVCC原理\n    - 作用:\n        - 解决脏读、不可重复读的事务读写问题\n        - 在保证隔离性的基础上，提升了读取效率和并发性\n    - 描述：在执行 Update 和 Delete 操作的时候，会将每次操作记录记录在 UndoLog 中, 每条记录都有唯一的事务ID,而ReadView记录了数据版本链的一些统计值，包括活跃事务集，当前事务ID等，然后通过四步判断法进行判断，遍历整个版本链，最终得到一个符合所有要求的数据版本。\n    - 四步判断法：第一步主要判断是否是同一个读取的当前事务修改的数据，第二三步是判断是否是读到的未来的数据，第四步是判断是否是读的已提交的数据\n    - 作用解释：因为保证了读到的都是已提交的数据，所以避免了脏读，因为同一个事务使用的都是同一个Readview，所以保证同一个事务匹配到的是同一个版本的数据，所以避免了不可重复读的问题。\n7. 日志Log\n    - bin log（二进制日志）：记录所有对MySQL数据库的更改操作，例如INSERT、UPDATE、DELETE等，以二进制格式存储。binlog文件可以用于数据备份和恢复，数据复制和数据同步。\n    - undo log（回滚日志）：在事务中，如果执行了UPDATE或DELETE操作，MySQL会先将修改前的数据记录到undo log中，然后再对数据进行修改。如果事务回滚，则MySQL可以使用undo log来撤销已经进行的修改。\n    - redo log（重做日志）：在事务中，MySQL会先将对数据的修改记录到redo log中，然后再进行实际的修改。如果MySQL在执行修改操作后崩溃，MySQL可以使用redo log来恢复数据。\n\n8. MySQL慢查询\n    - 概念：慢查询是指执行时间较长、响应时间较慢的SQL查询语句。通常来说，如果一条SQL查询语句的执行时间超过了一定的阈值（例如几秒钟），就可以将其视为慢查询。\n    - 定位：可以使用MySQL的慢查询日志文件\n    - 影响：它们可能会导致服务器资源的过度占用，影响系统的响应速度和稳定性。\n    - 解决方案\n        - 使用索引：确保表的索引能够覆盖查询的列，这将使MySQL能够快速找到需要的数据。\n        - 优化查询语句：使用合适的查询语句可以提高性能。使用JOIN时，应该尽可能使用INNER JOIN而不是LEFT JOIN或RIGHT JOIN，因为后者可能会导致较慢的查询速度。\n        - 优化表结构：可以改善查询性能。例如，避免使用过多的JOIN，使用正确的数据类型，避免使用过多的NULL值等等。\n\n9. 聚簇索引和非聚簇索引\n    - 区别：\n        - 物理存储方式不同: 前者的数据存在同一块物理存储区域，后者是建立索引值与行记录映射关系，有点像顺序存储和链式存储\n        - 适用范围不同: 聚簇索引适合于频繁查询范围较小的数据、后者适用于频繁查询单个或少量的记录,因为每个索引条目只需要查询一次就可以找到相应的行记录。\n        - 字段数量不同: 每张表前者只能有一个，后者可以有多个\n\n10. MySQL索引\n    - 如何判断MySQL中的索引有没有生效: 在select语句前面加上explain就可以了\n    - 主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值\n    - 唯一索引：唯一索引不能有相同值，但允许为空\n    - 普通索引：允许出现重复值\n    - 组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则\n    - 全文索引：通过建立倒排索引提升检索效率，广泛用于搜索引擎\n\n\n11. MySQL索引的应用场景\n- 适合：\n    - 频繁作为查询的字段\n    - 查询作为和其他表关联的字段\n    - 查询中常作为排序条件的字段\n- 不适合：\n    - 频繁更新的字段\n    - 表的记录不多的字段\n    - 数据重复且分布平均的字段\n\n12. MySQL索引失效场景\n    - or 的左右两边不全是索引字段\n    - %开头的模糊查询\n    - 违背最左匹配原则\n    - 索引列参与计算\n    - 索引列发生类型转换的时候\n    - order by的字段未能出现在where条件中\n\n13. MySQL的基本数据类型\n    - 整型（xxxint）\n    - 位类型(bit)\n    - 浮点型（float和double、real）\n    - 日期时间类型（date,time,datetime,year）\n    - 字符串（char,varchar,xxxtext）\n    - 二进制数据（xxxBlob、xxbinary）\n    - 定点数（decimal,numeric）\n    - 枚举（enum）\n    - 集合（set）\n\n14. MySQL回表\n    - 概念：一般是对于非主键索引而言的,查询完得到的结果是主键索引的值，然后不但要遍历非主键索引的B+树，还要重新遍历一遍主键索引的B+树，叫做回表\n    - 解决：可以通过覆盖索引的方式解决，即索引的字段中已经包含了需要查询的字段\n\n15. MySQL锁\n    - 共享锁: 共享锁允许多个事务同时读取同一资源，但是不能进行修改操作。这个语句会给查询的结果集上共享锁，其他事务可以读取这个结果集，但是不能进行修改操作，直到释放锁为止。\n        - ```sql SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE; ```\n    - 排他锁: 排他锁是最高级别的锁，它禁止其他事务对资源的任何读取和写入操作，只有当前事务可以对资源进行读取和写入操作。\n        - ```sql SELECT * FROM table_name WHERE ... FOR UPDATE; ```\n\n\n\n### Redis\n1. 缓存故障\n    - 缓存穿透\n        - 概念：是用户访问的数据既不在缓存当中，也不在数据库中。当高并发或有人利用不存在的Key频繁攻击时，数据库的压力骤增，甚至崩溃，这就是缓存穿透问题。\n        - 解决方法：可以通过布隆过滤器等方式，在缓存中添加一个不存在的数据时，先判断其是否存在于布隆过滤器中，如果不存在则直接返回，避免大量的请求直接访问数据库。\n    - 缓存击穿\n        - 概念：指一个存在的 key，在缓存过期的一刻，同时有大量的请求访问这个 key，由于缓存失效，请求会穿透缓存直接访问数据库，造成数据库压力过大。\n        - 解决方案：可以采用永不过期的方式或者在缓存中添加短暂的二级缓存等方式来解决缓存击穿问题。\n    - 缓存雪崩\n        - 概念：指缓存中的大量数据同时过期失效，导致大量请求直接访问数据库，造成数据库压力过大。\n        - 解决方案：可采用数据预热，提前将缓存数据加载到缓存中，还可以设置多级缓存,还可采用使用分布式锁控制只有一个请求来重新加载缓存数据，避免缓存雪崩。\n\n\n2. 数据库缓存一致性\n    - 双写模式: 通常使用的是“先更新数据库，立马更新缓存”的顺序，以确保数据一致性。如果更新缓存失败，可以将缓存标记为失效，让下一次查询时重新从数据库中获取数据。(每次写入都要写入两个地方，可能造成更新操作变慢)\n    - 延时双删：在更新数据库时，先将缓存中的数据标记为无效，然后等待一定时间后再删除缓存数据。(一定时候后才更新缓存，让数据库读写操作更快一点)\n\n\n3. Redis的持久化策略\n    - RDB持久化 : Redis会周期性地将内存中的数据集快照写入磁盘，即生成一个RDB文件，可能会丢失最后一次快照以后的所有修改。\n    - AOF持久化 : Redis会将执行的每个写命令都记录到一个追加的文件中，在Redis重启时，会重新执行AOF文件中的所有写命令，以便恢复原始数据集，但会导致更高的磁盘空间占用和更慢的写入性能。\n\n4. Redis的数据类型\n    - 字符串类型（string）：用于存储单个值，例如整数、浮点数、字符串等。\n    - 列表类型（list）：用于存储一系列有序的值，可以从两端插入或删除元素，支持列表的查找和修剪。\n    - 哈希类型（hash）：用于存储一些字段和值的映射，例如存储用户信息时，可以使用哈希类型存储用户的 ID、姓名、年龄等信息。\n    - 集合类型（set）：用于存储不重复的元素集合，支持交、并、差集等操作。\n    - 有序集合类型（sorted set）：类似于集合类型，但每个元素都有一个分数（score）与之关联，支持按照分数排序。\n\n### RabbitMQ\n1. 交换机类型\n    - fanoutExchange : 广播交换机，适用于简单模式、订阅模式、工作队列模式\n    - directExchange : 路由定向交换机，适用于路由模式\n    - headersExchange: 头交换机，适用于路由模式, 路由交换机的路由是基于路由键，头交换机的路由值基于消息的 header 数据。\n    - topicExchange : 主题交换机，适用于通配符模式\n\n2. 如何解决重复消费问题\n    - 开启手动ACK的机制，当消费端消费成功之后会给服务端发送一条确定信息，当收到确认信息之后，我们在服务端才让下一个消息进行消费。默认是自动ACK，也就是消费端消费成功了不会发送信息给服务端。\n    - 使用唯一的消息ID，并存到数据库中，每次消费者消费之前都去检查一下这条消息是否被消费过，如果没有才进行消费\n    - 使用分布式锁的方式，比如说redis的分布式锁命令setNX\n\n3. 如何保证消费顺序\n    - 在生产端可以给每个消息一个序号，然后消费端按照排序的序号进行消费\n    - 采用单队列单消费者的模式，将同一消息类型的消息放到一个队列中去，因为消费顺序主要是由于不同消费端对不同消息的处理能力不同导致的\n\n4. 如何保证消息不丢失\n    - confirm模式 ： 保证生产端到交换机这段路，消息无论是否成功被交换机拿到，都要返回一个确认消息\n    - return模式： 保证交换机到队列这段路，消息没能到队列才发送一个返回消息。\n\n\n## 基础学科\n### 数据结构\n1. HashMap的原理\n    - jdk1.7与jdk1.8的区别：\n        - 1.7是单链表，1.8加入了红黑树\n        - 1.7是头插法，1.8使用了尾插法，避免了环形链表死循环的问题\n    - 数据结构：数组+链表+红黑树\n        - 链表转红黑树条件：数组容量大于64且链表长度大于8,若数组容量不够则会扩容\n    - 为什么使用红黑树\n        - AVL树和红黑树都具有良好的平衡性，但AVL树对平衡性的要求比较高，每次插入或删除操作可能需要进行多次旋转操作来保持平衡，这会造成一定的性能开销。而红黑树对平衡性的要求相对较低，可以在一定程度上减少旋转操作的次数，提高插入和删除的性能。\n    - 多线程导致的问题\n        - 线程安全问题：HashMap不是线程安全的，多个线程同时对HashMap进行操作可能会导致数据的不一致性，例如put和remove操作可能导致元素丢失或重复等问题。\n        - 性能问题：当多个线程同时对HashMap进行操作时，由于需要进行锁竞争或者CAS操作，可能会导致性能下降，尤其是在高并发情况下。\n\n2. Concurrenthashmap原理\n    - ConcurrentHashMap采用了分段锁技术来保证并发访问的线程安全性，并且采用了CAS操作和volatile变量来保证数据的可见性和线程安全性。\n    - ConcurrentHashMap将整个存储空间分成若干个小的Segment段，每个Segment段相当于一个小的HashMap。\n    - ConcurrentHashMap在Segment段上加锁，每个线程在访问时只需要锁定对应的Segment段，而不需要锁定整个Map。\n    - ConcurrentHashMap在put、get等方法中会先根据key的hash值找到对应的Segment段，然后在该Segment段内进行操作，从而保证了多线程访问的线程安全性。\n    - ConcurrentHashMap在扩容时只需要对Segment段进行扩容，而不需要对整个Map进行扩容，因此扩容的代价相对较小。\n    - ConcurrentHashMap对于读操作和写操作进行了分离，对于读操作没有加锁，可以实现读取的高并发性。\n    - CAS和sychronize分别在什么时候使用\n        - CAS: 被用于实现ConcurrentHashMap的put()和remove()方法。当多个线程同时对ConcurrentHashMap进行put或remove操作时，CAS可以确保只有一个线程能够成功地执行该操作。\n        - synchronize: 被用于实现ConcurrentHashMap的get()方法。当多个线程同时访问ConcurrentHashMap中的同一条记录时，需要确保它们访问的是相同的记录，并且在访问过程中不会被其他线程修改。\n\n\n3. B树和B+树之间的区别\n    - B树\n        - 它是一种多路的平衡搜索树。\n        - 它跟普通的平衡二叉树的不同是，B树的每个节点可以存储多个数据，而且每个节点不止有两个子节点，最多可以有上千个子节点。\n        - B树中每个节点都存放着索引和数据，数据遍布整个树结构，搜索可能在非叶子节点结束，最好的情况是O(1)。\n\n    - B+树\n        - B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快。\n        - B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定\n        - B+树区间查询更方便：B+树所有的叶子节点数据构成了一个双向链表，在查询大小区间的数据时候更方便，数据紧密性很高。\n        - B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。\n    \n    - InnoDB为什么选择B+树\n        - 扫库、扫表能力更强：如果我们要对表进行全表扫描，只需要遍历叶子节点就可以 了，不需要遍历整棵B+树\n        - 数据连续可达：叶子节点上有下一个数据区的指针，数据形成了链表\n        - 效率稳定：B+树永远是在叶子节点拿到数据，所以IO次数是稳定的，而B树运气好的话根节点就能拿到数据，运气不好就要到叶子节点才能拿到数据，所花费的时间会有差异。\n\n4. 队列和堆栈\n    - 队列\n        - 顺序：先入先出\n        - 可在一端插入，另一端删除\n        - 可基于地址指针，从头部或者尾部来遍历，且不需要开辟临时空间，遍历速度更快\n        - 场景：任务调度、消息传递等场景\n    - 栈\n        - 顺序：后入先出\n        - 插入和删除在同一端\n        - 只能从顶部取数据，且需要开辟临时空间，如若要取栈底的元素，得先把所有元素给取出来一遍才行，遍历速度更慢\n        - 场景：回溯、表达式求值\n\n\n### 计算机网络\n1. TCP和UDP (传输层协议)\n    - 连接方式\n        - TCP是面向连接的协议，通信双方在传输数据之前需要先建立一个连接。连接的建立需要进行三次握手，确保通信双方能够相互通信，并确认双方都已准备好开始数据传输。数据传输完成后，需要进行四次挥手，正式关闭连接。\n        - UDP是无连接的协议，通信双方在传输数据之前不需要建立连接，也不需要进行连接的释放。每个数据包都是独立的，不会建立持久性的连接。\n    - 优缺点比较\n        - TCP可靠性高且具有有序性，发送的数据包会按照顺序进行接收，UDP的可靠性不高且不保证有序性\n        - TCP需要提前建立连接，所以传输速度比UDP慢,且实时性也不如UDP\n        - TCP可通过拥塞控制算法避免网络拥堵，但是UDP无法避免\n\n2. http与https(应用层协议)\n    - http\n        - 概念：HTTP代表超文本传输协议，它是用于在Web浏览器和Web服务器之间传输数据的协议。\n        - 机制：HTTP协议是明文传输数据的，这种明文传输数据的方式存在一定的风险，特别是在传输敏感信息时。\n    - https\n        - 概念：HTTPS代表安全超文本传输协议，它是HTTP协议的安全版本。\n        - 机制：在HTTPS下，传输的数据是通过SSL或TLS加密的，这样攻击者即使截取到了数据，也无法轻易地解密和阅读其中的内容。HTTPS还能够验证服务器的身份，确保用户正在与其信任的网站通信，而不是被攻击者伪装的恶意网站。\n\n3. Http状态码\n    - 200 OK：请求成功。服务器成功处理了请求，并返回了请求的数据。\n    - 301 Moved Permanently：永久重定向。请求的资源已被永久移动到新的URL。\n    - 302 Found：临时重定向。请求的资源已被临时移动到新的URL。\n    - 400 Bad Request：错误请求。服务器无法理解请求，因为请求中包含语法错误。\n    - 401 Unauthorized：未授权。请求需要用户身份验证，但用户未提供有效的身份验证信息。\n    - 403 Forbidden：禁止访问。服务器拒绝了请求，因为请求者没有访问资源的权限。\n    - 404 Not Found：未找到。服务器无法找到请求的资源。\n    - 500 Internal Server Error：服务器内部错误。服务器遇到了意外的情况，无法完成请求。 \n\n4. TCP粘包问题\n    - 概念：当发送方在短时间内连续发送多个数据包时，接收方在接收数据时可能会将多个数据包合并成一个数据包，从而导致数据包大小超过了接收缓冲区的大小，这就是所谓的粘包问题。\n    - 导致原因：\n        - 数据发送过快\n        - 接收缓冲区大小不够\n    - 解决方案：\n        - 采用特定的分隔符。发送方在发送数据包之前，在数据包中加入特定的分隔符，接收方在接收数据包时根据分隔符将数据包进行分割。\n        - 采用消息头和消息体。发送方在发送数据包之前，在数据包中加入消息头和消息体，消息头用于标识消息体的长度和类型，接收方在接收数据包时根据消息头将数据包进行分割。\n\n\n\n### 操作系统\n1. 进程和线程的区别\n    - 根本区别：进程是操作系统进行**资源分配**的最小单元，线程是操作系统进行**运算调度**的最小单元。\n    - 从属关系不同：进程中包含了线程，线程属于进程。\n    - 开销不同：进程的创建、销毁和切换的开销都远大于线程。\n    - 拥有资源不同：每个进程有自己的内存和资源，一个进程中的线程会共享这些内存和资源。\n    - CPU利用率不同：进程的CPU利用率较低，因为上下文切换开销较大，而线程的CPU的利用率较高，上下文的切换速度快。\n\n\n# 项目积累\n## 项目初衷\n- 做一个项目来把我所学的技术栈都尽量用起来，主要目的是想在开发项目中不断积累经验达到一个自学的目的。\n\n## 项目难点及解决方案\n- 二级缓存的设置,将它放在哪比较合适\n    - 使用Caffine + Redis构建二级缓存，使用SpringAOP将其独立出来\n\n- 如何优雅地使用SpringSecurity来实现用户的鉴权和认证\n    - 采用 RBAC0 权限模型、将管理员用户、角色、权限、受保护的 URL 都放入到 MySQL 中并建立相应联系\n    - 合理使用SpringSecurity的过滤链，使用数据源、管理器等资源实现系统的权限及认证管理\n\n- 如何让前端更方便地测试\n    - Swagger写接口文档\n    - 部署到云服务器\n","categories":["Interview"],"tags":[]},{"title":"BigData-HBase","url":"/posts/10071/","content":">总结关于了HBase的相关内容\n<!--more-->\n# HBase的启动\n>端口:16010\n\n# HBase的常用Shell命令\n1. jps查看守护进程(Linux的命令)\n2. Ctrl + Delete才能删除输入错误的命令\n3. exit 退出命令窗口\n4. 命名空间\n    - list_namespace : 列举命名空间\n    - create_namespace 'XXX' : 创建命名空间\n    - describe_namespace 'XXX' : 查看某个命名空间的相关信息\n    - alter_namespace 'XXX' ,{METHOD =>'set','hbase.namespace.quota.maxregion'=>'10'}: 修改命名空间的相关信息\n\n5. 表的创建\n    - create 'namespace:tableName','列族名1',....,'列族n'(无参数设置)\n    - create 'namespace:tableName',{name=>'列族1',versions=>1.....},{name=>'列族2'},'列族名3'\n    - create 'namespace:tableName','f1',SPLITS=>['10','20','30','40'] (设置4个分隔点，则是5个region)\n\n6. 查看表\n    - desc 'namespace:tableName' :查看制定表的结构\n    - count 'namespace:tableName' : 查看表中有多少个行键(类比关系型数据库的多少条记录)\n\n7. 修改表\n    - alter 'namespace:tableName',{name=>'列族1',version=>2}  (列族存在则修改，不存在就是添加)\n    - alter 'namespace:tableName',{name=>'列族2',METHOD='Delete'}\n\n8. 删除表\n    - 先disable 'namespace:tableName' :禁用表之后才能删除表\n    - drop 'namespace:tableName' :删除表\n\n9. 表数据增加\n    - put 'namespace:tableName','行键','列族:列限定符','插入值'\n    - put 'namespace:tableName','行键','列族:列限定符','插入值',时间戳\n\n10. 表数据查看\n    - get 'namespace:tableName','行键',{其他参数}\n    - get 'namespace:tableName','行键',{COLUMN=>'course',....} // 只看course列族\n    - get 'namespace:tableName','行键',{COLUMN=>'course:english'} // 只看英语成绩\n    - scan 'namespace:tableName' //全表扫描，全表数据都有\n\n11. 表数据修改\n    - delete 'namespace:tableName','jim','course:chinese' // 删除的默认是最新版本的数据，只能删一个列族的数据\n    - deleteall 'namespace:tableName','行键' //删除的是某个行键所对应的所有列族的数据\n    - truncate 'namespace:tableName' // 删除整个表中的数据,只保留一个region\n    ","categories":["Bigdata"],"tags":[]},{"title":"Algorithm-think","url":"/posts/2170/","content":">总结了关于算法的一些思路\n<!--more-->\n# 最小的连续因子序列  \n> for(inti=2; i*i<n; i++) 应当从2开始找  \n>最多找到i²<n的时候，因为我们要从i开始往后找连续的片段，而当i*i>=n的时候，i*(i+1)必然> 大于n，这时就没有必要继续遍历下去了  \n>大体思路无非是从2开始往后找，找到第一个因子之后，以此为基础嵌入一个循环去找以i为第一个因子，后续能构成一个长度为多大的连续因子序列。","categories":["Algorithm"],"tags":[]},{"title":"WritingPart-Baidu","url":"/posts/10408/","content":">百度的笔试复盘记录\n<!--more-->\n# 1，Cookie和Session\n>* Session的安全性更高\n>* 如果用户禁止cookie，服务器仍会将sessionId以cookie的方式发送给浏览器，但是，浏览器不再保存这个cookie(即sessionId)了如果用户禁止cookie，服务器仍会将sessionId以cookie的方式发送给浏览器，但是，浏览器不再保存这个cookie(即sessionId)了\n>* cookie默认是会话cookie，保存在内存中，浏览器退出就会过期，但是如果持久化cookie后将会保存在磁盘中\n\n# 2，出栈方案\n> f(n) = ∑(i=0;n-1)f(i)*f(n-1-i),  f(0) = f(1) = 1  \n> 若有7个元素，则出栈方案有 f(7) = f(0)f(6)+f(1)*f(5)+....+f(6)*f(0)\n\n# 3，Select\n>* 只要unacid存在数据，则对manager_code表进行全查询  \n```sql\nSELECT * FROM `manager_code` WHERE EXISTS (SELECT 0 FROM `unacid`);\n```\n>* 无须关注表中具体数据，只需知道表中有多少条记录，用以下可以提高查询效率\n```sql\n- 不管输出的是什么，不妨碍exists判断记录条数\nselect 0 from table;\nselect 1 from table;\nselect null from table;\nselect false from table;\n```\n# SQL\n>* avg会自动过滤掉为null的记录\n```sql\nSELECT AVG(work_code) FROM `manager_code`;\n```\n>* NULL不是一个值，只是一个标记\n>* 不能用 =NULL，因为=NULL表示的是某个地方的值为NULL，而isNULL表示某个地方是否是有NULL这个标记\n","categories":["Interview"],"tags":[]},{"title":"AC-windowsWords","url":"/posts/46298/","content":">windows操作命令\n<!--more-->\n# 端口\n## 查看所有端口\n>netstat -ano\n## 查到指定端口占用情况\n>netstat -ano |findstr \"XXXX\"\n## 结束进程\n>taskkill /pid XXXX -f\n","categories":["Accumulate"],"tags":[]},{"title":"BigData-HDFS","url":"/posts/32491/","content":">关于HDFS的相关操作\n<!--more-->\n# 文件操作命令\n- **创建文件**\n  - hdfs dfs -mkdir -p <Path>\n\n- **显示目录**\n  - hdfs dfs -ls /\n\n- **文件上传**\n  - -f是强制覆盖  \n  - hdfs dfs -put [-f][-p] <localsrc> <dst>\n- **文件合并后上传**  \n  - hdfs dfs -appendToFile /root/opt/*.* /user/root/txtdir/merge.txt\n\n- **文件下载**\n  - hdfs中文件合并后下载\n    - hdfs dfs -getmerge /user/root/txtdir/*.* /root/opt/join.txt\n  - 直接从hdfs下载文件到本地\n    - hdfs dfs -get /user/root/a.txt /root/opt/join.txt\n\n\n- **文件内容查询**\n  - hdfs dfs -cat /user/root/txtdir/a.txt\n\n-  **文件删除**\n  - ```txt hdfs dfs -rm <pathURL> ```\n\n\n\n# web界面操作\n## hdfs查看\n>master:50075\n","categories":["Bigdata"],"tags":[]},{"title":"BigData-Hadoop","url":"/posts/30565/","content":">主要介绍了大数据中Hadoop集群的使用\n<!--more-->\n# 时间同步\n## 分节点\n>在3个slave节点上执行命令【service ntpd stop】、【ntpdate master】、【service ntpd start & chkconfig ntpd on】启动与主节点master的时间同步服务。 \n## 主节点\n>在主节点执行/usr/local/sbin/目录下的命令【ntp_update】，可快速启动时间同步服务。\n\n# 集群的启动与关闭\n## 启动\n>执行/usr/local/sbin/hadoop_cluster.start即可\n## 关闭\n>执行/usr/local/sbin/hadoop_cluster stop即可\n\n# Hadoop集群的操作\n## 查看节点进程\n>/usr/local/sbin/hadoop_cluster status\n## 查看当前主机名\n>hostname : 查看当前主机全名  \n>hostname -f : 查找当前主机配置的映射名\n\n# Web界面操作Hadoop\n## HDFS监控\n> http://master:50070\n## 应用监控\n> http://master:8080","categories":["Bigdata"],"tags":[]},{"title":"JavaFX","url":"/posts/44747/","content":">总结了关于JavaFX的相关内容\n<!--more-->\n\n","categories":["JavaStudy"],"tags":[]},{"title":"WebS- 接单平台","url":"/posts/13929/","content":">总结了各大接单平台\n<!--more-->\n# 接单前要\n>* 需要有第三方担保，个人对个人的尽量不要接\n>* 不说具体需求的不要接，需要有具体的需求文档\n>* 尽量442收费方式，开工收40%项目款，项目中期收40%项目款，项目结束收20%项目款\n>* 不给完钱不交完整代码\n\n# 接单网站\n## 开源众包\n> https://zb.oschina.net\n## 猪八戒\n> https://zbj.com\n## 程序员客栈\n> https://www.proginn.com/\n## coding码市\n>https://mart.coding.net\n## 英选\n> http://linktion.cn\n## 开发邦\n>http://www.kaifabang.com\n## freelancer\n>https://www.freelancer.com\n## Stackoverflow\n>https://stackoverflow.com\n## 猿急送\n>https://www.yuanjisong.com\n## 人人开发\n>http://rrkf.com\n## 码易\n>http://mayigeek.com","categories":["WebSites"],"tags":[]},{"title":"MySQL-CRUD","url":"/posts/48277/","content":">介绍了MySQL中对于CRUD的基本操作\n<!--more-->\n# Create(新建)\n## 创建表的时候添加限制\n```sql\n  CREATE TABLE test(\n\tid INT,\n\thcode INT,\n\tCONSTRAINT xtzl FOREIGN KEY (hcode) REFERENCES heal(id)\n\tON UPDATE CASCADE\n    ON DELETE CASCADE);\n```\n## 新增数据\n```sql\nINSERT emp VALUES(NULL,'智力2',2);\nINSERT INTO xtzl(NAME,Birthday,Sex ,Age)VALUES('嘉嘉','2002-6-06','男',10);\n```\n# Read(查询)\n## 全查询 && 条件查询 && 去重查询\n```sql\nselect * from tableA;\nselect * from tableA where XXX;\nSELECT DISTINCT NAME FROM xtzl;\n-- 截取查询\nselect left(username,3) from tableA;\n```\n## 模糊查询\n```sql\n -- 关键词 where-like\n -- 模糊查询，查询名字是小开头的数据\nSELECT * FROM xtzl WHERE NAME LIKE '小%'; \n-- 模糊查询，查询名字是四个字的，有四个下划线\nSELECT * FROM xtzl WHERE NAME LIKE '____'; \n-- 模糊查询，查询名字里面包含有‘特’的数据\nSELECT * FROM xtzl WHERE NAME LIKE '%特%'; \n```\n## 排序查询\n```sql\n-- 先按照前面那个条件升序，如果前面那个条件的值一样的时候，才会按照后面的条件排序\nSELECT * FROM xtzl  ORDER BY Age ASC ,score DESC; \n```\n## 聚合查询\n```sql\n   -- count 计算个数  \n   -- max 计算最大值\n   -- min 计算最小值\n   -- sum 计算和\n   -- avg 计算平均值\nSELECT COUNT(NAME ) FROM xtzl; -- 单行单列的元素个数\n```\n## 分组查询\n```sql\n-- 查询的字段必须在group by 后或者聚合函数内\nSELECT sex FROM xtzl GROUP BY sex;  \nSELECT sex,AVG(score) FROM xtzl GROUP BY sex; \n-- AVG()用于对指定的列或表达式求平均值\nSELECT sex,AVG(score) FROM xtzl WHERE score>=100 GROUP BY sex; \n```\n## 分页查询\n```sql\n-- 0表示第一个数据的索引值，3表示索引从0开始，依次读取3个数据\nSELECT * FROM xtzl LIMIT 0,3; \n-- 第二页了，上面那个是第一页  (2-1)*3 = 3 = 当前页面开始时的索引\nSELECT * FROM xtzl LIMIT 3,4; \n```\n\n# Update(修改)\n## 修改表结构\n### 修改列的数据类型\n```sql\nALTER TABLE stu modify name VARCHAR(20);\nALTER TABLE stu MODIFY NAME VARCHAR(20) UNIQUE;\n```\n### 修改列名或数据类型\n```sql\nALTER TABLE xtzl change Age Myage INT;\n```\n### 删除某列\n```sql\nALTER TABLE xtzl DROP KKK;\n```\n### 添加某列\n```sql\nALTER TABLE xtzl ADD  SEX VARCHAR(1);\n```\n## 修改数据记录\n```sql\nUPDATE xtzl SET NAME='小特特' WHERE Age=10;\n```\n## 修改数据库\n### 修改基本配置\n```sql\nALTER DATABASE\nMODIFY FILE{\n\tNAME=Teacher_Log,\n\tFILENAME='E:\\SQL Server\\DB_Practice\\Test01\\Teacher.ldf',\n\tSIZE=10,\n\tMAXSIZE=500,\n\tFILEGROWTH=10};\n```\n### 修改数据库用户的密码\n```sql\nUPDATE USER SET PASSWORD = PASSWORD ('newpassword') WHERE USER = 'wendy';  \n-- 格式： \nset password for 用户名@localhost = password(‘新密码’);  \n-- 例子：\nset password for root@localhost = password(‘123’);\n```\n# Delete(删除)\n## 删除表和数据库\n```sql\nDROP DATABASE xxx;\nDROP TABLE xxx;\n-- 删除表后重构一个数据结构相同，无数据的表\nTRUNCATE TABLE xtzl;\n```\n## 删除表中数据\n```sql\nDELETE FROM table_name WHERE xxxx;\n```\n\n# Constraint的CRUD\n## 新增\n### 添加主键及其自增\n```sql\nALTER TABLE stu MODIFY id INT PRIMARY KEY AUTO_INCREMENT;\n```\n### 添加外键\n```sql\nALTER TABLE workers ADD CONSTRAINT foreignkeyName FOREIGN KEY (de_id) REFERENCES department(id);\n```\n### 添加某列的约束\n```sql\n-- 添加 WeiXin 唯一值约束 \nalter table Student add constraint WeixinUnique unique(WeiXin);\n-- 添加 check 约束 \nalter table Student add constraint mycheckN check(Gender = ' 男 ' or Gender = ' 女 ')\n```\n## 删除\n### 删除某列的约束\n```sql\n-- 删除表 student 的唯一值约束 \nalter table Student drop WeixinUnique;\n```\n### 删除外键\n```sql\n-- 删除外键 \nalter table Gooos drop foreign key outsidecode\n```\n## 修改\n> 修改其实和新增大同小异，只是要注意constraint的对应名称不能错即可\n```sql\n-- 在表 SaleBill 上增加数量大于 0 的约束。\nalter table SaleBill add constraint numlimit check(Number > 0);\n-- 将表 SaleBill 上数量的约束修改为 0~100。\nalter table SaleBill add constraint changedlimit check(Number >=0 and Number <=100)\n```\n","categories":["DataBase"],"tags":[]},{"title":"MySQL-advanced","url":"/posts/55275/","content":">介绍了关于MySQL中的高级特性\n<!--more-->\n# MVCC的原理\n## MVCC的介绍\n>**MVCC：** 多版本并发控制机制  \n>**作用：**\n>* 可解决脏读、不可重复读的事务读写问题\n>* 在保证隔离性的基础上，提升了读取效率和并发性\n## 保证事务隔离性\n**UndoLog版本链**\n>* 在执行Update和Delete操作的时候，会将每次操作记录记录在UndoLog中,每条记录都有唯一的事务ID\n>* 最新的记录在链头，最老的记录在链尾  \n\n**Readview**\n>记录了数据版本链的统计值: m_ids、min_trx_id、max_trx_id、creator_trx_id\n>* m_ids：ss活跃事务ID集合(未提交的事务)\n>* min_trx_id：最老活跃事务ID\n>* max_trx_id：最新活跃事务ID+1 (下一个将被分配的版本ID)\n>* creator_trx_id：当前事务ID\n\n**选择版本**  \n> **四步判断法**  \n>在遍历版本链的过程中    \n1，判断当前版本事务ID == 最新活跃事务，若是，则该版本符合要求,若不是，则继续往下判断  \n2，判断当前版本事务ID < 最老活跃事务(在创建当前事务之前就已经提交了)，若是，则该版本符合要求，若不是，则继续往下判断\n3，判断当前版本事务ID > max_trx_id（在创建当前事务之后才有的版本),若是，则版本不符合要求\n4, 判断当前版本事务ID 是否在非活跃事务中，如果不在，则说明该版本事务是已提交的事务，符合要求  \n>- - -\n**解决问题**\n>在进行undoLog中遍历版本链选择版本的过程中，主要找到最新的已提交的版本，从而避免了脏读，而第一事务开始前创建，之后都只使用这唯一的一个ReadView,则单个事务去匹配到的版本就是一样的，也就解决了不可重复读的问题\n\n# 权限操作\n## 查询权限\n```sql\n-- 查询某个用户的权限\n\tSHOW GRANTS FOR 'root'@'%';\n\tSHOW GRANTS FOR 'wendy'@'localhost';\n```\n## 授予权限\n```sql\n-- 格式：grant 权限列表 on 数据库表.表名 to '用户名'@'主机名' :把某张表的哪些权限给某个用户\nGRANT ALL ON *.* TO 'wendy'@'localhost';\n```\n## 撤销权限\n```sql\nREVOKE ALL ON *.* FROM 'wendy'@'localhost';\n```\n\n# 函数的使用\n## if && ifnull\n>* IFNULL函数接受两个参数，如果不是NULL，则返回第一个参数。否则，IFNULL函数返回第二个参数。\n>* is null 函数 is not null 函数与上同理\n```sql\n-- if\nSELECT IF(uuu IS NOT NULL ,'1','2') p FROM users; \n-- ifnull\nSELECT id,IFNULL(uuu,PASSWORD) param FROM users;\n```\n## Case when\n<img src = \"http://xtzl.wentexl.cn/case1.png\"/>\n<img src = \"http://xtzl.wentexl.cn/case2.png\"/>\n\n","categories":["DataBase"],"tags":[]},{"title":"RabbitMQ","url":"/posts/15185/","content":">关于RabbitMQ的知识点积累\n<!--more-->\n# 架构图\n<img src = \"http://xtzl.wentexl.cn/rabbitMQ.png\">\n\n# 工作模式(五种)\n## Simple简单模式\n>一个生产者，一个队列，一个消费者的模式\n\n## Work queues工作队列模式\n>多个消费端共同处理同一个队列中的消息\n>对于任务过重或者任务较多的情况使用,C1和C2的轮询获取的，同一个消息只能被其中一个获取到\n<img src=\"http://xtzl.wentexl.cn/wq.png\"/>\n\n## Pub/Sub 订阅模式\n<img src=\"http://xtzl.wentexl.cn/emq.png\"/>\n\n## Routing路由模式\n>交换机只将消息发送给指定路由key的消息队列中去\n<img src=\"http://xtzl.wentexl.cn/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2%E6%9C%BA.png\"/>\n\n## Topic通配符方式\n>批量匹配之后将消息发送到对应消息队列中\n><img src=\"http://xtzl.wentexl.cn/Topic%E9%80%9A%E9%85%8D%E7%AC%A6%E6%96%B9%E5%BC%8F.png\">\n* topic中#和*的区别\n>符号“#”匹配路由键的一个或多个词，符号'*'只匹配路由键的一个词。  \n>例如：topic.#那么这个队列会会接收topic开头的消息，topic.*.queue那么这个队列会接收topic.aaaa.queue这样格式的消息，不接收能topic.aaaa.bbbb.queue这样格式的消息\n\n# 交换机的类型\n>* fanoutExchange : 广播交换机，适用于简单模式、订阅模式、工作队列模式\n>* directExchange : 路由定向交换机，适用于路由模式\n>* headersExchange: 头交换机，适用于路由模式,路由交换机的路由是基于路由键，头交换机的路由值基于消息的header数据。\n>* topicExchange  : 主题交换机，适用于通配符模式\n\n# SpringBoot集成RabbitMQ\n## 导入依赖\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n## 生产端\n>* 在配置类中配置交换机、消息队列以及它们的绑定关系\n>* 使用RabbitTemplate发送消息,最重要的三个参数是：交换机名称、路由key、消息数据\n### 定义与绑定\n```java\n@Configuration\npublic class RabbitMQConfig {\n    public static final String EXCHANGE_NAME = \"bootExchange\";\n    public static final String QUEUE_NAME_ONE = \"bootQueueOne\";\n    /**一、交换机*/\n    @Bean(\"bootExchange\")\n    public Exchange rabbitExchange(){\n        // durable是众多参数之一，是否持久化\n        return ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(true).build();\n    }\n    /**二、队列*/\n    @Bean(\"bootQueueOne\")\n    public Queue bootQueue(){\n        // 设置持久化、设置ttl：消息队列中的消息最大存活时间是5s\n        return QueueBuilder.durable(QUEUE_NAME_ONE).ttl(5000).build();\n    }\n\n    /**三、队列和交换机的绑定关系*/\n    @Bean\n    public Binding bindQueueExchange(@Qualifier(QUEUE_NAME_ONE) Queue queue,\n                                     @Qualifier(EXCHANGE_NAME) Exchange exchange){\n        return BindingBuilder.bind(queue).to(exchange).with(\"boot.#\").noargs();\n    }\n}\n```\n\n\n## 消费端\n>* 配置一个Listener,使用 @RabbitListener来自动接收消息并处理，如下代码所示\n```java\n// 这里接收了消息会自动确认，即消息的自动签收\n@Component\npublic class RabbitMQListener {\n    @RabbitListener(queues = \"bootQueueOne\")\n    public void ListenerQueue(Message message){\n        System.out.println(message);\n    }\n}\n```\n\n# 高级特性\n## 消息的可靠性传递\n> 可靠性：作为消息发送方，希望杜绝任何消息丢失或者投递失败的场景\n### Confirm确认模式\n> producer ---> exchange：返回一个confirmCallback，里面为true则成功到达exchange，为false则消息未到达exchange\n```java\n    @Test\n    public void testResponsibility() throws InterruptedException {\n        // 定义回调函数\n        // ask为判断标志位，cause为消息发送失败的原因\n        rabbitTemplate.setConfirmCallback(((correlationData, ask, cause) -> {\n            if (ask){\n                System.out.println(\"消息发送成功\");\n            }\n            else {\n                System.out.println(\"消息发送失败\");\n                System.out.println(cause);\n            }\n        }));\n        // 发送消息\n        rabbitTemplate.convertAndSend(\"directExchange\",\"confirm\",\"消息数据\");\n        Thread.sleep(2000);\n    }\n```\n### return 退回模式\n>   exchange ---> queue： 只有投递失败的时候，才会返回一个returnCallback,说明消息未能从exchange传递到queue中\n```java\n    public void testReturn() throws InterruptedException {\n        // 如果消息从交换机发送到某个队列中失败，则将消息返回给生产者，false为直接丢弃\n        rabbitTemplate.setMandatory(true);\n        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {\n            /**\n             * @param message 消息对象\n             * @param i 错误码\n             * @param s 错误信息\n             * @param s1 交换机\n             * @param s2 路由键\n             */\n            @Override\n            public void returnedMessage(Message message, int i, String s, String s1, String s2) {\n                System.out.println(message);\n            }\n        });\n        rabbitTemplate.convertAndSend(\"directExchange\",\"confirm\",\"消息数据\");\n        Thread.sleep(2000);\n    }\n```\n## 消息的签收\n>* 消息默认在消费端是自动接收\n>* 如果未确认消息，则消息会以unasked的状态存在于消息队列中\n### Consumer ASK手动签收方式\n```yml\n    listener:\n      simple:\n        # 设置监听器为手动签收\n        acknowledge-mode: manual\n```\n```java\n// 实现接口、重写方法、使用注解添加进容器，并绑定监听的消息队列\n@Component\npublic class RabbitMQListener implements ChannelAwareMessageListener {\n    @Override\n    @RabbitListener(queues = \"directQueueOne\")\n    public void onMessage(Message message, Channel channel) throws Exception {\n        // 接收消息的消息投递序号，在某个管道中，每个消息的序号都不同\n        long deliveryTag = message.getMessageProperties().getDeliveryTag();\n        try {\n            // 接收转换消息\n            String body = new String(message.getBody());\n            // 处理业务逻辑\n            System.out.println(body);\n            int a = 1/0;\n            // 手动签收,true是指：是否接收多条消息\n            channel.basicAck(deliveryTag,true);\n        } catch (Exception e) {\n            // 拒绝签收,b1是指消息是否重回queue来重新发送给消费端\n            channel.basicNack(deliveryTag,true,true);\n        }\n    }\n}\n```\n## 消费端对消息的限流\n```yml\n    listener:\n      simple:\n        # 设置消费端一次最多拉取多少条数据\n        prefetch: 1000\n```\n## 设置消息的过期时间\n>* 如果同时设置了消息的过期时间和队列的过期时间，以消息时间短的为准\n>* 队列设置的消息时间到了之后，会移除掉队列中所有的消息\n>* 如果设置了某条消息的过期时间，则必须要等消息到顶端的时候才会判断其是否失效，若失效这个时候才会移除\n```java\n// 构造队列的时候设置TTL\nQueueBuilder.durable(\"directQueueOne\").ttl(5000).build();\n```\n```java\n// 单独给某些消息设置TTL\n    @Test\n    public void  testMessageTTL(){\n        MessagePostProcessor messagePostProcessor = new MessagePostProcessor() {\n            @Override\n            public Message postProcessMessage(Message message) throws AmqpException {\n                // 设置过期时间为5.2s\n                message.getMessageProperties().setExpiration(\"5200\");\n                return message;\n            }\n        };\n        rabbitTemplate.convertAndSend(\"directExchange\",\"confirm\",\"消息TTL测试数据\",messagePostProcessor);\n    }\n```\n## 死信队列\n> 当队列中的消息成为死信之后，可把死信发送给死信交换机，可发送到对应队列中，被对应的死信消费端所消费\n### 死信消息的三种情况\n>* 队列消息长度达到限制\n>* 消费端拒接消费消息:在手动签收消息的时候，调用了basicNack且设requeue=false\n>* 原队列存在消息过期设置，消息到达超时时间而未被消费\n### 代码配置\n```java\n    @Bean(\"directQueueOne\")\n    public Queue directQueueOne(){\n        // 设置队列中的数据的ttl的和死信交换机和死信路由键\n        return QueueBuilder.durable(\"directQueueOne\").ttl(5000).deadLetterExchange(\"deathExchange\").deadLetterRoutingKey(\"death\").build();}\n```\n## 延迟队列\n>* 当消息进入队列之后不会立即被消费，只有到达指定的时间之后才会被消费\n>* 可使用TTL+死信队列来实现延迟队列 ","categories":["MessageQueue"],"tags":[]},{"title":"RabbitMQ-Install","url":"/posts/59081/","content":"> 对RabbitMQ的安装总结与归纳\n<!--more-->\n## 1. 安装依赖环境\n\n在线安装依赖环境：\n\n```shell\nyum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz\n\n```\n## 2. 安装Erlang\n上传\nerlang-18.3-1.el7.centos.x86_64.rpm\nsocat-1.7.3.2-5.el7.lux.x86_64.rpm\nrabbitmq-server-3.6.5-1.noarch.rpm\n```sh\n# 安装\nrpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm\nrpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm\nrpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm\n```\n\n## 4. 开启管理界面及配置\n```sh\n# 开启管理界面\nrabbitmq-plugins enable rabbitmq_management\n# 修改默认配置信息\nvim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app \n# 比如修改密码、配置等等，例如：loopback_users 中的 <<\"guest\">>,只保留guest\n```\n\n## 5. 启动\n\n```sh\nservice rabbitmq-server start # 启动服务\nservice rabbitmq-server stop # 停止服务\nservice rabbitmq-server restart # 重启服务\n```\n\n- 设置配置文件\n```shell\ncd /usr/share/doc/rabbitmq-server-3.6.5/\n\ncp rabbitmq.config.example /etc/rabbitmq/rabbitmq.config\n\n```\n\n## 6. 配置虚拟主机及用户\n>管理台URL：http://120.48.77.232:15672/\n### 6.1. 用户角色\n\nRabbitMQ在安装好后，可以访问`http://ip地址:15672`  \n其自带了guest/guest的用户名和密码。默认账号和默认密码都是guest\n\n**角色说明**：\n\n1、 超级管理员(administrator)\n\n可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。\n\n2、 监控者(monitoring)\n\n可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)\n\n3、 策略制定者(policymaker)\n\n可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。\n\n4、 普通管理者(management)\n\n仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。\n\n5、 其他\n\n无法登陆管理控制台，通常就是普通的生产者和消费者。\n\n### 6.2. Virtual Hosts配置\n\n像mysql拥有数据库的概念并且可以指定用户对库和表等操作的权限。RabbitMQ也有类似的权限管理；在RabbitMQ中可以虚拟消息服务器Virtual Host，每个Virtual Hosts相当于一个相对独立的RabbitMQ服务器，每个VirtualHost之间是相互隔离的。exchange、queue、message不能互通。 相当于mysql的db。Virtual Name一般以/开头。\n\n","categories":["MessageQueue"],"tags":[]},{"title":"AC-websites","url":"/posts/51499/","content":"> 积累了我认为写的比较好的博文的链接\n<!--more-->\n# Spring全家桶相关的\n# 缓存\n## Caffine + Redis 二级缓存\n>https://baijiahao.baidu.com/s?id=1746195877138194250&wfr=spider&for=pc\n\n\n","categories":["Accumulate"],"tags":[]},{"title":"AC-dataIndex","url":"/posts/13052/","content":"> 对数据指标的相关知识进行了总结和积累\n<!--more-->\n>*  DAU：Daily Active User   \n>日活跃用户量。统计一日（统计日）之内，登陆或使用了某个产品的用户数（去重）\n>- - -\n>* WAU：Weekly Active Users  \n>周活跃用户量。统计一周（统计日）之内，登陆或使用了某个产品的用户数（去重）\n>- - -\n>* MAU：Monthly Active User  \n> 月活跃用户量。统计一月（统计日）之内，登陆或使用了某个产品的用户数（去重）\n>- - -\n>* DNU：Day New User   \n>日新增用户，表示当天的新增用户\n>- - -\n>* DOU：Day Old User  \n>日老用户。当天登陆的老用户，非新增用户\n>- - -\n>* ACU：Average Concurrent Users  \n>平均同时在线人数\n>- - -\n>* PCU：Peak Concurrent Users  \n>最高同时在线人数\n>- - -\n>* UV：Unique Visitor    \n>唯一访问量，即页面被多少人访问过\n>- - -\n>* PV：Page View  \n>页面浏览量，即页面被多少人看过\n>- - -\n>* ARPU：Average Revenue Per User  \n>平均每个活跃用户收益\n>- - -\n>* LTV：Life Time Value  \n>生命周期价值。产品从用户所有互动中获取的全部经济收益的总和\n>- - -\n>* CAC：Customer Acquisition Cost  \n> 用户获取成本\n>- - -\n>* ROI：Return On Investment   \n> 投资回报率,ROI=利润总额/投入成本总额*100%\n>- - -\n>* GMV：Gross Merchandise Volume  \n>成交总额。是指下单产生的总金额,CMV=销售额+取消订单金额+退款金额\n>- - -\n>* 支付UV  \n>下单并成功支付的用户数\n\n\n","categories":["Accumulate"],"tags":[]},{"title":"boot-Configure","url":"/posts/36638/","content":">介绍了关于SpringBoot对Web组件等的配置\n<!--more-->\n# 过滤器&&拦截器的配置\n## 过滤器注解的配置方式\n```java\n// 在过滤器类上使用注解\n@WebFilter(urlPatterns = \"/*\", filterName = \"RestWebFilter\")\n```\n```java\n//在主启动类上添加Servlet扫描注解\n@ServletComponentScan\n```\n## 过滤器在配置类的配置方式\n```java\n/**将该实例注册进容器即可 */\n    @Bean\n    public FilterRegistrationBean filterRegistrationBean(){\n        FilterRegistrationBean<Filter> registrationBean = new FilterRegistrationBean<>();\n        registrationBean.setFilter(new LoginFilter());\n        registrationBean.setName(\"loginFilter\");\n        registrationBean.addUrlPatterns(\"/login\");\n        return registrationBean;\n    }\n```\n\n\n## 拦截器在配置类的配置方式\n```java\n@Configuration\npublic class InterceptorConfig implements WebMvcConfigurer {\n      @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoginInterceptor())\n                .addPathPatterns(\"/**\")  //所有请求都被拦截包括静态资源\n                .excludePathPatterns(\"/\",\"/login\",\"/css/**\",\"/fonts/**\",\"/images/**\",\n                        \"/js/**\",\"/aa/**\"); //放行的请求\n    }\n}\n```","categories":["SpringBoot"],"tags":[]},{"title":"TechStack-SpringMail","url":"/posts/31627/","content":">总结了关于SpringBoot集成发送邮件的服务，主要用于做邮件认证码\n<!--more-->\n> 前提准备是在QQ邮箱开启SMTP服务(简单邮件传输协议)\n# 导入依赖\n```xml\n<dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n```\n# yml配置\n```yml\nspring:\n  #邮箱验证码配置\n  mail:\n    #smtp服务主机  qq邮箱则为smtp.qq.com;163邮箱是smtp.163.com\n    host: smtp.qq.com\n    #服务协议\n    protocol: smtp\n    # 编码集\n    default-encoding: UTF-8\n    #发送邮件的账户\n    username: 123456789@qq.com\n    #授权码\n    password: wpsbapnfmsbocece\n    test-connection: true\n    properties:\n      mail:\n        smtp:\n          auth: true\n          starttls:\n            enable: true\n            required: true\n```\n\n# 具体操作\n```java\n    @Resource\n    private JavaMailSender javaMailSender;\n\n    public String loginAuthCodeBySendMails(String username) {\n        // 验证码自己写代码随机生成\n        String authCode = sb.toString();\n        // 设置邮件内容\n        MimeMessage mimeMessage = javaMailSender.createMimeMessage();\n        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true,\"utf-8\");\n        helper.setSubject(\"您的验证码为:\"+authCode);\n        helper.setText(\"您好！欢迎登录校疫通管理系统。您的验证码为：\"+\"<h1>\"+authCode+\"</h1>\"+\"请勿将验证码告诉他人！验证码将在3分钟内失效，请尽快输入！\");\n        helper.setTo(targetMail);\n        helper.setFrom(\"393815277@qq.com\");\n        // 发送邮件\n        javaMailSender.send(mimeMessage);\n    }\n```\n","categories":["TechStack"],"tags":[]},{"title":"JavaSE","url":"/posts/14085/","content":"> 主要介绍了关于JavaSE的相关积累和操作\n<!--more-->\n# Tags\n## String.format\n```java\npublic class MainTest {\n    public static void main(String[] args) {\n        String ip = \"120.0.0.7\";\n        String now = \"2022/12/05\";\n        String target = \"www.wentexl.cn\";\n        String format = String.format(\"用户[%s],在[%s],访问了[%s].\", ip, now, target);\n        System.out.println(format);\n    }\n}\n```\n## 反射与注解\n```java\n/**自定义注解 */\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface testAnnotion {\n    String value() default \"\";\n}\n\n/**使用注解*/\n@testAnnotion(\"test\")\npublic class TestService {\n    @testAnnotion(\"testMethod\")\n    public void sayHello() {\n        System.out.println(\"hello word\");\n    }\n}\n\n/**获取注解 */\n\npublic static void main(String[] args) throws NoSuchMethodException {\n    Class<?> clazz = TestService.class;\n    // 获取类上面标记的所有注解\n    System.out.println(Arrays.toString(clazz.getAnnotations()));\n    // 获取类上的@testAnnotion注解\n    System.out.println(clazz.getAnnotation(testAnnotion.class));\n    //返回一个类上的直接注解信息，如果类上没有直接注解信息，则返回一个空数组\n    System.out.println(Arrays.toString(clazz.getDeclaredAnnotations()));\n\n    // 获取类中某个方法的注解信息\n    Method method = clazz.getMethod(\"sayHello\", null);\n    // 获取方法上所有的注解信息\n    System.out.println(Arrays.toString(method.getAnnotations()));\n    // 获取方法上@testAnnotion的注解\n    System.out.println(method.getAnnotation(testAnnotion.class));\n    // 获取方法上的注解信息\n    System.out.println(Arrays.toString(method.getDeclaredAnnotations()));\n\n}\n\n```\n# 八大数据类型\n## 整型 (四种)\n>* int  \n>长度为4字节32bit，取值-2^31 到 2^31-1，变量初始化默认值为0，包装类Integer\n>- - -\n>* long   \n>长度为8字节64bit，取值-2^63 到 2^63-1，变量初始化默认值为0或0L，包装类Long\n>- - -\n>* short  \n>长度为2字节16bit，取值-32768 到 32767，变量初始化默认值为0，包装类Short\n>- - -\n>* byte  \n>长度为1字节8bit，取值（-128）到（127），变量初始化默认值为0，包装类Byte\n## 浮点型 (二种)\n>* float  \n>单精度浮点型，长度为4字节32bit，变量初始化默认值0.0f，包装类Float\n>- - -\n>* double  \n>双精度浮点型，长度为8字节64bit，变量初始化默认值0.0d，包装类Double\n## 字符型 (一种)\n>* char  \n>占2字节16bit，可以赋值单字符以及整型数值, 变量初始化无默认值，包装类Character。\n## 布尔型 (一种)\n>* boolean  \n>仅有两个值true, false，变量初始化默认值false\n\n# 浅拷贝和深拷贝\n## 浅拷贝\n> * 最简单的浅拷贝：Student s1 = new Student(); Student s2 = s1; \n> * 浅拷贝就是获得拷贝对象的引用,而不是正真意义上的拷贝一个对象  \n> * 如下代码中的Student是JavaBean对象，而School只是实现了Cloneable接口\n> * 实际上这不全是深拷贝，因为原对象中的成员变量若是一个对象引用，则对该成员变量只是浅拷贝而已,但是School本身确实是深拷贝，因为新School对象和原School对象确实不是同一个对象\n```java\n  // 重写的Clone方法中，如果是super.clone()，是无法克隆到本对象的成员变量的，这样的话实际上也是一种浅拷贝\n  @Override\n  protected School clone() throws CloneNotSupportedException {\n    return (School)super.clone();\n  }\n```\n## 深拷贝\n> 深拷贝则是拷贝了源对象的所有值，所以即使源对象的值发生变化时，拷贝对象的值也不会改变。深拷贝则是真正意义上的拷贝\n### 构造函数深拷贝(new关键字)\n```java\npublic void constructorCopy() {\n  Student student = new Student (\"小李\",21,\"男\");\n  School school = new School (\"xx大学\",100, student);\n \n  // 调用构造函数时进行深拷贝\n  School copySchool = new School (school.getSchoolName(),school.getStuNums(), new Student(student.getName(), student.getAge(),student.getSex()));\n \n  // 修改源对象的值\n  copySchool .getStudent().setSex(\"女\");\n \n  // 检查两个对象的值不同\n  System.out.println(school.hashCode()==school2.hasCode())\n}\n```\n### 重载Clone()方法深拷贝\n>在重写School类的clone()方法时，Student对象需要调用stu.clone()重新赋值。\n```java\n// 重写Clone方法里面，需要将被克隆的对象的属性对象也克隆一下\n  @Override\n  protected School clone() throws CloneNotSupportedException {\n    School school = (School) super.clone();\n    school.stu = (Student) stu.clone();\n    return school;\n  }\n```\n### Serializable序列化深拷贝\n```java\n@Data\npublic class User implements Serializable {\n  private String name;\n  private Address2 address;\n\n  public Object deepClone() throws Exception\n  {\n    // 序列化\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(bos);\n\n    oos.writeObject(this);\n\n    // 反序列化\n    ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n    ObjectInputStream ois = new ObjectInputStream(bis);\n\n    return ois.readObject();\n  }\n}\n```\n```java\n@Data\npublic class Address2 implements Serializable {\n  private String city;\n  private String country;\n}\n```","categories":["JavaStudy"],"tags":[]},{"title":"Python","url":"/posts/43687/","content":"> 关于python的相关知识点\n<!--more-->\n# 数据结构\n## Queue\n### 导入依赖\n```py\nfrom queue import Queue\n```\n### 数据操作\n```py\n# 创建队列\nqueue_obj = Queue()\n# 添加元素\nqueue_obj.put(i)\n# 取出元素\nqueue_obj.get()\n# 判断是否为空\nqueue_obj.empty()\n# 队列长度\nqueue_obj.qsize()\n```\n# 设置下载源\n* pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n* pip config set install.trusted-host mirrors.aliyun.com\n","categories":["TechStack"],"tags":["python"]},{"title":"TechStack-Hikari","url":"/posts/36787/","content":"> 总结了关于Hikari数据库连接池的相关信息与内容\n<!-- more -->\n# 引入依赖\n```xml\n        <dependency>\n            <groupId>com.zaxxer</groupId>\n            <artifactId>HikariCP</artifactId>\n        </dependency>\n```\n\n# dataSource\n```yml\n  datasource:\n    type: com.zaxxer.hikari.HikariDataSource\n```\n# 基本配置及其解释\n```yml\nhikari:\n    # 控制HikariCP尝试在池中维护的最小空闲连接数\n    minimum-idle: 5\n    # 控制允许连接在池中保持空闲状态的最长时间,这里是10min\n    idle-timeout: 600000\n    # 控制允许池达到的最大大小,同时最多允许十个连接\n    maximum-pool-size: 10\n    # 自动提交行为\n    auto-commit: true\n    # 表示连接池的用户定义名称\n    pool-name: MyHikariCP\n    # 控制池中连接的最大生存期\n    max-lifetime: 1800000\n    # 控制客户端等待来自池的连接的最大毫秒数\n    connection-timeout: 30000\n    # 测试数据库连接的语句\n    connection-test-query: SELECT 1\n```\n\n# 配置详解\n## autoCommit\n        此属性控制从池返回的连接的默认自动提交行为。它是一个布尔值。 默认值：true\n\n## connectionTimeout\n        此属性控制客户端（即您）等待来自池的连接的最大毫秒数。如果超过此时间而没有可用的连接，则会抛出SQLException。可接受的最低连接超时为250 ms。 默认值：30000（30秒）\n\n## idleTimeout\n        此属性控制允许连接在池中保持空闲状态的最长时间。 仅当minimumIdle定义为小于maximumPoolSize时，此设置才适用。连接池达到连接后， 空闲连接将不会退出minimumIdle。连接是否以空闲状态退役，最大变化为+30秒，平均变化为+15秒。在此超时之前，连接永远不会因为闲置而退役。值必须比maxLifetime小。值为0表示永远不会从池中删除空闲连接。最小允许值为10000ms（10秒）。 默认值：600000（10分钟）\n\n## maxLifetime\n        此属性控制池中连接的最大生存期。使用中的连接永远不会停止使用，只有在关闭连接后才将其删除。在逐个连接的基础上，应用较小的负衰减以避免池中的质量消灭。 我们强烈建议设置此值，它应该比任何数据库或基础结构施加的连接时间限制短几秒钟。 值0表示没有最大寿命（无限寿命），当然要遵守该idleTimeout设置。最小允许值为30000ms（30秒）。 默认值：1800000（30分钟）\n\n## connectionTestQuery\n        如果您的驱动程序支持JDBC4，我们强烈建议不要设置此属性。这是针对不支持JDBC4的“旧版”驱动程序的Connection.isValid() API。这是将在从池中为您提供连接之前执行的查询，以验证与数据库的连接仍然有效。同样，尝试运行不带该属性的池，如果驱动程序不兼容JDBC4，HikariCP将记录错误。 默认值：无\n\n## minimumIdle\n        此属性控制HikariCP尝试在池中维护的最小空闲连接数。如果空闲连接下降到该值以下，并且池中的总连接数少于maximumPoolSize，则HikariCP将尽最大努力快速而有效地添加其他连接。但是，为了获得最佳性能和对峰值需求的响应能力，我们建议不要设置此值，而应让HikariCP充当固定大小的连接池。 默认值：与maximumPoolSize相同\n\n## maximumPoolSize\n        此属性控制允许池达到的最大大小，包括空闲和使用中的连接。基本上，此值将确定到数据库后端的最大实际连接数。合理的值最好由您的执行环境确定。当池达到此大小并且没有空闲连接可用时，对getConnection（）的调用将connectionTimeout在超时之前最多阻塞毫秒。请阅读有关池大小的信息。 默认值：10\n\n## metricRegistry\n        此属性仅可通过编程配置或IoC容器使用。此属性允许您指定池将用于记录各种指标的Codahale / Dropwizard 的实例MetricRegistry。有关 详细信息，请参见Metrics Wiki页面。 默认值：无\n\n## healthCheckRegistry\n        此属性仅可通过编程配置或IoC容器使用。此属性允许您指定池将用于报告当前健康信息的Codahale / Dropwizard 的实例HealthCheckRegistry。有关 详细信息，请参见运行状况检查 Wiki页面。 默认值：无\n\n## poolName\n        该属性表示连接池的用户定义名称，主要出现在日志记录和JMX管理控制台中，以识别池和池配置。 默认值：自动生成","categories":["TechStack"],"tags":["Hikari"]},{"title":"技术官方文档","url":"/posts/9625/","content":"> 介绍了关于技术栈中的相关技术的官方文档链接\n<!--more-->\n# SpringBoot\n```html\n<a> https://spring.io/projects/spring-boot#learn </a>\n```\n# SpringSecurity\n```html\n<a>https://spring.io/projects/spring-security</a>\n```\n# SpringCloud\n```html\n<a>https://spring.io/projects/spring-cloud</a>\n```\n# SpringData\n```html\n<a>https://spring.io/projects/spring-data</a>\n```\n\n","categories":["WebSites"],"tags":["document"]},{"title":"JavaJDBC","url":"/posts/19301/","content":">总结了关于SpringJDBC 连接SqlServer和Mysql\n<!--more-->\n\n# 连接SqlServer\n> 仅仅支持 JDK8,11,17,18\n## 导入依赖\n```xml\n  <dependencies>\n<!--  junit版本至少在4.12及其以上-->\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.12</version>\n      <scope>test</scope>\n    </dependency>\n<!--    引入Spring-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n      <version>5.3.18</version>\n    </dependency>\n<!--    使用xml配置来设置JDBC的参数-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-jdbc</artifactId>\n      <version>5.3.18</version>\n    </dependency>\n<!--  模拟Spring环境的测试jar包-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-test</artifactId>\n      <version>5.2.5.RELEASE</version>\n    </dependency>\n<!-- SQLServer的连接jar包-->\n    <dependency>\n      <groupId>com.microsoft.sqlserver</groupId>\n      <artifactId>mssql-jdbc</artifactId>\n      <version>7.4.1.jre8</version>\n    </dependency>\n<!--  使用C3P0连接池-->\n    <dependency>\n      <groupId>c3p0</groupId>\n      <artifactId>c3p0</artifactId>\n      <version>0.9.1.2</version>\n    </dependency>\n  </dependencies>\n```\n## 配置applicationContext.xml\n```xml\n<!--    1，配置数据源-->\n    <bean id=\"datasource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n<!--        驱动类名，照着写-->\n        <property name=\"driverClass\" value=\"com.microsoft.sqlserver.jdbc.SQLServerDriver\"/>\n<!--        URL地址，根据自己的URL来，端口都是3306,主要可能就改个数据库名-->\n        <property name=\"jdbcUrl\" value=\"jdbc:sqlserver://localhost:1433;DatabaseName=trding\"/>\n<!--        登录sqlserver数据库的用户名和密码-->\n        <property name=\"user\" value=\"sa\"/>\n        <property name=\"password\" value=\"rootxtzl\"/>\n    </bean>\n\n\n<!--    2，配置JDBC模板-->\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n<!--        将我们自己的数据源配置进这个JDBC模板-->\n        <property name=\"dataSource\" ref=\"datasource\"/>\n    </bean>\n\n\n\n<!--    3,注入JDBC到具体的Dao类-->\n    <bean id=\"userDao\" class=\"second.hand.transactions.dao.userDao\">\n<!--        将自己配置的jdbcTempla注入进具体的Dao类-->\n        <property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"/>\n    </bean>\n```\n\n\n# 连接MySQL\n\n## 引入依赖\n```xml\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.12</version>\n      <scope>test</scope>\n    </dependency>\n<!--    引入Spring-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n      <version>5.3.18</version>\n    </dependency>\n<!--    使用xml配置来设置JDBC的参数-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-jdbc</artifactId>\n      <version>5.3.18</version>\n    </dependency>\n<!--  模拟Spring环境的测试jar包-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-test</artifactId>\n      <version>5.2.5.RELEASE</version>\n    </dependency>\n\n<!--    使用 MySQL 8.X 的连接包-->\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>8.0.21</version>\n    </dependency>\n\n<!--    MySQL5.X 的驱动包-->\n<!--    <dependency>-->\n<!--      <groupId>mysql</groupId>-->\n<!--      <artifactId>mysql-connector-java</artifactId>-->\n<!--      <version>5.1.49</version>-->\n<!--    </dependency>-->\n\n    <!--  使用C3P0连接池-->\n    <dependency>\n      <groupId>c3p0</groupId>\n      <artifactId>c3p0</artifactId>\n      <version>0.9.1.2</version>\n    </dependency>\n  </dependencies>\n\n```\n\n## 配置数据源等实例(application.xml)\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n<!--    1，配置数据源-->\n    <bean id=\"datasource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n<!--        驱动类名，照着写-->\n        <property name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"/>\n<!--        URL地址，根据自己的URL来，端口都是3306,主要可能就改个数据库名-->\n        <property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/triding?serverTimezone=UTC\"/>\n<!--        登录sqlserver数据库的用户名和密码-->\n        <property name=\"user\" value=\"root\"/>\n        <property name=\"password\" value=\"root\"/>\n    </bean>\n\n\n<!--    2，配置JDBC模板-->\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n<!--        将我们自己的数据源配置进这个JDBC模板-->\n        <property name=\"dataSource\" ref=\"datasource\"/>\n    </bean>\n\n\n<!--    3,注入JDBC到具体的Dao类-->\n    <bean id=\"userDao\" class=\"second.hand.transactions.dao.userDao\">\n<!--        将自己配置的jdbcTempla注入进具体的Dao类-->\n        <property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"/>\n    </bean>\n</beans>\n```\n\n\n# 实体类User\n```java\npackage second.hand.transactions.entities;\n\nimport java.io.Serializable;\n\n/**\n * @author Wente\n * @date 2022/11/30\n * 普通用户类\n **/\npublic class User implements Serializable {\n    private Long userId;\n    private Long carId;\n    private String userName;\n    private String userPwd;\n    private String userNickname;\n    private String userBirth;\n    private String userPsig;\n    private String userQq;\n    private String userTele;\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"userId=\" + userId +\n                \", carId=\" + carId +\n                \", userName='\" + userName + '\\'' +\n                \", userPwd='\" + userPwd + '\\'' +\n                \", userNickname='\" + userNickname + '\\'' +\n                \", userBirth='\" + userBirth + '\\'' +\n                \", userPsig='\" + userPsig + '\\'' +\n                \", userQq='\" + userQq + '\\'' +\n                \", userTele='\" + userTele + '\\'' +\n                '}';\n    }\n\n    public Long getUserId() {\n        return userId;\n    }\n\n    public void setUserId(Long userId) {\n        this.userId = userId;\n    }\n\n    public Long getCarId() {\n        return carId;\n    }\n\n    public void setCarId(Long carId) {\n        this.carId = carId;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getUserPwd() {\n        return userPwd;\n    }\n\n    public void setUserPwd(String userPwd) {\n        this.userPwd = userPwd;\n    }\n\n    public String getUserNickname() {\n        return userNickname;\n    }\n\n    public void setUserNickname(String userNickname) {\n        this.userNickname = userNickname;\n    }\n\n    public String getUserBirth() {\n        return userBirth;\n    }\n\n    public void setUserBirth(String userBirth) {\n        this.userBirth = userBirth;\n    }\n\n    public String getUserPsig() {\n        return userPsig;\n    }\n\n    public void setUserPsig(String userPsig) {\n        this.userPsig = userPsig;\n    }\n\n    public String getUserQq() {\n        return userQq;\n    }\n\n    public void setUserQq(String userQq) {\n        this.userQq = userQq;\n    }\n\n    public String getUserTele() {\n        return userTele;\n    }\n\n    public void setUserTele(String userTele) {\n        this.userTele = userTele;\n    }\n}\n```\n\n# userDao(与数据库交互用的模板类)\n```java\npublic class userDao {\n\n    private JdbcTemplate jdbcTemplate;\n\n    public JdbcTemplate getJdbcTemplate() {\n        return jdbcTemplate;\n    }\n\n    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    /**\n     * 向数据库中添加数据\n     */\n    public void addUserCommon(){\n        String sql = \"insert into user_common(user_id,user_name,user_pwd,user_nickname,user_birth,user_psig,user_qq,user_tele)values(42000,'wente','wenteroot','文特','2001/12/05','个性签名','393815277','18423225933')\";\n        // 返回updateResult表示受影响的行数\n        int updateResult = jdbcTemplate.update(sql);\n        System.out.println(updateResult);\n    }\n}\n```\n# 测试类\n```java\n//注解是用来配置Spring的测试环境\n@ContextConfiguration(\"classpath:applicationContext.xml\")\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class TestUser {\n    @Test\n    public void test1(){\n        // 获取userDao的实例\n        ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        userDao userDao = (userDao) ctx.getBean(\"userDao\");\n        // 执行添加用户方法,该方法是我们自定义的\n        userDao.addUserCommon();\n    }\n}\n```","categories":["JavaStudy"],"tags":["SpringJDBC"]},{"title":"ssm_beanXml","url":"/posts/12964/","content":"> 总结了在SSM中对bean的配置\n<!--more-->\n# 属性是存储类对象\n```xml\n        <bean id=\"userDao\" class=\"User.UserDaoimpl\">\n            <!-- 属性是List类型 -->\n            <property name=\"strList\">\n                <list>\n                    <value>aaa</value>\n                    <value>bbb</value>\n                    <value>ccc</value>\n                </list>\n            </property>\n\n            <!-- 属性是Map类型 -->\n        <property name=\"userMap\">\n            <map>\n                <entry key=\"u1\" value-ref=\"user1\"></entry>\n                <entry key=\"u2\" value-ref=\"user2\"></entry>\n            </map>\n        </property>\n\n             <!-- 属性是Properties类型 -->\n        <property name=\"properties\">\n            <props>\n                <prop key=\"p1\">ppp1</prop>\n                <prop key=\"p2\">ppp2</prop>\n                <prop key=\"p3\">ppp3</prop>\n            </props>\n        </property>\n        </bean>\n```\n\n# 实体类属性注入\n```xml\n    <bean id=\"user1\" class=\"User.User\">\n        <property name=\"name\" value=\"tom\"/>\n        <property name=\"age\" value=\"beijing\"/>\n    </bean>\n\n```\n\n# 对象的构造方法的参数注入\n```xml\n    <!-- 将已有的id为userDao的bean注入到构造方法中参数为userDao的对象中 -->\n    <bean id=\"userService\" class=\"Service.UserServiceimpl\">\n        <constructor-arg name=\"userDao\" ref=\"userDao\"></constructor-arg>\n    </bean>\n```\n# 导入其他XML文件\n```xml\n<import resource=\"applicationContext-user.xml\"/>\n```\n","categories":["SSM"],"tags":["beanXml"]},{"title":"boot-Themleaf","url":"/posts/3251/","content":"> 总结了关于模板引擎themleaf的相关知识\n<!--more-->\n# 引入名称空间\n```txt\n<html xmlns:th=\"http://www.thymeleaf.org\">    \n```\n# 属性介绍\n* th:text：设置当前元素的文本内容，相同功能的还有th:utext，两者的区别在于前者不会转义html标签，后者会。优先级不高：order=7\n\n* th:value：设置当前元素的value值，类似修改指定属性的还有th:src，th:href。优先级不高：order=6\n\n* th:each：遍历循环元素，和th:text或th:value一起使用。注意该属性修饰的标签位置，详细往后看。优先级很高：order=2\n\n* th:if：条件判断，类似的还有th:unless，th:switch，th:case。优先级较高：order=3\n\n* th:insert：代码块引入，类似的还有th:replace，th:include，三者的区别较大，若使用不恰当会破坏html结构，常用于公共代码块提取的场景。优先级最高：order=1\n\n* th:fragment：定义代码块，方便被th:insert引用。优先级最低：order=8\n\n* th:object：声明变量，一般和*{}一起配合使用，达到偷懒的效果。优先级一般：order=4\n\n* th:attr：修改任意属性，实际开发中用的较少，因为有丰富的其他th属性帮忙，类似的还有th:attrappend，th:attrprepend。优先级一般：order=5\n# 表达式 \n* ${...}    变量表达式\n* *{...}    选择变量表达式\n* #{...}    消息表达式\n* @{...}    连接网址表达式\n* ~{...}    片段表达式\n* [[...]]   内联表达式(转义后输出)\n* [(...)]   内联表达式(直接输出原文)\n\n\n","categories":["SpringBoot"],"tags":["themleaf"]},{"title":"boot_yml","url":"/posts/54094/","content":">总结了关于yml配置的格式\n<!--more-->\n```yml\n\nperson:\n#  单引号会将转义字符作为字符串输出，双引号不会改变转义字符原先的意思，这里也就是换行符，执行换行操作\n  username: 'zhangsan \\n'\n  birth: 2001/12/05\n  age: 20\n  boos: true\n#  interests: [篮球，足球]\n  interests:\n    - 篮球\n    - 足球\n    - 18\n  animal: [阿猫，阿狗]\n#  score: {english: 80,math: 90}\n  score:\n    - english: 80\n    - math: 90\n\n#一个-代表集合的一个元素，注意-后面要加一个空格\n  allPets:\n    - sick:\n      - {name: 阿猫,weight: 20.0}\n      - {name: 阿狗,weight: 30.5}\n      - name: 小猫\n        weight: 35.0\n    - health:\n      - {name: 智力,weight: 50}\n      - {name: 力,weight: 15}\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/wedo\n    username: root\n    password: root\n    driver-class-name: com.mysql.jdbc.Driver\n  jdbc:\n    template:\n#      查询超时属性:ms是单位\n      query-timeout: 3000\n  redis:\n    url: redis://xtzl:Ljw060119@r-bp1a7csap888l0glj2pd.redis.rds.aliyuncs.com:6379\n    jedis:\n      pool:\n        max-active: 10\n        min-idle: 5\n\n#    lettuce:\n#      pool:\n#        最大活动数\n#        max-active: 10\n#          最小空闲数\n#        min-idle: 5\n\n\n\n#      配置mybatis的规则\nmybatis:\n#  config-location: classpath:mybatis/Mybatis-config.xml\n  mapper-locations: classpath:mapper/*.xml\n  configuration:\n#    开启驼峰配置，解决数据库的命名规则和服务器的\n    map-underscore-to-camel-case: true\nserver:\n  port: 8001\n\n```\n","categories":["SpringBoot"],"tags":["yml"]},{"title":"TechStack_ElasticSearch","url":"/posts/29919/","content":"> 总结了关于ElasticSearch的相关知识\n<!--more--> \n# 信息查看\n<img src = \"http://xtzl.wentexl.cn/ElasticSearch/%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B.png\">\n\n# 请求体参数\n```json\n{\n    // 多条件查询\n    \"query\":{\n        // 条件\n        \"bool\":{\n            // must是与操作，should是或操作\n             \"must\":[\n                // 种类为小米文档数据\n                {\n                    // match的底层采用倒排索引\n                    // match_phrase会采用完全匹配\n                    \"match\":{\n                    \"category\":\"小米\"\n                        }\n                },\n                // 价格为3999的数据\n                {\n                    \"match\":{\n                        \"price\" : \"3999\"\n                    }\n                }\n            ]   \n            ,\n            \"filter\" :{\n                // 指定范围\n                \"range\":{\n                    // 指定字段\n                    \"price\" :{\n                            // 大于5000\n                        \"gt\" : \"5000\"\n                    }\n                }\n            }\n        }\n    },\n    // 数组起始位置\n    \"from\" : 1,\n    // 查询的条数\n    \"size\" : 2,\n    // 选择字段 : 只查title\n    \"_source\" : [\"title\"],\n    // 排序\n    \"sort\" :{\n            //根据price字段进行排序 \n        \"price\" : {\n            // 降序排序\n            \"order\" : \"desc\"\n        }\n    },\n    // 对查询出的结果进行高亮显示\n    \"highlight\":{\n        // 指定范围\n        \"fields\":{\n            \"category\":\"小米\"\n        }\n    },\n    // 聚合操作\n    \"aggs\" : {\n        // 随意起一个组名\n        \"price_group\" : {\n            // 分组查询\n            \"terms\":{\n                // 按字段分组\n                \"field\" : \"price\"\n            },\n            // 求平均值\n            \"avg\":{\n                // 求price的平均值\n                \"field\" : \"price\"\n            }\n        }\n    },\n    // 不看原始数据\n    \"size\" : 0,\n\n    // 映射关系\n    \"properties\":{\n        // 支持自动倒排索引查询\n        \"name\":{\n            \"type\" : \"text\",\n            \"index\" : true\n        },\n        // 不支持倒排索引查询\n        \"sex\" :{\n            \"type\" : \"keyword\",\n            \"index\" : true\n        },\n        \"tel\":{\n            \"type\" : \"keyword\",\n            \"index\" : false\n        }\n    }\n}\n```\n\n# 通过Kibana来设置ES\n```json\nPUT novel_engine\n{\n    //设置title字段为completion类型，好让Suggetsion可以使用\n  \"mappings\":{\n      \"properties\": {\n        \"title\": {\n          \"type\": \"completion\",\n          \"analyzer\": \"ik_max_word\"\n        }\n      }\n  },\n  // 设置默认分词器为ik分词器\n  \"settings\": {\n      \"analysis\": {\n        \"analyzer\": {\n          \"default\":{\n            \"type\":\"ik_max_word\"\n          }\n        }\n      }\n    }\n}\n```","categories":["TechStack"],"tags":["ElasticSearch"]},{"title":"Code","url":"/posts/54840/","content":">总结了关于算法的一些代码函数\n<!--more-->\n# Functions\n## 长整数加法器 (Java)\n```java\n    // 长整数加法器\n    private static String addLongInteger(String str, int num){\n            int ci = 0;\n        StringBuffer sb = new StringBuffer();\n        for(int i = str.length() -1 ; i>=0 ;i--){\n            // 数字的ASCALL与真值相差48\n            int tempnum = (str.charAt(i) - 48) + ci +num;\n            ci = 0;\n            num = 0;\n            if (tempnum >= 10){\n                ci = tempnum/10;\n                tempnum = tempnum %10;\n            }\n            sb.append(String.valueOf(tempnum));\n        }\n    return sb.reverse().toString();\n    }\n```\n","categories":["Algorithm"],"tags":["algorithm"]},{"title":"Sqlserver-DCL","url":"/posts/37793/","content":"> 描述了关于sql对数据的控制语言\n<!--more-->\n\n# 导入外部文件到表中的命令\n```sql\n-- sqlserver\n-- 列的分隔符为|，行的分隔符为\\n\nbulk insert tea_stu_msg from 'D:\\AAA\\txt\\teastuID.txt' \nwith(fieldterminator='|',rowterminator='\\n')\n\n-- mysql\n-- 批量导入：将csv文件直接导入到数据库中\n  LOAD DATA INFILE \"D:/AAA/txt/teastuID.txt\"\n  INTO TABLE stu_tea \n  FIELDS TERMINATED BY '|' \n  LINES TERMINATED BY '\\n'\n  (peo_id,peo_name,peo_academic,peo_major,peo_tele,peo_idification)\n  SET hea_id = NULL;\n  IGNORE 1 LINES\n```","categories":["DataBase"],"tags":[]},{"title":"importantFunctions","url":"/posts/30183/","content":">对一些值得积累的函数、操作进行了积累\n<!--more-->\n# 长整数加法器 Java\n```java\n    // 长整数加法器\n    private static String addLongInteger(String str, int num){\n            int ci = 0;\n        StringBuffer sb = new StringBuffer();\n        for(int i = str.length() -1 ; i>=0 ;i--){\n            int tempnum = (str.charAt(i) - 48) + ci +num;\n            ci = 0;\n            num = 0;\n            if (tempnum >= 10){\n                tempnum = tempnum %10;\n                ci ++;\n            }\n            sb.append(String.valueOf(tempnum));\n        }\n    return sb.reverse().toString();\n    }\n```\n# 文件上传操作\n```java\n/**\n * @author Wente\n * @date 2023/2/6\n * 和文件有关的操作\n **/\n@RestController\n@RequestMapping(\"/file\")\npublic class FileController {\n    @Value(\"${spring.servlet.multipart.location}\")\n    private String fileSavePath;\n    @Value(\"${server.servlet.context-path}\")\n    private String servletContextPath;\n    @PostMapping(\"/upload\")\n    public String upload(MultipartFile multipartFile, HttpServletRequest req){\n        // 1，保证本地的文件存储位\n        File filefolder = new File(fileSavePath);\n        if (!filefolder.isDirectory()){\n            filefolder.mkdirs();\n        }\n        // 2，文件重命名\n        String returnUrlPath = \"\";\n        try {\n            String oldName = multipartFile.getOriginalFilename();\n            String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf('.'),oldName.length());\n            // 3，返回文件访问路径\n            multipartFile.transferTo(new File(filefolder,newName));\n            returnUrlPath = req.getScheme() + \"://\" + req.getServerName() + \":\" +\n                    req.getServerPort() + servletContextPath +\"/images/\" + newName;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return JSON.toJSONString(ResultTool.failWithMessage(\"上传失败\"));\n        }\n        return JSON.toJSONString(ResultTool.successWithData(returnUrlPath));\n    }\n}\n```\n\n# 布隆过滤器\n## 依赖\n```xml\n<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-data-redis</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.apache.commons</groupId>\n\t\t\t<artifactId>commons-pool2</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t    <groupId>com.google.guava</groupId>\n\t\t    <artifactId>guava</artifactId>\n\t\t    <version>30.1-jre</version>\n\t\t</dependency>\n\t</dependencies>\n```\n## 过滤器源码\n```java\n/**\n * @author Wente\n * @date 2023/2/7\n * 给Redis加上一层布隆过滤器\n **/\n@Component\npublic class RedisBloomFilter {\n\n    /**\n     * \t二进制位大小（多少位）\n     */\n    private Long numBits ;\n    /**\n     * \thash函数个数\n     */\n    private Integer numHashFunctions ;\n\n    private Funnel<CharSequence> funnel = Funnels.stringFunnel(Charset.forName(\"UTF-8\")) ;\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate ;\n    @Value(\"${bf.expected-insertions}\")\n    private Long expectedInsertions;\n    @Value(\"${bf.fpp}\")\n    private Double fpp;\n\n\n    @PostConstruct\n    public void initRedisBloomFilter() {\n        this.numBits = optimalNumOfBits(expectedInsertions, fpp) ;\n        this.numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits) ;\n    }\n\n    /**\n     *  <p>\n     *  \t最佳的位数（二进制位数）\n     *  </p>\n     *  <p>时间：2021年2月7日-上午10:13:43</p>\n     * @author xg\n     * @param expectedInsertions 预期插入的数量\n     * @param fpp 错误率大于0，小于1.0\n     * @return long\n     */\n    public long optimalNumOfBits(long expectedInsertions, double fpp) {\n        if (fpp == 0) {\n            fpp = Double.MIN_VALUE;\n        }\n        return (long) (-expectedInsertions * Math.log(fpp) / (Math.log(2) * Math.log(2)));\n    }\n\n    /**\n     *  <p>\n     *  \t最佳的Hash函数个数\n     *  </p>\n     *  <p>时间：2021年2月7日-上午10:17:26</p>\n     * @author xg\n     * @param expectedInsertions 预期插入的数量\n     * @param numBits 根据optimalNumOfBits方法计算的最佳二进制位数\n     * @return int\n     */\n    public static int optimalNumOfHashFunctions(long expectedInsertions, long numBits) {\n        return Math.max(1, (int) Math.round((double) numBits / expectedInsertions * Math.log(2)));\n    }\n\n    /**存数据*/\n    public boolean put(String key, String value) {\n        byte[] bytes = Hashing.murmur3_128().hashObject(value, funnel).asBytes();\n        long hash1 = lowerEight(bytes);\n        long hash2 = upperEight(bytes);\n\n        boolean bitsChanged = false;\n        long combinedHash = hash1;\n        for (int i = 0; i < numHashFunctions; i++) {\n            long bit = (combinedHash & Long.MAX_VALUE) % numBits ;\n            // 这里设置对应的bit为1\n            stringRedisTemplate.opsForValue().setBit(key, bit, true) ;\n            combinedHash += hash2;\n        }\n        return bitsChanged;\n    }\n\n    /**判断数据是否已经存在*/\n    public boolean mightContain(String key, String value) {\n        byte[] bytes = Hashing.murmur3_128().hashObject(value, funnel).asBytes();\n        long hash1 = lowerEight(bytes);\n        long hash2 = upperEight(bytes);\n\n        long combinedHash = hash1;\n        for (int i = 0; i < numHashFunctions; i++) {\n            long bit = (combinedHash & Long.MAX_VALUE) % numBits ;\n            // 这里判断redis中对应位是否为1\n            if (!stringRedisTemplate.opsForValue().getBit(key, bit)) {\n                return false;\n            }\n            combinedHash += hash2;\n        }\n        return true;\n    }\n\n    private long lowerEight(byte[] bytes) {\n        return Longs.fromBytes(bytes[7], bytes[6], bytes[5], bytes[4], bytes[3], bytes[2], bytes[1], bytes[0]);\n    }\n\n    private long upperEight(byte[] bytes) {\n        return Longs.fromBytes(bytes[15], bytes[14], bytes[13], bytes[12], bytes[11], bytes[10], bytes[9], bytes[8]);\n    }\n}\n```\n## 相关配置\n```yml\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    password: \n    database: 3 \n    lettuce:\n      pool:\n        maxActive: 8\n        maxIdle: 100\n        minIdle: 10\n        maxWait: -1\n# 自定义相关的属性配置          \nbf:\n  expected-insertions: 10001\n  fpp: 0.01     \n```","categories":["Accumulate"],"tags":["Functions"]},{"title":"JavaIO","url":"/posts/20622/","content":"> 总结了关于JavaIO的知识点\n<!--more-->\n\n# Java Input\n```java\n    String inputpath=\"D:\\\\AAA\\\\txt\\\\code.txt\";\n    File file = new File(inputpath);\n    FileReader fileReader = new FileReader(file);\n    // 使用BufferReader读取\n    BufferedReader bufferedReader = new BufferedReader(fileReader);\n    String line = null;\n    // 按行读取\n    while ((line = bufferedReader.readLine()) !=null){\n        System.out.println(line);\n    }\n    // 读取第一个字符，并且返回其Ascall码值\n    int read = bufferedReader.read(); \n```\n\n# Java Output\n```java\n    public static void main(String[] args) throws IOException {\n        String hello = \"time23\";\n        String outputStreamFilePath=\"D:\\\\AAA\\\\txt\\\\demo.txt\";\n        File file=new File(outputStreamFilePath);\n\n        FileWriter fileWriter = new FileWriter(outputStreamFilePath, true);\n        fileWriter.write(hello);\n        fileWriter.close();\n        //以FileWriter作为参数，不换行写入\n        BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\n        bufferedWriter.write(hello);\n        //以FilterWriter为参数，换行与不换行写入\n        PrintWriter printWriter = new PrintWriter(fileWriter);\n        printWriter.println(hello);\n        printWriter.print(hello);\n        printWriter.close();\n    }\n\n```\n# JavaIO的集中输入输出流的比较\n>* FileReader和Filewriter可以作为Buffer类的参数\n>* BufferedReader和BufferedWriter在内存中会自带一个8kb的字节缓冲区\n>* Buffer同样可以传入File类\n>* PrintWriter的print、println方法可以接受任意类型的参数，而BufferedWriter的write方法只能接受字符、字符数组和字符串\n>* PrintWriter不但能接收字符流，也能接收字节流。\n","categories":["JavaStudy"],"tags":["IO"]},{"title":"C-Process-API","url":"/posts/5/","content":">总结了关于C语言对进程控制的一些语句\n<!--more-->\n# 进程标识\n* getpid函数：获取调用该函数进程的进程ID。    \n* getppid函数：获取调用该函数进程的父进程ID。  \n* getuid函数：获取调用该函数进程的实际用户ID，一般在没有调用setuid函数（此\n 数不讲）进行修改进程对应的程序文件所属用户的情况下，该用户ID就等于当初运行\n 该程序时的用户ID。  \n* geteuid函数：获取调用该函数进程的有效用户ID，一般在没有调用seteuid函数进行修\n 改前，该用户ID就等于当初的运行该程序时的有效用户ID。  \n* getgid函数：获取调用该函数进程的实际组ID，一般在没有调用setgid函数进行修改\n 前，该用户组ID就等于当初运行该程序时的组ID。  \n* getegid函数：获取调用该函数进程的有效组ID，一般在没有调用setegid函数进行修改 前，该用户ID就等于当初运行该程序时的有效组ID。\n```c\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdio.h>\nint main(void)\n{\n        //执行当前函数的进程ID\n        printf(\"pid  = %d\\n\", getpid());\n        //调用该函数的父进程ID\n        printf(\"ppid = %d\\n\\n\", getppid());\n\n        //调用该函数的实际用户ID\n        printf(\"uid  = %d\\n\", getuid());\n        //调用该函数的有效用户ID\n        printf(\"euid = %d\\n\\n\", geteuid());\n\n        // 调用该函数的实际组ID\n        printf(\"gid  = %d\\n\", getgid());\n        // 调用该函数的有效组ID\n        printf(\"egid = %d\\n\", getegid());\n\n        return 0;\n}\n\n```","categories":["C/CPP"],"tags":["Process"]},{"title":"C-open-write","url":"/posts/22783/","content":"> 总结了关于C语言的IO\n<!--more-->\n\n```c\n#include<stdlib.h>\n#include<string.h>\n#include<stdio.h>\nint main(int argc, char* argv[]){\n  char rootline[1024] = \"/root/os_process_shell/code/\";\n  FILE *file;\n  FILE *wfile;\n  char words[1024][1024];\n  int i = 0;\nif(argc >= 1){\n        strcat(rootline,argv[1]);\n        // open file\n        file = fopen(rootline,\"r\");\n        // 逐行读取\n        while(!feof(file)){\n        fgets(words[i],1000,file);\n        i++;\n        }\n}\n// write in txt file    \n  wfile = fopen(\"./word.txt\",\"w\");\n  int j = 0;\n  // 逐行写入\n  while(i>=0){\n        fwrite(words[j],sizeof(words[j]),1,wfile);\n        i--;\n        j++;\n}\n  return 0;\n}\n```\n<img src = \"http://xtzl.wentexl.cn/c_open_write.png\">","categories":["C/CPP"],"tags":[]},{"title":"Sqlserver-Grant","url":"/posts/20431/","content":">总结了关于权限管理的sql语句\n<!--more-->\n# 授予权限\n```sql\n-- 授予wente所有权限\ngrant all privileges on goods to wente\n\n-- 授予dbuser2 查询和修改Goods表的权限\n-- with grant option 表示是否可以把该权限授予其他用户\ngrant select,update on Goods to dbuser2 with grant option\n\n-- 授予dbuser2创建表和视图的权限\ngrant create table,create view to dbuser2\n```\n\n# 禁止权限\n```sql\n-- 禁止guest用户对Goods表进行crud的操作\ndeny select,insert,update, delete on Goods to guest\n```\n\n# 撤销权限\n```sql\n-- 撤销dbuser2对Goods表的查询和更新的权限\nrevoke select,update on Goods from dbuser2\n```\n# 查询权限信息\n```sql\n-- 查看用户名为dbuser2所拥有的权限\nExecute sp_helprotect @username = 'dbuser2'\n\n-- 查询获得某个权限的用户信息\nExecute sp_helprotect @name = 'create view'\n```\n","categories":["DataBase"],"tags":[]},{"title":"Caffeine","url":"/posts/46615/","content":"> 本文主要介绍了关于Caffeine的用法，仅限于如何使用Caffeine\n<!--more-->\n# Caffeine简介\n>Caffeine是一种在本地进行本地缓存的缓存库，可以使用它来搭建本地缓存  \n>可使用它构建本地缓存+Redis的多级缓存机制  \n>Caffeine提供了四种缓存添加策略：\n>* 手动加载\n>* 自动加载\n>* 手动异步加载\n>* 自动异步加载\n\n \n\n # 手动加载\n ```java\n  @Test\n    public void test1(){\n        Cache<String, String> cache = Caffeine.newBuilder()\n                //设置数据过期时间\n                .expireAfterWrite(10, TimeUnit.MINUTES)\n                //设置数据的最大长度\n                .maximumSize(10_000)\n                .build();\n\n        String key = \"key1\";\n\n        // 根据key查找一个缓存元素， 没有查找到的时候返回null\n                String value = cache.getIfPresent(key);\n        // 根据key查找缓存，如果缓存存在，则返回对应缓存值，如果缓存不存在则生成缓存元素,如果无法生成则返回nul\n                String value2 = cache.get(key, this::createValueByKey);\n\n        // 添加一个缓存元素\n                cache.put(\"key2\",\"xtzl\");\n                String value_key2 = cache.getIfPresent(\"key2\");\n                Assertions.assertEquals(\"xtzl\",value_key2);\n\n        // 移除一个缓存元素\n                cache.invalidate(\"key2\");\n                value_key2 = cache.getIfPresent(\"key2\");\n                Assertions.assertNull(value_key2);\n    }\n\n    // 没查到缓存之后生成缓存元素的方法,生成并自动加入到Cache中\n    private String createValueByKey(String key){\n        return key+\"_value\";\n    }\n ```\n\n # 自动加载\n ```java\n     @Test\n    public void test(){\n        LoadingCache<String, String> cache = Caffeine.newBuilder()\n                .maximumSize(10_000)\n                .expireAfterWrite(10, TimeUnit.MINUTES)\n                .build(this::createExpensiveGraph);\n        // 往缓存中存入数据\n            cache.put(\"key2\",\"value2\");\n        // 查找缓存，若存在则返回对应缓存值，如果缓存不存在则调用指定方法生成指定缓存值,  如果无法生成则返回null\n            String val_key1 = cache.get(\"key1\");\n            String val_key2 = cache.get(\"key2\");\n        // 批量查找缓存，如果缓存不存在则生成缓存元素\n            //模拟加入多个缓存元素\n            List<String> cacheKeyList= new ArrayList<String>();\n            for (int i = 1; i <= 5; i++) {\n                cache.put(\"k\" + i,\"v\" + i);\n                cacheKeyList.add(\"k\"+i);\n            }\n            Map<String, String> cacheAll = cache.getAll(cacheKeyList);\n\n            // 验证是否正常生成\n            Assertions.assertEquals(\"key1_cache_value\", val_key1);\n            Assertions.assertEquals(\"value2\",val_key2);\n            for (int i = 1; i <= 5; i++) {\n                Assertions.assertEquals(\"v\"+i,cacheAll.get(\"k\"+i));\n            }\n    }\n\n    private String createExpensiveGraph(String key){\n        return key+\"_cache_value\";\n    }\n \n ```\n\n # 手动加载与自动加载的区别\n >* 手动加载在Caffeine.newBuilder()中未指定创建缓存值的方法\n >* 手动加载将 getIfPresent() 和 get()方法区分开\n >* 手动加载在get()方法需要指定创建缓存值的方法    \n\n >总结：\n 个人感觉还是自动加载方便。因为在build我们的Cache的时候就已经指定了创建缓存值的方法\n\n# 手动异步加载\n```java\npublic class TestManualAsynchronous {\n    @Test\n    public void test() throws ExecutionException, InterruptedException {\n        AsyncCache<String, String> cache = Caffeine.newBuilder()\n                .expireAfterWrite(10, TimeUnit.MINUTES)\n                .maximumSize(10_000)\n                .buildAsync();\n\n            String key = \"key1\";\n        // 查找一个缓存元素， 没有查找到的时候返回null\n            CompletableFuture<String> key_value = cache.getIfPresent(key);\n        // 查找缓存元素，如果不存在，则异步生成对应key的缓存值\n            CompletableFuture<String> key_get_value = cache.get(key, this::createExpensiveGraph);\n        // 添加或者更新一个缓存元素\n            cache.put(key, key_get_value);\n        // 移除一个缓存元素\n        CompletableFuture<String> key3_value = cache.get(\"key3\", this::createExpensiveGraph);\n        cache.put(\"key3\",key3_value);\n        // 也要先转成同步的之后才移除\n        cache.synchronous().invalidate(\"key3\"); \n        CompletableFuture<String> key3_del = cache.getIfPresent(\"key3\");\n        // 验证\n        Assertions.assertNull(key_value);\n        // join()或者get()方法是得到字符串类型的值\n        Assertions.assertEquals(\"key1_value\",key_get_value.join()); \n        Assertions.assertNull(key3_del);\n    }\n    // 根据key创建对应的缓存元素，并自动加入到缓存Cache中\n    private String createExpensiveGraph(String key){\n        return key+\"_value\";\n    }\n}\n```\n# 自动异步加载\n```java\n    @Test\n    public void test() throws ExecutionException, InterruptedException {\n        AsyncLoadingCache<String, String> cache = Caffeine.newBuilder()\n                .maximumSize(10_000)\n                .expireAfterWrite(10, TimeUnit.MINUTES)\n                // 你可以选择: 去异步的封装一段同步操作来生成缓存元素\n                .buildAsync(this::createExpensiveGraph);\n            /** 也可以选择: 构建一个异步缓存元素操作并返回一个future\n                .buildAsync((key, executor) -> createExpensiveGraphAsync(key, executor));\n            */\n        String key = \"key1\";\n        // 查找缓存元素，如果其不存在，将会异步进行生成\n        CompletableFuture<String> key1_value = cache.get(key);\n\n        // 批量查找缓存元素，如果其不存在，将会异步进行生成\n        String [] keys = {\"k1\",\"k2\",\"k3\"};\n        List<String> keysList = Arrays.asList(keys);\n        CompletableFuture<Map<String, String>> keys_values_map = cache.getAll(keysList);\n        // 将CompletableFuture类型获取到其中的Map\n        Map<String, String> map = keys_values_map.get();\n        // 将Map中的元素提取成Set集合，元素为Entry类型，并使用Set集合的迭代器迭代遍历\n        Set<Map.Entry<String, String>> entries = map.entrySet();\n        Iterator<Map.Entry<String, String>> iterator = entries.iterator();\n        while (iterator.hasNext()){\n            Map.Entry<String, String> next = iterator.next();\n            System.out.println(next.getKey());\n            System.out.println(next.getValue());\n        }\n    }\n    private String createExpensiveGraph(String key){\n        return key+\"_value\";\n    }\n```\n# 同步和异步的差别\n>* 移除缓存元素，同步直接调用invalidate()就可移除，异步需要先使用synchronous()转成同步之后才能调用invalidate()移除元素\n>* get() 和 getIfPresent()方法在同步中直接返回的是缓存值，在异步方法中返回的是CompletableFuture类型的数据，CompletableFuture类型的数据需要执行join()或者get()方法才能获取到真正的缓存值\n\n\n# CacheLoader\n> CacheLoader共可实现6个方法\n>* load\n>* loadall\n>* asyncload\n>* asyncloadall\n>* reload\n>* asyncReload\n```java\n LoadingCache<String, Object> cache = Caffeine.newBuilder()\n        .maximumSize(10_000)\n        .expireAfterWrite(10, TimeUnit.MINUTES)\n        .build(new CacheLoader<String, Object>() {\n            @Override\n            // 调用get方法，若在缓存未命中，则生成一个缓存值\n            public @Nullable Object load(@NonNull String s) throws Exception {\n                return s + \"_value\";\n            }\n        });\n```\n\n# 注解的使用\n## 引入依赖\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n<dependency>\n    <groupId>com.github.ben-manes.caffeine</groupId>\n    <artifactId>caffeine</artifactId>\n</dependency>\n```\n## 常用注解\n>- - -\n* @Cacheable：表示该方法支持缓存。当调用被注解的方法时，如果对应的键已经存在缓存，则不再执行方法体，而从缓存中直接返回。当方法返回null时，将不进行缓存操作。\n>- - -\n* @CachePut：表示执行该方法后，其值将作为最新结果更新到缓存中，每次都会执行该方法。\n>- - -\n* @CacheEvict：表示执行该方法后，将触发缓存清除操作。\n>- - -\n* @Caching：用于组合前三个注解，例如：\n```java\n@Caching(cacheable = @Cacheable(\"CacheConstants.GET_USER\"),\n         evict = {@CacheEvict(\"CacheConstants.GET_DYNAMIC\",\n         allEntries = true)})\n```\n>- - -\n# 多级缓存(二级缓存)的逻辑实现图\n>* 要求一级缓存的数据过期时间要比二级缓存短\n>* 我的项目中，Caffeine缓存时间是30s，redis缓存时间是3分钟\n<img src = \"http://xtzl.wentexl.cn/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E9%80%BB%E8%BE%91.png\"/>","categories":["TechStack"],"tags":["Cache"]},{"title":"Sqlserver_TSQL","url":"/posts/4967/","content":">Transction-Sql的积累，主要是与事务，流程相关的东西\n<!--more-->\n```sql\n-- 游标的使用场景:\n-- 数据表有几千万数据，需要就其中约百万数据进行更新，不能锁表。因此采用游标进行更新\n\n-- 1.游标查询\n-- 建立scroll滚动游标\n-- 定义游标,scroll是参数，cursor是固定的定义格式\ndeclare cur scroll cursor for\n\tselect * from goods join category on goods.categoryno = category.categoryno where category.categoryname = '洗发水'\n-- 打开游标\nopen cur\n-- 游标指向上面查询出来的表的第一条数据\nfetch first from cur \n-- 指向最后一条\nfetch last from cur\n-- 从上往下数，第十条数据（绝对的）\nfetch absolute 10 from cur\n-- 从当前游标所在的位置往后数的第五个数据 （相对于当前游标所在位置，是相对的）\nfetch relative 5 from cur\n-- 固定格式，关闭游标\nclose cur\ndeallocate cur\n\n\n-- 2.游标更新\ndeclare @Id char(6); -- 声明临时变量\n-- 声明更新游标\ndeclare cur_up scroll cursor for \n\t(select goodsno from goods join category on goods.categoryno = category.categoryno where category.categoryname = '咖啡') for update of saleprice;\nopen cur_up;\nfetch next from cur_up\ninto @Id;\nwhile @@FETCH_STATUS = 0\nbegin\n\tupdate goods set saleprice = saleprice *0.9 where goods.goodsno = @Id\n\t-- 切换\n\tfetch next from cur_up\n\tinto @Id\nend;\nclose cur_up\ndeallocate cur_up\n\n\n-- 触发器的使用场景：当需要删除与多表之间相连的数据，但又不想使用级联的时候\n-- 由系统调用，我们也需要表明调用的实际和规则\n\n-- 3.触发器实现商品的购买\ncreate trigger sale_trigger\non\tsalebill\nafter insert as\ndeclare @changenum int\ndeclare @change_goodsno char(6)\n\nselect @changenum = number from inserted \nselect @change_goodsno = goodsno from inserted\nbegin\n\tupdate goods set number = (number - @changenum) where goods.goodsno = @change_goodsno\nend\n\n-- 激活对应表中某个触发器,如果要激活所有的，就把触发器名改为all\nalter table salebill enable trigger sale_trigger\n\n-- 实行购买操作，向saleprice表中增加购买记录\ninsert into salebill values('gn001','s01','2022-10-25 17:18:00',2);\n\nselect * from salebill join  goods on salebill.goodsno = goods.goodsno\nselect * from goods\n\n\n-- 4.触发器实现删除类别信息的时候同时删除商品表中对应类别编号设置为其他类别\ncreate trigger category_trigger \non category \nafter delete as\ndeclare @del_categoryno char(6)\nselect @del_categoryno = categoryno from deleted\n\nbegin\n\tupdate goods set categoryno = 'cn006' where goods.categoryno = @del_categoryno\nend\n\nalter table category enable trigger category_trigger\n\n-- 执行删除类别信息的操作\ndelete from category where category.categoryno = 'cn005'\n\nselect * from category\nselect * from goods\n\n-- 5.创建触发器：实现在供应商表Supplier中删除供货商时，同时删除该供货商所供应的商品信息及商品的销售记录。\ncreate trigger supplier_trigger\non supplier \ninstead of delete as\ndeclare @sup_no char(6)\n\n-- 值\nselect @sup_no = supplierno from deleted\nbegin\n\tdelete from salebill where salebill.goodsno in \n\t(select goodsno from goods where goods.supplierno = @sup_no)\n\n\tdelete from goods where goods.supplierno = @sup_no\n\tdelete from supplier where supplier.supplierno = 'sup002'\nend\n\nalter table supplier enable trigger supplier_trigger\n\nselect * from supplier join goods on goods.supplierno = supplier.supplierno join salebill on salebill.goodsno = goods.goodsno\nselect * from salebill\n\n-- 6.创建触发器：向销售表SaleBill中插入一条记录时，这个触发器将更新商品表Goods。要求：Goods表中数量为原有数量减去销售数量\n--\t  如果库存数量小于10，则提示“该商品数量小于10，低于安全库存量，请及时进货”；如果原有数量不足，则提示“数量不足！”\n\ncreate trigger saleprint_goods\non salebill\nafter insert as \ndeclare @sale_goodsno char(6)\ndeclare @change_number int\ndeclare @now_number int\ndeclare @end_number int \n\nselect @sale_goodsno = goodsno,@change_number = number from inserted\nselect @now_number = number from goods where goodsno = @sale_goodsno\nset @end_number = @now_number - @change_number\n\nbegin\n\tif(@end_number < 10 and @end_number>=0 )\n\t\tprint('该商品数量小于10，低于安全库存量，请及时进货')\n\telse if( @end_number < 0)\n\t\tprint('数量不足')\n\telse\n\t\tupdate goods set number = @end_number where goods.goodsno = @sale_goodsno\nend\n-- 激活触发器\nalter table salebill enable trigger saleprint_goods\n-- 执行插入命令\ninsert into salebill values('gn005','s05','2022-10-26 11:16:00',1)\ninsert into salebill values('gn005','s05','2022-10-26 11:16:00',4)\ninsert into salebill values('gn007','s05','2022-10-26 11:16:00',2)\n\nselect * from salebill join goods on goods.goodsno = salebill.goodsno\n\n```","categories":["DataBase"],"tags":[]},{"title":"Sqlserver_View","url":"/posts/46353/","content":">主要讲的是视图创建的东西\n<!--more-->\n\n```sql\nuse supermarket_Insert\n-- 1.\ncreate view V_MIS as select * from student where major = 'MIS'\n\nselect * from V_MIS\n\n--2.\ncreate view V_SSG as \nselect student.sno,student.sname,goods.goodsname,goods.saleprice,salebill.number \nfrom student \njoin salebill \non student.sno = salebill.sno \njoin goods on \ngoods.goodsno = salebill.goodsno\n\n\n-- 3.\ncreate view V_AGE as \nselect *,\n\t(2020 - student.birthyear) as age\nfrom\n\tstudent\n\nselect * from V_AGE\n\n-- 4.\ncreate view V_COM as\nselect\n\tstudent.college,\n\tcount(*) counts_num,\n\tAVG(2020-student.birthyear) avg_age\nfrom \n\tstudent\ngroup by\n\tstudent.college\n\nselect * from V_COM\n\n-- 5.\ncreate view V_S_CONSUME as\nselect\n\tstudent.sno,\n\tSUM(goods.saleprice * salebill.number) cost_all,\n\tcount(distinct goods.categoryno) goods_category_counts\nfrom\n\tstudent\njoin\n\tsalebill\non\n\tstudent.sno = salebill.sno\njoin\n\tgoods\non\n\tgoods.goodsno = salebill.goodsno\ngroup by\n\tstudent.sno\n\nselect * from V_S_CONSUME\n\n\n--6 .\ncreate view V_GOOODS as \nselect\n\tgoods.categoryno,\n\tcount(*) goods_num,\n\tAVG(goods.saleprice) avg_price,\n\tmin(goods.number) min_number\nfrom\n\tgoods\ngroup by\n\tgoods.categoryno\n\t\nselect * from V_GOOODS\n\n-- 7.\ncreate view V_SU_GOOD as\nselect\n\tgoods.supplierno,\n\tsum(goods.number) goods_counts_rest_sum,\n\tAVG(goods.inprice) goods_inprice_avg,\n\tsum(case when salebill.goodsno is null then goods.number else goods.number+salebill.number end) goods_counts_all_sum\nfrom\n\tgoods\nleft join\n\tsalebill\non\n\tgoods.goodsno = salebill.goodsno\ngroup by\n\tgoods.supplierno\n\nselect * from V_SU_GOOD\n\n-- 8.\nselect \n\t*\nfrom\n\tV_COM\nwhere\n\tavg_age > 19\n\n-- 9.\nselect * from\n\tV_S_CONSUME\nwhere\n\tcost_all > 20\n\n-- 10.\nselect\n\tsupplier.suppliername,\n\tsupplier.number,\n\tsupplier.address\nfrom\n\tV_SU_GOOD\njoin\n\tsupplier\non\n\tsupplier.supplierno = V_SU_GOOD.supplierno\nwhere\n\tgoods_counts_rest_sum < 50\n\n-- 11.\ninsert into V_MIS values('s09','宋江','2000','男','CS','MIS','wx009')\n\nselect * from V_MIS\n\n-- 12.\ninsert into V_MIS values('s10','周瑜','1999','男','CS','IT','wx010')\nselect * from V_MIS\nselect * from student\n\n-- 13.\nupdate V_MIS set sname = '李欢欢' where sno = 's01'\n\n-- 14.\nupdate V_MIS set sname = '徐慧慧' where sno = 's02'\nselect * from V_MIS\n\n-- 15.\nupdate V_SSG set saleprice = 10 where sname = '力神咖啡'\nselect * from V_SSG\n\n-- 16.\ndelete from V_MIS where sno = 's09'\nselect * from V_MIS\n\n-- 17.\ndelete from V_MIS where sno = 's10'\nselect * from V_MIS\nselect * from student\n\n```","categories":["DataBase"],"tags":[]},{"title":"Sqlserver_DQL","url":"/posts/19382/","content":">关于数据查询语言的修改\n<!--more-->\n```sql\nuse supermarket;\n\n\n--1 \nselect * from goods\n\n--2 条件查询\nselect\n\t* \nfrom\n\tgoods\nwhere\n\tgoods.categoryno = 'cn002'\n\n--3 条件查询\nselect\n\t*\nfrom\n\tgoods\nwhere\n\tgoods.categoryno = 'cn001'\n\tor\n\tgoods.categoryno = 'cn002'\n\n\n--4 条件查询\nselect\n\t*\nfrom\n\tgoods\nwhere\n\tgoods.inprice > 20\nand\n\tgoods.categoryno = 'cn005'\n\n\n--5 内连接查询\nselect\n\tgoods.goodsno,\n\ts.supplierno,\n\tgoods.goodsname,\n\tgoods.number\nfrom\n\tgoods\njoin\n\tsupplier s\non\n\tgoods.supplierno = s.supplierno\nwhere\n\tgoods.number < 10\n\n\n--6 左外连接查询\nselect\n\tstu.sno\nfrom\n\tstudent stu\nleft join\n\tsalebill\non\n\tsalebill.sno = stu.sno\nwhere\n\tsalebill.goodsno is not null\n\n--7 条件查询\nselect\n\tstu.sno,\n\tstu.sname,\n\t(2022-stu.birthyear) age\nfrom\n\tstudent stu\nwhere\n\tstu.major = 'IT'\n\n--8 条件查询\nselect\n\tstu.sno,\n\tstu.sname,\n\tstu.college,\n\tstu.major,\n\t(2022- stu.birthyear) age\nfrom\n\tstudent stu\nwhere\n\t(2022- stu.birthyear) >= 22\nand\n\t(2022- stu.birthyear) <= 24\n\n--9 模糊查询\nselect\n\tstu.sno,\n\tstu.sname,\n\tstu.college\nfrom\n\tstudent stu\nwhere\n\tstu.sname like '张%'\n\n--10 排序查询\nselect\n\t*\nfrom\n\tgoods\nwhere\n\tgoods.number > 20\norder by \n\tgoods.number DESC\n\n\n--11 条件查询，排序查询\nselect\n\tgoods.goodsno,\n\tgoods.goodsname,\n\tgoods.categoryno,\n\tgoods.number\nfrom\n\tgoods\nwhere\n\tgoods.number <= 10\norder by\n\tgoods.categoryno ASC,\n\tgoods.number DESC\n\n\n\n\n--12.top的使用,解决了并列问题\nselect\n\ttop 3 *\nfrom\n\tgoods\nwhere\n\tgoods.number in (\n\t\tselect\n\t\t\ttop 3 number\n\t\tfrom\n\t\t\tgoods\n\t)\norder by goods.number DESC\n\n\n--13. 子查询\nselect\n\tgoods.goodsno,\n\tgoods.goodsname,\n\tgoods.number\nfrom\n\tgoods\njoin\n\tcategory\non\n\tgoods.categoryno = category.categoryno\nwhere\n\tcategory.categoryno = 'cn001'\nand\n\tgoods.number = (select max(number) from goods)\n\n--14.条件查询\nselect\n\tcount(*) countStu\nfrom\n\tstudent\nwhere\n\tstudent.major = 'MIS'\n\t\n\n\n--15. 分组查询\nselect\n\tstudent.college,\n\tcount(*) countAge\nfrom\n\tstudent\nwhere\n\t(2022 - student.birthyear) >= 20\ngroup by\n\tcollege\n\n--16.内连接查询\nselect\n\tgoods.goodsno,\n\tgoods.goodsname,\n\tsum(salebill.number) salecounts\nfrom\n\tsalebill\njoin \n\tgoods\non\n\tgoods.goodsno = salebill.goodsno\nwhere\n\tsalebill.happentime > CONVERT(date,'2018-01-01 00:00:00')\nand\n\tsalebill.happentime < CONVERT(date,'2019-01-01 00:00:00')\ngroup by\n\tgoods.goodsno,\n\tgoods.goodsname\n\n\n--17. having子句\nselect\n\tcollege,\n\tCOUNT(*) counts\nfrom\n\tstudent \ngroup by\n\tcollege\nhaving\n\tcount(*) > 3\n\n\n--18.派生表查询\nselect\n\tstu.sno,\n\tstu.sname,\n\tsalenum.countsnum\nfrom\n\tstudent stu,\n\t(\n\t\tselect\n\t\t\tsum(salebill.number) countsnum\n\t\tfrom\n\t\t\tsalebill\n\t\tjoin\n\t\t\tstudent\n\t\ton student.sno = salebill.sno\n\t\twhere\n\t\t\tsalebill.happentime > CONVERT(date,'2019-01-01 00:00:00')\n\t\tand\n\t\t\tsalebill.happentime < CONVERT(date,'2020-01-01 00:00:00')\n\t\tgroup by\n\t\t\tstudent.sno\n\t) salenum\nwhere\n\tsalenum.countsnum > 5\n\n-- 19.内连接查询\nselect\n\tAVG(goods.saleprice) avg_sale_price\nfrom\n\tgoods\njoin\n\tcategory\non\n\tgoods.categoryno = category.categoryno\nwhere\n\tcategory.categoryname = '咖啡'\n\n--20.相关子查询\nselect\n\tsno,\n\tsname,\n\tcollege\nfrom\n\tstudent stu\nwhere\n\tstu.college = (\n\t\tselect\n\t\t\tcollege\n\t\tfrom\n\t\t\tstudent\n\t\twhere\n\t\t\tstudent.sname = '张小红'\n\t)\n\n\n-- 21.内连接查询\nselect\t\n\tg.goodsno,\n\tg.goodsname,\n\tstu.sno,\n\tstu.sname,\n\ts.happentime,\n\ts.number\nfrom\n\tgoods g\njoin\n\tsalebill s\non\n\tg.goodsno = s.goodsno\njoin \n\tstudent stu\non\n\tstu.sno = s.sno \norder by\n\ts.happentime DESC\n\n-- 22. 内连接查询\nselect\n\tstu.sno,\n\tstu.sname,\n\tstu.college\nfrom\n\tstudent stu\njoin\n\tsalebill\non\n\tsalebill.sno = stu.sno\n\n\n--23. 内连接查询\nselect\n\tstu.sno,\n\tstu.sname,\n\tstu.college\nfrom\n\tstudent stu\njoin\n\tsalebill\non\n\tstu.sno = salebill.sno\njoin\n\tgoods\non\n\tgoods.goodsno = salebill.goodsno\njoin\n\tcategory\non\n\tgoods.categoryno = category.categoryno\nwhere\n\tcategory.categoryname = '咖啡'\n\n\n-- 24.连接查询\nselect\n\tg.goodsno,\n\tgoodsname,\n\tc.categoryname,\n\tg.saleprice,\n\tg.number\nfrom\n\tgoods g\njoin \n\tcategory c\non\n\tg.categoryno = c.categoryno\nleft join\n\tsalebill s\non\n\tg.goodsno = s.goodsno\nwhere\n\ts.happentime is null\n\n\n--24.子查询\nselect\n\tg.goodsno,\n\tgoodsname,\n\tc.categoryname,\n\tg.saleprice,\n\tg.number\nfrom \n\tgoods g,\n\tcategory c\nwhere\n\tg.categoryno = c.categoryno\nand\n\tg.goodsno not in(\n\t\tselect\n\t\t\tgoodsno\n\t\tfrom\n\t\t\tsalebill\n\t)\n\n\t\n-- 25.同26题\nselect\n\tstudent.sno,\n\tsname,\n\tcollege\nfrom\n\tstudent\njoin \n\tsalebill\non\n\tstudent.sno = salebill.sno\nwhere\n\tsalebill.goodsno = 'gn001'\n\n-- 26.用内连接查询实现\nselect\n\tstudent.sno,\n\tsname,\n\tcollege\nfrom\n\tstudent\njoin \n\tsalebill\non\n\tstudent.sno = salebill.sno\nwhere\n\tsalebill.goodsno = 'gn001'\n\n\n-- 27.用子查询实现\nselect \n\tsno,\n\tsname,\n\tcollege\nfrom \n\tstudent\nwhere\n\tsno in (\n\t\tselect\n\t\t\tsno\n\t\tfrom\n\t\t\tstudent\t\n\t\twhere\n\t\t\tbirthyear in (\n\t\t\t\t\tselect\t\n\t\t\t\t\t\tmin(birthyear)\n\t\t\t\t\tfrom\n\t\t\t\t\t\tstudent\n\t\t\t\t\tgroup by\n\t\t\t\t\t\tcollege\n\t\t\t)\n\n\t)\n\n-- 27.用派生表实现\nselect \n\tsno,\n\tsname,\n\tstuM.college\nfrom \n\tstudent stuM,\n\t(select \n\t\tmin(stuN.birthyear) as birthyear,\n\t\tstuN.college\n\t from\n\t\tstudent stuN\n\t group by\n\t\tcollege\t\n\t\t) as stuP\nwhere\n\tstuM.birthyear = stuP.birthyear\nand \n\tstuM.college = stuP.college\n\n\n--28.用内连接查询\nselect\n\tg.goodsno,\n\tg.goodsname\n\t-- SUM(s.number) as counts\nfrom\n\tgoods g\njoin\n\tsalebill s\non\n\tg.goodsno = s.goodsno\ngroup by \n\tg.goodsno,\n\tg.goodsname\n\n-- 28.派生表查询\nselect\n\tg.goodsno,\n\tgoodsname,\n\tgs.counts_num\nfrom\n\tgoods g,\n\t(\n\tselect \n\t\tsum(number) as counts_num,\n\t\tgoodsno\n\t from\n\t\tsalebill\n\tgroup by \n\t\tsalebill.goodsno\n\t) gs\nwhere\n\tg.goodsno = gs.goodsno;\n\n--29. 派生表查询\nselect\n\tstu.sno,\n\tsname,\n\tcollege\nfrom\n\tstudent stu,\n\t(\n\tselect\n\t\tsno,\n\t\tsum(number) buy_counts\n\tfrom\n\t\tsalebill\n\twhere\n\t\thappentime < convert( date,'2020-01-01 00:00:00')\n\tand\n\t\thappentime > CONVERT(date,'2019-01-01 00:00:00')\n\tgroup by\n\t\tsno\n\t)sum_number\nwhere\n\tstu.sno = sum_number.sno\n\n\n--30.派生表\nselect\n\tsup.supplierno,\n\tsup.suppliername,\n\tsup.address\nfrom\n\tsupplier sup,\n\t(\n\tselect\n\t\tsupplierno,\n\t\tsum(number) sum_number\n\tfrom\n\t\tgoods\n\tgroup by\n\t\tsupplierno\n\t) sumgoods\nwhere\n\tsumgoods.sum_number > 50\nand \n\tsup.supplierno = sumgoods.supplierno\norder by \n\tsumgoods.sum_number DESC\n\n\n\n\n\t-- 导入新的sql\n\t-- 选做1\nselect\n\ttop 1 st.college,\n\tmax(c_sum) max_sum\nfrom\n\t(\n\tselect\n\t\tstu.college college,\n\t\tsum(salebill.number) c_sum\n\tfrom\n\t\tstudent stu\n\tjoin \n\t\tsalebill\n\ton stu.sno = salebill.sno\n\tgroup by \n\t\tstu.college\n\t) cs,\n\t\tstudent st\nwhere\n\tst.college = cs.college\ngroup by\n\tst.college\norder by\n\tmax_sum DESC\n```","categories":["DataBase"],"tags":[]},{"title":"Sqlserver_DML","url":"/posts/35774/","content":">关于数据操纵语言的积累\n<!--more-->\n```sql\nuse supermarket_Insert;\n\n-- 向goods表中添加数据\ninsert into goods values('GN0001','Sup001','CN001','优乐美奶茶',2.5,3.5,100,'2019-12-20')\ninsert into goods values('GN0002','Sup002','CN001','雀巢咖啡',4,5.8,50,'2017-06-08')\ninsert into goods values('GN0005','Sup003','CN002','飘柔洗发水',15,19.8,65,'2019-05-29')\ninsert into goods values('GN0007','Sup005','CN005','小绵羊被套',120,150,28,'2019-11-22')\n\n-- 向supplier表中添加数据\ninsert into supplier values('sup001','卡夫食品','广东佛山','12348768900')\ninsert into supplier values('sup002','久润食品','广东东莞','13248768901')\ninsert into supplier values('sup003','飞鹤食品','重庆解放碑','12648768901')\ninsert into supplier values('sup004','南山日化','重庆南坪','11648768903')\ninsert into supplier values('sup005','缙云日化','重庆北培','19648768903')\n\n-- 向Category表中添加数据\ninsert into category values('CN001','咖啡','速溶咖啡，袋装咖啡，咖啡粉')\ninsert into category values('CN002','洗发水','袋装，瓶装洗发水')\ninsert into category values('CN005','床上用品','被套，枕套,床单')\n\n-- 向student表中添加数据\ninsert into student values('S01','李明','1999','男','CS','IT','wx001')\ninsert into student values('S02','徐好','1998','女','CS','MIS','wx002')\ninsert into student values('S03','伍民','1996','男','CS','MIS','wx003')\ninsert into student values('S04','闵红','1997','女','ACC','AC','wx004')\ninsert into student values('S05','张小红','1997','女','ACC','AC','wx005')\n\n-- SaleBill表中添加数据\ninsert into salebill values('GN0001','S01','2020-06-09','3')\ninsert into salebill values('GN0001','S02','2020-05-03','1')\ninsert into salebill values('GN0001','S03','2020-04-07','1')\ninsert into salebill values('GN0002','S02','2020-05-08','2')\ninsert into salebill values('GN0002','S05','2020-06-26','2')\ninsert into salebill values('GN0005','S05','2020-06-01','1')\n\n\n-- mysql的多表联合修改\nUPDATE `daily_heath` d JOIN `stu_tea` s ON d.hea_id = s.hea_id SET d.peo_id = s.peo_id;\n\n-- 2.\nupdate goods set goodsname = '雀巢咖啡条a装' where goodsname = '雀巢咖啡'\n\n-- 3.\nupdate goods set saleprice = saleprice*1.05\n\n-- 4.\nupdate category set categoryno = 'CN004' where categoryno = 'CN005'\n\n-- 5.\nupdate goods set saleprice = saleprice*0.8 \nwhere goods.goodsno in\n(\tselect\n\t\tgoodsno\n\tfrom\n\t\tsalebill\n\twhere\n\t\tsalebill.number < 3\n\tand\n\t\tsalebill.happentime < '2021-01-01'\n\tand \n\t\tsalebill.happentime > '2020-01-01'\n)\n-- 6.\nupdate goods set number = 0 where supplierno = \n( select\n\tsupplierno\n  from\n\tsupplier\n  where\n\tsupplier.suppliername = '久润食品'\n)\n\n--7. \ndelete from salebill where salebill.number < 3 and salebill.goodsno = (\n\tselect\n\t\tgoodsno\n\tfrom\n\t\tgoods\n\twhere\n\t\tgoods.goodsname = '优乐美奶茶'\n)\n\n-- 8.\ndelete from goods where producttime < '2018-01-01' \nalter table salebill add constraint PK_sale_goods foreign key(goodsno) references goods(goodsno) on delete cascade\n\n-- 9.\ndelete from salebill where goodsno in (\n\tselect\n\t\tgoodsno\n\tfrom\n\t\tgoods\n\tjoin\n\t\tsupplier\n\ton\n\t\tgoods.supplierno = supplier.supplierno\n\twhere\n\t\tsupplier.suppliername = '卡夫食品')\n\n-- 10.\ndelete from salebill where salebill.sno in (\n\tselect\n\t\tsno\n\tfrom student\n\twhere\n\t\tstudent.college = 'ACC'\n)\n\n-- 11.\ndelete from salebill\ndelete from goods\n\n--12.\ndelete from student where student.birthyear < 1997\n\nupdate goods set categoryno = 'CN001' where goodsno = 'GN0002'\n\n\nselect * from salebill\nselect * from student\nselect * from goods\nselect * from category\nselect * from supplier\n\n\n```","categories":["DataBase"],"tags":[]},{"title":"Sqlserver_DDL","url":"/posts/56248/","content":">关键数据定义语言的sql语句\n<!--more-->\n```sql\ncreate database sqlserverdatabase;\nuse sqlserverdatabase;\n\n\n-- 货品表\n\ncreate table Goods(\n\tGoodsNo varchar(15) primary key,\n\tSupplierNO char(6),\n\tCategoryNO varchar(15),\n\tGoodsName varchar(10),\n\t-- 六位数，保留一位小数\n\tInPrice\tdecimal(6,1),\n\tSalePrice decimal(6,1),\n\tNumber int,\n\tProductTime date\n);\n\n\n-- 增加保质期属性列\nalter table Goods add QGperiod int;\n-- 修改Goods表“进价”属性列为精确数值型，总共七位，保留一位小数。\nalter table Goods alter column InPrice decimal(7,1)\n-- CategoryNO为外码，对Category表的主键\nalter table Goods add constraint outsidecode foreign key(CategoryNO) references Category(CategoryNO);\n\n-- 删除外键\nalter table Gooos drop foreign key outsidecode\n\nselect * from Goods;\nDELETE FROM Goods;\n\n-- 学生表\n/*==============================================================*/\n/* Table: Student                                               */\n/*==============================================================*/\ncreate table Student (\n   SNO                  varchar(15)                  not null,\n   SName                varchar(10)          null,\n   BirthYear            int                  null,\n   Gender               char(1)              null,\n   College              varchar(10)          null,\n   Major                varchar(10)          null,\n   WeiXin               varchar(20)          not null,\n   -- 添加主键约束\n   constraint PK_STUDENT primary key (SNO)\n);\n-- 添加WeiXin唯一值约束\nalter table Student add constraint WeixinUnique unique(WeiXin);\n-- 添加check约束\nalter table Student add constraint mycheckN check(Gender = '男' or Gender = '女')\n-- 删除student表中的出生年份这一列\nalter table Student drop column BirthYear;\n-- 删除表student的唯一值约束\nalter table Student drop WeixinUnique;\n\n\nselect * from Student;\n\n\n\n-- 销售表\ndrop table SaleBill;\n/*==============================================================*/\n/* Table: SaleBill                                              */\n/*==============================================================*/\ncreate table SaleBill (\n   GoodsNO              varchar(15)              not null,\n   SNO                  varchar(15)                  not null,\n   HappenTime           date                 null,\n   Number               int                  null,\n   constraint PK_SALEBILL primary key (GoodsNO,SNO)\n)\n-- 在表SaleBill上增加数量大于0的约束。\nalter table SaleBill add constraint numlimit check(Number > 0);\n-- 将表SaleBill上数量的约束修改为0~100。\nalter table SaleBill add constraint changedlimit check(Number >=0 and Number <=100)\n\n\n\n\n-- 商品种类表\n/*==============================================================*/\n/* Table: CategoryNO                                            */\n/*==============================================================*/\ncreate table Category (\n   CategoryNO           varchar(15)          not null,\n   CategoryName         varchar(15)          null,\n   Descriptions         varchar(100)         null,\n   constraint PK_CATEGORYNO primary key (CategoryNO)\n)\n\n-- 在Category表上，按商品类别编号属性列升序 和 商品类别名属性降序建立唯一值索引。\ncreate unique nonclustered index indexMO on Category(CategoryNO ASC,CategoryName DESC);\n\n-- 供应商表\n/*==============================================================*/\n/* Table: Supplier                                              */\n/*==============================================================*/\ncreate table Supplier (\n   SupplierNO           varchar(15)          not null,\n   SupplierName         varchar(15)          null,\n   Address              varchar(20)          null,\n   TelNumber               varchar(20)          null,\n   constraint PK_SUPPLIER primary key (SupplierNO)\n)\n\n-- 在表supplier表上，按供应商号 属性列的唯一值方式建立索引。\ncreate unique nonclustered index indexNO on Supplier(SupplierNO ASC); \n-- 删除supplier上的唯一值索引。\ndrop index indexNO on Supplier;\n\n\n```","categories":["DataBase"],"tags":[]},{"title":"Sqlserver_command","url":"/posts/27698/","content":"\n关于sqlServer的一些命令的创建\n\n<!--more-->\n# JavaType-Mapping-SqlType\n<img src = \"http://xtzl.wentexl.cn/%E6%96%87%E6%A1%A3.png\"> \n\n# Transact-SQL\n## 自定义数据类型\n```sql\n    -- 创建自定义数据类型\n    1, create type\n    例： create type goodsNO from varchar(20) Not NULL\n\n    2, sp_addtype\n    例： EXEC sp_addtype comment,text,NULL\n\n    -- EXEC ： 表示执行后面的存储过程\n    -- 删除自定义数据类型\n    1, sp_droptype \n    例： EXEC sp_droptype goodsNo\n\n    -- 查看自定义的comment的数据类型的相关信息\n    2, sp_help\n    例： EXEC sp_help comment\n```\n\n## 常量或变量\n```sql\n-- 常量\n日期常量：\n    '2/14/2018'  表示 2018 年 2月 14 日\n    '2018-1-19'  表示 2018 年 1月 19 日\n    'Mar 8,2018' 表示 2018 年 3月  8 日\n\n-- 局部变量\n-- 定义\ndeclare @local1 int\ndeclare @local2 char(5), @local3 float\n-- 赋值\nset @local1 = 56 -- 只可给单个变量赋值\nselect @local2 = 'world', @local3 = '34.2'\n-- 将table1表中local3为local1的值的数据，赋值给自定义的变量local2\nselect @local2  =  local3 from table1 where local2 = @local1\n\n-- 以文本形式输出\nprint(@local2)\n-- 以表格形式输出多个变量值\nselect @local2, @local3\n```\n\n## 流程控制语句\n```sql\n-- IF语句\ndeclare @in decimal(18,2), @sale decimal(18,2)\nselect @in = Inprice,@sale = SalePrice from goods where gooodsno = 'G001'\n\nIF @in > @sale\n    print('GN001是打折商品')\nelse if @in = @sale\n    print('测试用例')\nELSE\n    print('GN001是正价商品')\n\n\n-- Case语句\ncase expression\n    when expression1 then result1\n    when expression2 then result2\n    ELSE result3\nEND\n```\n\n# 存储类型\n* varchar(10)，只能存储10个英文字符或数字，也只能存储5个汉字；\n* char(10)，只能存储10个英文字符或数字，也只能存储5个汉字；\n* nvarchar(10)，即存储10个英文字符或数字，也能存储10个汉字；\n* nchar(10)，即存储10个英文字符或数字，也能存储10个汉字\n\n# Date或者DateTime类型的年月日函数\n* year(date)\n* month(date)\n* day(date)\n* datediff(datepart,startdate,enddate):计算两个时间的差值,比如：datediff(yy,getdate(),'2008-08-08') : 表示计算年份的差值\n* getdate() 是获取当时时间，类型是datetime类型\n\n# 截取字符串\n* left('abcdefg',3) ,从左开始截取3位\n* right('asdasd',4), 从右开始截取4位\n* substr('asdadasd',2,4) 截取下标2~3的字符\n\n\n\n\n\n\n\n\n\n\n","categories":["DataBase"],"tags":[]},{"title":"JUC","url":"/posts/30559/","content":">主要总结了关于JUC的相关知识点\n<!--more-->\n# 随记\n>* volatile ： 强制每个线程到主存去获取数据而不是去Cache\n\n## JUC辅助类\n### CountDownLatch(减少计数)\n>* 使用场景： 多个线程互相等待都执行完毕之后，统一执行主线程\n### CyclicBarrier(循环栅栏)\n>* 使用场景： 多个线程互相等待都执行完毕之后，统一执行另一线程\n### Semaphore(信号灯)\n>* 使用场景： 类似于线程池，多个线程抢夺有限个执行机会(锁的机制)\n\n# 锁\n## 无锁\n>多线程争夺资源，很乱\n## 普通锁\n>使用synchronized和ReentrantLock (都是独占锁)\n## 读写锁 ReentrantReadWriteLock\n> * 读读可以共享，支持多人读，可以提升性能\n> * 写锁还是一个线程独占的\n> **缺点:** \n>1, 造成锁饥饿，一直读却没有写\n>2, 同一线程读锁的情况下不能再写锁(可能会死锁)，但是同一线程写锁的情况下还可以去读锁\n> * 锁降级：写锁可以降级为读锁，读锁不能升级为写锁 :即同一线程读的时候不能写，但写的时候可以读\n\n\n## 锁的介绍 \n>* 自旋锁：自旋，jvm默认是10次吧，有jvm自己控制。自旋锁，它并不会放弃CPU时间片，而是通过自旋等待锁的释放，也就是说，它会不停地再次地尝试获取锁，如果失败就再次尝试，直到成功\n>* 阻塞锁：被阻塞的线程，不会争夺锁。\n>* 可重入锁： 多次进入改锁的域\n>* 读写锁\n>* 互斥锁：锁本身就是互斥的\n>* 悲观锁：不相信，这里会是安全的，必须全部上锁\n>* 乐观锁：相信，这里是安全的。\n>* 公平锁：有优先级的锁\n>* 非公平锁：无优先级的锁\n>* 偏向锁：无竞争不锁，有竞争挂起，转为轻量锁\n>* 对象锁：锁住对象\n>* 线程锁\n>* 锁粗化：多锁变成一个，自己处理\n>* 轻量级锁：CAS 实现\n>* 锁消除：偏向锁就是锁消除的一种\n>* 锁膨胀：jvm实现，锁粗化\n>* 信号量:使用阻塞锁 实现的一种策略\n\n# 阻塞队列\n * 放入  |  取出  |     取队首元素 |    触发  \n * add   | remove  |   element |    抛异常  \n * offer |  poll   |     peek  |     返回Bool  \n * put   |  take    |     无   |     处于阻塞状态，一直处于运行  \n * offer(e,time,unit) |  poll(time,unit)  这种方式的可设置阻塞时间，如果超过设置时  间，则返回Bool\n\n\n# 创建线程的多种方式：\n * 1,继承Thread类 ：参数不可传入Callable\n * 2,实现Runnable接口\n * 3,通过Callable接口\n * 4,通过线程池的方式来创建接口\n\n# Runnable（Thread默认）与Callable接口的比较\n  1,返回值（R无，C有）  \n  2,是否会抛出异常(R无，C有)  \n  3,Callable 和 Runnable都是函数式接口，都可以使用 lambada 表达式  \n  4,实现方法名称:  \n  * Runnable: run方法  \n  * Callable: call方法  \n  \n>- - -\n  Runnable接口有个实现类：FutureTask  \n  * FutureTask构造可以传递 Callable,有Callable的构造方法  \n  * FutureTask可以先单开线程去做其他事情，最后汇总，汇总只需要一次  \n  * FutureTask实际上是构造方法既能传入Callable、也可以传入Runnable  \n\n\n\n\n# 线程池\n## ThreadPoolExecutor\n## 随记\n>* 当阻塞队列和核心线程都满了之后，如果还有线程，将直接优先处理刚来的线程而不是处理阻塞队列里面的线程\n### 参数\n```Java\n// 核心线程\n>int corePoolSize, \n>- - -\n// 最大线程数量\n>int maximumPoolSize,\n>- - -\n// 存活时间及其单位\n>long keepAliveTime,\n>TimeUnit unit,\n>- - -\n//阻塞队列 : 线程排队用的\n>BlockingQueue<Runnable> workQueue,\n>- - -\n//线程工厂：用于创建线程\n>ThreadFactory threadFactory,\n>- - -\n//拒绝策略 : 该线程池无法为其他线程提供服务了\n>RejectedExecutionHandler handler\n```\n## Executors\n>阿里开发规范已经不支持使用Executors了，而使用ThreadPoolExecutor代替\n### 一池 N 线程\n```java\nExecutorService executorService = Executors.newFixedThreadPool(3);\n```\n### 一池一线程\n```java\nExecutorService executorService1 = Executors.newSingleThreadExecutor();\n```\n### 自动根据需要创建线程，可扩容，遇强则强\n```java\nExecutorService executorService2 = Executors.newCachedThreadPool();\n```\n\n### 四种拒绝策略\n>* AbortPolicy(默认):直接抛出Rejected的异常\n>* CallerRunsPolicy: 将任务回退到调用者\n>* DiscardOldestPolicy: 抛弃队列中等待最久的任务，然后将当前任务加入到队列中，尝试再次提交当前任务\n>* DiscardPlicy : 默默丢弃无法处理的任务，不予处理也不抛出任何异常，如果运行任务丢失，这将是最好的策略\n\n\n","categories":["JavaStudy"],"tags":["JUC"]},{"title":"Redis","url":"/posts/27273/","content":"> 介绍了关于Redis的相关内容\n<!--more-->\n# 依赖引入\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n# yml 配置\n```yml\n# 使用的数据库（0-15），默认为0\nspring:\n    redis:\n    lettuce:\n    # 对连接池的相关配置\n      pool:\n        # 最大连接数(使用负数表示无限制)\n        max-active: 8\n        # 最大阻塞等待时间(使用负数表示无限制)\n        max-wait: -1\n        # 最大空闲连接\n        max-idle: 8\n        # 最小空闲连接数\n        min-idle: 0\n    database: 0\n    host: 120.48.77.232\n    port: 6379\n    password: redis\n    # 6s后连接超时\n    timeout: 6000\n```\n\n# Jedis和Lettuce的区别\n>* jedis和Lettuce都是Redis的客户端，它们都可以连接Redis服务器，但是在SpringBoot2.0之后默认都是使用的Lettuce这个客户端连接Redis服务器。因为当使用Jedis客户端连接Redis服务器的时候，每个线程都要拿自己创建的Jedis实例去连接Redis客户端，当有很多个线程的时候，不仅开销大需要反复的创建关闭一个Jedis连接，而且也是线程不安全的，一个线程通过Jedis实例更改Redis服务器中的数据之后会影响另一个线程；\n\n>* 但是如果使用Lettuce这个客户端连接Redis服务器的时候，就不会出现上面的情况，Lettuce底层使用的是Netty，当有多个线程都需要连接Redis服务器的时候，可以保证只创建一个Lettuce连接，使所有的线程共享这一个Lettuce连接，这样可以减少创建关闭一个Lettuce连接时候的开销；而且这种方式也是线程安全的，不会出现一个线程通过Lettuce更改Redis服务器中的数据之后而影响另一个线程的情况；\n\n\n\n# 缓存注解\n```java\n@CacheConfig\n是一个类级别的注解，允许共享缓存的名称。\n一个类可能会有多个缓存操作而这些缓存操作可能是重复的，这时候可以使用@CacheConfig.\n```\n>- - -\n```java\n@Cacheable\n* 代表从缓存中查询指定的key，如果有，从缓存中取，不再执行方法。\n* 如果没有则执行方法，并且将方法的返回值和指定的key关联起来，放入到缓存中。\n\n主要参数：\n* value : 缓存的名称，在spring配置中定义，必须指定至少一个。\n* key: 缓存的key，可以为空，如果指定要按照spel表达式编写，如果不指定，则缺省按照方法的所有参数进行组合。\n* condition: 缓存的条件，可以为空，使用spek编写，返回true或false,只有为true使才进行缓存。\n\nExample:\n@Cacheable(value=\"thisredis\", key=\"'users_'+#id\")\npublic User findUser(Integer id) {}\n```\n>- - -\n>如果在类上配置了@CacheConfig,那么此时@Cacheable中的value就会取代@CacheConfig中cacheNames。  \n>如果在类上配置了@CacheConfig(cacheNames = \" \"),在该类下的@Cacheable中可以不用配置value。\n>- - -\n```java\n@CacheEvict\n标记在方法上，方法执行完毕之后根据条件或key删除对应的缓存。\n\nExample:\n@CacheEvict(value=\"thisredis\",   key=\"'users_'+#id\",condition=\"#id!=1\")\npublic void delUser(Integer id) {}\n\n主要参数：\nallEntries : 布尔类型 表示是否需要清除缓存中的所有元素。\nkey: 需要删除的缓存的key\n\n当我们在更新数据库的数据时，要使用@CacheEvict，需要把redis的缓存清空，否则查询的数据就是redis缓存中的数据，这样就会导致数据库和缓存数据不一致的问题。（页面不能及时的同步更新后的数据）。\n\n加上@CacehEvict 就会在查询数据时发现数据时最新的，与数据库保持一致。\n```\n\n# 模板对象序列化\n> 如果不自定义序列化，则调用redisTemplate.keys(\"*\")是无法获取到键的  \n> 更无法使用redisTemplate.keys(prefix+\"*\")来获取某个前缀下的所有key值了\n```java\n    @Resource\n    private RedisConnectionFactory redisConnectionFactory;\n\n     /**\n     * 自定义Key为String类型Value为Object类型的Redis操作模板\n     * 定义redis用到的redisTemplate对象序列化\n     */\n    @Bean(name = \"redisTemplate\")\n    public RedisTemplate<String, Object> redisTemplate(){\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n        // key采用String的序列化方式\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n        // hash的key也采用String的序列化方式\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());\n        return redisTemplate;\n    }\n```","categories":["TechStack"],"tags":["Redis"]},{"title":"日常随笔","url":"/posts/10026/","content":">日常学习的一个随笔\n<!--more-->\n# 获取request对象\n```java\n ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n```\n# 产生随机数\n```java\n System.out.println((int) (Math.random()*3));\n System.out.println(new Random().nextInt(20));\n```\n\n","categories":["Accumulate"],"tags":["随笔"]},{"title":"VersionController","url":"/posts/8310/","content":">总结了关于Spring全家桶以及Maven依赖的版本后缀意义，以及依赖关系\n>为了预防版本冲突或者版本不一致所导致的BUG\n<!--more-->\n\n# Maven版本后缀\n>* SNAPSHOT(快照版本Snapshot)\n>* RELEASE(发布版本release)\n>* Alpha：内测版，BUG 多，开发人员开发过程中使用，希腊字母α，第一，指最初版 \n>* Beta：早期版本，有缺陷，无大 BUG，可能加入新功能，进一步开发完善。\n>* Gamma: 经 beta 版，完善修改，成为正式发布的候选版本（Release Candidate）\n>* RC：(Release Candidate)：候选版本，几乎就是正式版了，一般需要 ASF 投票通过后，才会形成正式版本。\n>* GA：（Ggeneral Availability）：发行稳定版，官方推荐使用此版本。\n>* R，RELEASE：正式版，等价于 GA。\n>- - -\n>**其他版本**  \n>Alpha：内部测试版  \nBeta：外部测试版  \nBuild：修正版  \nCorporation 或 Enterprise：企业版  \nDelux：豪华版  \nDEMO：演示版，有功能限制  \nFree：免费版  \nFull：完全版  \nFinal：正式版  \nPro(professional)：专业版  \nPlus：加强版  \nRetail：零售版  \nRelease：发行版，有时间限制  \nShareware：共享版，虽然不会要求注册但是一般也有功能限制  \nSR：修正版  \nTrial：试用版（一般有时间或者功能限制）  \n\n# SpringCloudAlibaba 与 SpringCloud 与 Springboot 的对应关系\n>![alt](http://xtzl.wentexl.cn/%E4%B8%BB%E7%89%88%E6%9C%AC.png)\n\n# SpringCloud的组件\n>![alt](http://xtzl.wentexl.cn/Cloud%E7%BB%84%E4%BB%B6.png)","categories":["Accumulate"],"tags":["version"]},{"title":"Swagger2","url":"/posts/35285/","content":"\n> 描述了关于Swagger的简介和简单使用\n<!--more-->\n# 地址：\n>http://服务器ip:端口/swagger-ui.html\n# 什么是swagger2\n>编写和维护接口文档是每个程序员的职责，根据Swagger2可以快速帮助我们编写最新的API接口文档，再也不用担心开会前仍忙于整理各种资料了，间接提升了团队开发的沟通效率。\n# 常用注解\n>* @Api：修饰整个类，描述Controller的作用\n>* @ApiOperation：描述一个类的一个方法，或者说一个接口\n>* @ApiParam：单个参数描述\n>* @ApiModel：用对象来接收参数\n>* @ApiModelProperty：用对象接收参数时，描述对象的一个字段\n>* @ApiImplicitParam：一个请求参数\n>* @ApiImplicitParams：多个请求参数\n# 具体使用\n```java\n// 标注在类上\n@Api(tags = \"ES接口模块\")\n\n// 标注在接口上\n@ApiOperation(value = \"搜索接口\",notes = \"至少传入三个参数\")\n@ApiImplicitParams({\n        @ApiImplicitParam(name = \"keyword\",value = \"搜索关键词\"),\n        @ApiImplicitParam(name = \"indexPage\",value = \"页码\" ),\n        @ApiImplicitParam(name = \"pageSize\",value = \"每页显示的条数\")\n})\n```\n\n\n\n\n\n\n\n\n# 依赖\n```xml\n  <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui -->\n <dependency>\n      <groupId>io.springfox</groupId>\n      <artifactId>springfox-swagger-ui</artifactId>\n      <version>2.9.2</version>\n  </dependency>\n  <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 -->\n  <dependency>\n      <groupId>io.springfox</groupId>\n      <artifactId>springfox-swagger2</artifactId>\n      <version>2.9.2</version>\n      <scope>compile</scope>\n  </dependency>\n\n```","categories":["TechStack"],"tags":["Swagger2"]},{"title":"JSTL 表达式","url":"/posts/9859/","content":"<!--more-->\n# JSTL\n##\t1. 概念：JavaServer Pages Tag Library  JSP标准标签库\n\t\t* 是由Apache组织提供的开源的免费的jsp标签\t\t<标签>\n\n##\t2. 作用：用于简化和替换jsp页面上的java代码\n\n##\t3. 使用步骤：\n\t\t1. 导入jstl相关jar包\n\t\t2. 引入标签库：taglib指令：  <%@ taglib %>\n\t\t3. 使用标签\n\n##\t4. 常用的JSTL标签\n\t\t1. if:相当于java代码的if语句\n\t\t\t1. 属性：\n\t            * test 必须属性，接受boolean表达式\n\t                * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容\n\t                * 一般情况下，test属性值会结合el表达式一起使用\n       \t\t 2. 注意：\n\t       \t\t * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签\n\t\t2. choose:相当于java代码的switch语句\n\t\t\t1. 使用choose标签声明         \t\t\t相当于switch声明\n            2. 使用when标签做判断         \t\t\t相当于case\n            3. 使用otherwise标签做其他情况的声明    \t相当于default\n\n\t\t3. foreach:相当于java代码的for语句\n\n##\t5. 练习：\n\t\t* 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中\n\n\n\n\n\n# 三层架构：软件设计架构\n##\t1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互\n##\t2. 业务逻辑层：处理业务逻辑的。\n##\t3. 数据访问层：操作数据存储文件。","categories":["JavaStudy"],"tags":["JSYL表达式"]},{"title":"EL 表达式","url":"/posts/5361/","content":">总结了关于EL表达式的相关知识\n<!--more-->\n>EL 表达式\n\n#\t1. 概念：Expression Language 表达式语言\n#\t2. 作用：替换和简化jsp页面中java代码的编写\n#\t3. 语法：${表达式}\n#\t4. 注意:\n>\tjsp默认支持el表达式的。如果要忽略el表达式\n##\t1. 设置jsp中page指令中：isELIgnored=\"true\" 忽略当前jsp页面中所有的el表达式\n##\t2. \\${表达式} ：忽略当前这个el表达式\n\n\n#\t5. 使用：\n##\t\t1. 运算：\n\t\t\t* 运算符：\n\t\t\t\t1. 算数运算符： + - * /(div) %(mod)\n\t\t\t\t2. 比较运算符： > < >= <= == !=\n\t\t\t\t3. 逻辑运算符： &&(and) ||(or) !(not)\n\t\t\t\t4. 空运算符： empty\n\t\t\t\t\t* 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0\n\t\t\t\t\t* ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0\n\t\t\t\t\t* ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度>0\n##\t\t2. 获取值\n\t\t\t1. el表达式只能从域对象中获取值\n\t\t\t2. 语法：\n###\t\t\t1. ${域名称.键名}：从指定域中获取指定键的值\n\t\t\t\t\t* 域名称：\n\t\t\t\t\t\t1. pageScope\t\t--> pageContext\n\t\t\t\t\t\t2. requestScope \t--> request\n\t\t\t\t\t\t3. sessionScope \t--> session\n\t\t\t\t\t\t4. applicationScope --> application（ServletContext）\n\t\t\t\t\t* 举例：在request域中存储了name=张三\n\t\t\t\t\t* 获取：${requestScope.name}\n\n###\t\t\t\t2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。\n\n\n\n##\t\t\t\t3. 获取对象、List集合、Map集合的值\n\t\t\t\t\t1. 对象：${域名称.键名.属性名}\n\t\t\t\t\t\t* 本质上会去调用对象的getter方法\n\n\t\t\t\t\t2. List集合：${域名称.键名[索引]}\n\n\t\t\t\t\t3. Map集合：\n\t\t\t\t\t\t* ${域名称.键名.key名称}\n\t\t\t\t\t\t* ${域名称.键名[\"key名称\"]}\n\n\n##\t\t3. 隐式对象：\n\t\t\t* el表达式中有11个隐式对象\n\t\t\t* pageContext：\n\t\t\t\t* 获取jsp其他八个内置对象\n\t\t\t\t\t* ${pageContext.request.contextPath}：动态获取虚拟目录","categories":["JavaStudy"],"tags":["EL表达式"]},{"title":"SpringSecurity-Web 权限","url":"/posts/21484/","content":"> 总结了关于SpringSecurity的Web权限控制方面的知识点\n<!--more-->\n>* 登录接口/login如果是GET方式，则表示访问登录页面，如果是POST方式，则表示提交表单，执行登录逻辑\n>* 默认SpringSecurity的过滤器链的优先级高于自定义的过滤器的优先级\n>* Spring Security中的FilterInvocation ：通过Spring Security 封装，可以安全的拿到HttpServletRequest 和 HttpServletResponse对象\n\n\n# 设置登录的用户名和密码\n## 通过配置文件\n```yml\nspring:\n  security:\n    user:\n      name: Wente\n      password: wente695\n```\n\n## 自定义编写实现类\n> 从数据库中获取账户和密码，验证的时候是通过用户名获取到数据库的数据\n```java\n@Configuration\npublic class SecuriryConfig extends WebSecurityConfigurerAdapter {\n    @Resource\n    private UserDetailsService userDetailsService;\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailsService).passwordEncoder(password());\n    }\n    @Bean\n    PasswordEncoder password(){return new BCryptPasswordEncoder();}\n}\n```\n**Service端**\n```java\n  @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        List<GrantedAuthority> auths = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\");\n        return new User(\"mary\",new BCryptPasswordEncoder().encode(\"123\"),auths);\n    }\n```\n# 基于角色或者权限进行访问控制\n## hasAuthority 方法\n> 在配置类设置当前访问地址有哪些权限\n> 配置类中设置权限\n```java\n   .antMatchers(\"/test/index\").hasAnyAuthority(\"admins\")// 当前登录用户只有具有admins权限的才能访问这个路径\n```\n> 服务端配置权限\n```java\n  List<GrantedAuthority> auths = AuthorityUtils.commaSeparatedStringToAuthorityList(\"admins\");\n```\n## hasAnyAuthority方法\n```java\n   .antMatchers(\"/test/index\").hasAnyAuthority(\"admins,mannager\")// 当前登录用户只有具有admins,或者mannager的都可以\n```\n## hasRole方法\n> 但是在服务类里面添加角色权限的时候，必须要加一个ROLE_前缀\n>hasanyRole方法在配置类中多个角色用逗号隔开\n```java\n .antMatchers(\"/test/index\").hasRole(\"sale\") // 设置什么角色可以访问\n```\n>- - -\n```java\n  List<GrantedAuthority> auths = AuthorityUtils.commaSeparatedStringToAuthorityList(\"admins,ROLE_sale\");\n```\n>- - -\n\n# 基于注解配置SpringSecurity\n## 设置权限\n> 开启注解配置Security方式\n```java\n// prePostEnabled是表示支持事后验证的方式\n@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)\n```\n>接口类\n```java\n//@Secured({\"ROLE_sale\",\"ROLE_mannager\"})\n@PreAuthorize(\"hasAnyAuthority('admins')\")\n//@PostAuthorize(\"hasAnyAuthority('admins')\") // 在方法执行之后再做权限验证\n    public String update(){\n        return \"hello updata\";\n    }\n```\n## 过滤注解\n```java\n@PostFilter // 方法对返回数据进行过滤\n@PreFillter // 对传入方法的数据进行过滤\n```\n> 参数使用\n```java\n// 表示只返回的数据对象中的username是admin的对象\n@PostFilter(\"filterObject.username == 'admin'\")\n// 表示只传入的数据对象中的username属性是admin的对象\n@PreFilter(\"filterObject.username == 'admin'\")\n```\n# 用户注销\n> href的/logout是自带的，不需要自己去编写\n> 登出后再去访问需要登录的方法的请求就会被拦截，自动跳到登陆页面去\n ```xml\n  <a href=\"/logout\">退出</a>\n ```\n\n# 登录逻辑流程图\n> <img src = \"http://xtzl.wentexl.cn/login.png\">\n\n# 鉴权逻辑流程图\n> <img src = \"http://xtzl.wentexl.cn/auth.png\">\n","categories":["SpringSecurity"],"tags":[]},{"title":"boot_Security.md","url":"/posts/29525/","content":"> 主要是针对于SpringSecurity进行总结,主要采用的是SpringBoot + SpringSecurity\n<!--more-->\n# 核心要点\n>* 引入依赖之后访问方法都要先登录，登录用户名默认是user，密码在控制台\n\n# 依赖引入\n```xml\n   <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n```\n# 两个重要接口：\n##  UserDetailsServic 接口: 查询数据库用户名和密码的过程\n* 创建类继承UsernamePasswordAuthenticationFilter\n* 创建类实现UserDetailsService,编写查询数据过程，返回User对象，这个User对象是安全框架提供对象。\n## User对象的两种构造\n### 简单构造\n只需要传入username，password，authoritities即可\n### 完全构造\n除了上面三个参数，还需要如下几个\n* isAccountNonExpired() // 用户是否过期\n* isAccountNonLocked() // 用户是否被锁定\n* isCredentialsNonExpired() // 用户密码是否过期\n* isEnabled() // 用户是否被禁用\n\n## PasswordEncoder 接口：数据加密接口，用于返回User对象里面密码加密\n\n# 配置类\n\n\n","categories":["SpringSecurity"],"tags":["SpringSecurity"]},{"title":"SpringAop","url":"/posts/21566/","content":">介绍了关于SpringBoot的相关知识点\n<!--more-->\n# 通知\n## 执行顺序\n>环绕通知 -> 前置通知 -> 方法逻辑 -> 返回通知(无异常) -> 后置通知 -> 环绕通知\n><img src = \"http://xtzl.wentexl.cn/%E9%80%9A%E7%9F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png\">\n## 注解\n>* 环绕通知 @Around(\"testCut()\")\n>* 前置通知 @Before(\"testCut()\")\n>* 返回通知 @AfterReturning(value = \"testCut()\", returning = \"result\")\n>* 异常通知 @AfterThrowing(value = \"testCut()\", throwing = \"e\")\n>* 后置通知 @After(\"testCut()\")\n\n# 优先级\n> 环绕通知可以决定切点方法内的业务逻辑是否执行  \n> 如果选择执行切点的话，则使用joinPoint.proceed();  \n> 环绕通知的返回值就是最终返回给前端的返回值  \n> 即便执行了业务逻辑代码，若配置了环绕通知，返回给前端的仍然是环绕通知的return\n\n# 代码演示\n## 自定义注解\n```java\n// 自定义注解\n//@Documented注解，是被用来指定自定义注解是否能随着被定义的java文件生成到JavaDoc文档当中。\n@Documented\n@Retention(RetentionPolicy.RUNTIME) // 在运行时可被虚拟机保留,通过反射可以读取到它\n@Target(ElementType.METHOD) // 限定了只能使用在方法上面\npublic @interface AspectTest {\n    // 里面可以放一些成属性\n}\n```\n## 自定义切面\n```java\n@Aspect\n@Component\npublic class AspectTest {\n\n    /**\n     * 这里的路径填自定义注解的全路径\n     */\n    @Pointcut(\"@annotation(campus.epidemic.prevention.aspect.Annotations.AspectTest)\")\n    public void testCut() {\n\n    }\n\n    // 前置通知\n    @Before(\"testCut()\")\n    public void cutProcess(JoinPoint joinPoint) {\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        System.out.println(\"注解方式AOP开始拦截, 当前拦截的方法名: \" + method.getName());\n    }\n\n    // 环绕通知\n    @Around(\"testCut()\")\n    public Object testCutAround(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"注解方式AOP拦截开始进入环绕通知.......\");\n        // 这里的proceed是指的指定切点(接口方法)的返回值\n        Object proceed = joinPoint.proceed();\n        System.out.println(\"准备退出环绕......\");\n        return proceed;\n    }\n\n    /**\n     * returning属性指定连接点方法返回的结果放置在result变量中\n     * @param joinPoint 连接点\n     * @param result    返回结果\n     */\n    // 返回通知：必须无异常的时候才能执行\n    @AfterReturning(value = \"testCut()\", returning = \"result\")\n    public void afterReturn(JoinPoint joinPoint, Object result) {\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        System.out.println(\"注解方式AOP拦截的方法执行成功, 进入返回通知拦截, 方法名为: \" + method.getName() + \", 返回结果为: \" + result.toString());\n    }\n\n\n    // 异常通知： 有异常的时候抛出\n    @AfterThrowing(value = \"testCut()\", throwing = \"e\")\n    public void afterThrow(JoinPoint joinPoint, Exception e) {\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        System.out.println(\"注解方式AOP进入方法异常拦截, 方法名为: \" + method.getName() + \", 异常信息为: \" + e.getMessage());\n    }\n\n    //后置通知:无论是否有异常都必须执行\n    @After(\"testCut()\")\n    public void after(JoinPoint joinPoint) {\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        // 方法名\n        Method method = signature.getMethod();\n        System.out.println(\"注解方式AOP执行的方法 :\" + method.getName() + \" 执行完了\");\n    }\n\n}\n```\n\n## AOP实战切面\n```java\n\n/**\n * @author Wente\n * @date 2023/1/13\n **/\n@Slf4j\n@Component\n@Aspect\npublic class CacheAspect {\n    /**由于所有线程都共享这一个组件中的cache，所以需要考虑并发*/\n    private LoadingCache<String,Object> cache ;\n    @Resource\n    private RedisTemplate<String,Object> redisTemplate;\n    @Pointcut(\"@annotation(campus.epidemic.prevention.aspect.Annotations.DoubleCache)\")\n    public void cacheAspect() {}\n\n    @Value(\"${Caffeine.expireAfterWrite}\")\n    private Long expireTime;\n    @Value(\"${Caffeine.maximumSize}\")\n    private Long maximumSize;\n\n\n    @PostConstruct\n    public void init(){\n        /**反存逻辑已经在代码中体现，无须在build中指定*/\n         cache = Caffeine.newBuilder().\n            maximumSize(maximumSize).\n            expireAfterWrite(expireTime,TimeUnit.SECONDS).\n            build(new CacheLoader<String, Object>() {\n                @Override\n                public @Nullable Object load(@NonNull String s) throws Exception {\n                    return null;\n                }\n            });\n    }\n\n\n    @Around(\"cacheAspect()\")\n    public synchronized Object doAround(ProceedingJoinPoint point) throws Throwable {\n        MethodSignature signature = (MethodSignature) point.getSignature();\n        Method method = signature.getMethod();\n\n//拼接解析springEl表达式的map\n        String[] paramNames = signature.getParameterNames();\n        Object[] args = point.getArgs();\n        TreeMap<String, Object> treeMap = new TreeMap<>();\n        for (int i = 0; i < paramNames.length; i++) {\n            treeMap.put(paramNames[i],args[i]);\n        }\n        DoubleCache annotation = method.getAnnotation(DoubleCache.class);\n        String key = ElParser.parse(annotation.key(), treeMap);\n\n        //一般来说都是针对一张表的操作，elResult不为空，则为带条件的操作，如果elResult为空，则为操作整张表\n        String realKey = annotation.cacheName() + \"-\" + key;\n\n//强制更新所有缓存PUT\n        if (annotation.type()== CacheType.PUT){\n            Object object = point.proceed();\n            redisTemplate.opsForValue().set(realKey, object,annotation.l2TimeOut(), TimeUnit.SECONDS);\n            cache.put(realKey, object);\n            return object;\n        }\n//删除DELETE\n        else if (annotation.type()== CacheType.DELETE){\n            redisTemplate.delete(realKey);\n            cache.invalidate(realKey);\n            return point.proceed();\n        }\n\n//读写PULL，查询Caffeine(一级缓存)\n        Object caffeineCache = cache.getIfPresent(realKey);\n        if (Objects.nonNull(caffeineCache)) {\n            log.info(\"get data from caffeine\");\n            return caffeineCache;\n        }\n\n//查询Redis(二级缓存)\n        Object redisCache = redisTemplate.opsForValue().get(realKey);\n        if (Objects.nonNull(redisCache)) {\n            log.info(\"get data from redis\");\n            cache.put(realKey, redisCache);\n            return redisCache;\n        }\n        log.info(\"get data from database\");\n        Object object = point.proceed();\n        if (Objects.nonNull(object)){\n//更新二级缓存Redis\n            redisTemplate.opsForValue().set(realKey, object,annotation.l2TimeOut(), TimeUnit.SECONDS);\n//更新一级缓存Caffeine\n            cache.put(realKey, object);\n        }\n        return object;\n    }\n\n}\n\n```","categories":["SpringBoot"],"tags":["SpringAop"]},{"title":"Transaction","url":"/posts/43132/","content":"> 该文主要介绍了关于SpringBoot的事务管理的相关知识点\n<!--more-->\n# 核心\n>* Spring并不直接管理事务，而是通过各种事务管理器来调用特定平台的事务实现\n>* spring统一管理事务，把不同的数据库访问技术的事务处理统一起来\n>* 已经commit的事务是不能rollback的\n\n\n# 常用的事务管理器\n>* DataSourceTransactionManager：用于JDBC的持久化支持，也可用于IBATIS\n>* HibernateTransactionManager：用于Hibernate3的持久化支持\n>* JpaTransactionManager：用于Java持久化API的持久化支持\n>* JtaTransactionManager：主要用于分布式事务的支持\n\n# 事务的传播行为ProPagation\n>**事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式**  \n>优秀博文:http://t.csdn.cn/TgggY  \n> **重点：**\n>* PROPAGATION_REQUIRED : 表示当前方法必须运行在事务中，若当前存在事务，则在原有事务中运行，否则创建一个新的事务。\n>- - -\n>* PROPAGATION_REQUIRES_NEW :  新建事务，如果当前存在事务，把当前事务挂起。\n>- - -\n>* PROPAGATION_SUPPORTS : 如果当前有事务，则使用事务，如果当前没有事务，就以非事务方式执行\n>- - -\n>* Propagation.NOT_SUPPORTED :  以非事务方式执行操作，如果当前存在事务，就把当前事务挂起\n>- - -\n>- - -\n> **次要:**\n>* PROPAGATION_MANDATORY ：表示该方法必须在事务中运行，若当前事务不存在则抛异常。举例来说，一个service方法调用了两个dao方法，那么在执行其中的一个dao方法时，都要求已经启动了事务，否则需要抛异常。\n>- - -\n>* PROPAGATION_NESTED :表示若当前已存在一个事务，那么该方法将在嵌套事务中运行。嵌套事务可以独立于当前事务进行提交或回滚，若当前事务不存在，则该传播行为与PROPAGATION_REQUIRED一样。举例来说，一个service方法中调用了某dao方法，并且根据该dao方法执行的成功或失败区分了两套处理逻辑，这时候若dao执行失败，它只要保证不对数据库数据有任何影响（通过rollback）就可以了，不需要回滚整个service方法，故这个dao方法需要在嵌套事务中运行。\n>- - -\n>* PROPAGATION_NEVER : 表示当前方法不应该运行在事务中，若当前已经有一个事务在运行，则抛异常。这种适用于在某些dao操作中，它要求之前的事务已经结束，而它本身的操作结果不会受到其他dao操作结果的影响（比如被其他操作所rollback）。\n>- - -\n>* PROPAGATION_NOT_SUPPORTED : 表示当前方法不应该运行在事务中，若当前已经有一个事务在运行，则将其挂起。\n\n# 事务并发可能导致的错误\n>* 脏读：某事务读取了其他事务未提交的数据后，其他事务又将其数据回滚，导致该事务使用了无效的数据。\n>- - -\n>* 不可重复读：某事务执行两次相同的查询操作，但是由于在这两次操作中间存在其他事务更新了数据，从而导致两次查询的结果不一致。\n>- - -\n>* 幻读 ：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 删除或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候真实的数据集已经发生了变化，但是A却查询不出来这种变化，因此产生了幻读。\n>- - -\n\n# Spring提供的事务隔离isolation \n>若通过相关互斥机制保证事务的绝对隔离，则会很大程度影响并发的性能，最差情况就相当于事务是串行地执行。为了尽可能避免这些问题、权衡性能以及提高事务隔离的灵活性，Spring定义了五种隔离级别，以允许应用程序自己决定所能接受的、被其他事务所影响的程度。\n>- - -\n>* ISOLATION_DEFAULT : 使用底层数据库默认的隔离级别。\n>- - -\n>* ISOLATION_READ_UNCOMMITTED : 允许读取未提交的数据，这可能导致脏读、不可重复读和幻读。\n>- - -\n>* ISOLATION_READ_COMMITTED ：允许读取已提交的数据，这可以避免脏读，但是还是可能导致不可重复读和幻读。\n>- - -\n>* ISOLATION_REPEATABLE_READ : 对同一字段的多次读取结果是一致的，除非由本事务自己更新，这可以避免不可重复读和脏读，但是还是可能导致幻读。\n>- - -\n>* ISOLATION_SERIALIZABLE：完全按照ACID所要求的，可以避免脏读、不可重复读和幻读。注意：这种事务隔离级别的效率最差，因为它经常需要将事务相关的表进行加锁，锁粒度大。\n>- - -\n>![事务](http://xtzl.wentexl.cn/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E8%A7%84%E5%88%99.png)\n\n\n","categories":["SpringBoot"],"tags":["Transaction"]},{"title":"Seata","url":"/posts/63021/","content":"> 介绍了分布式中关于Seata分布式事务的知识\n<!--more-->\n# Seata重点\n>* 必须先启动Nacos后启动Seata\n\n\n# Seata介绍\n>* 1 + 3 的组件模型\n>* 分布式事务处理过程的-ID+三组件模型\n>* Transaction ID XID : 全局唯一的事务ID\n\n# Seata术语(三组件)\n## TC (Transaction Coordinator) - 事务协调者\n>维护全局和分支事务的状态，驱动全局事务提交或回滚。\n\n## TM (Transaction Manager) - 事务管理器\n>定义全局事务的范围：开始全局事务、提交或回滚全局事务。\n\n## RM (Resource Manager) - 资源管理器\n>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回\n滚。\n\n![seata](http://xtzl.wentexl.cn/Seata.png)\n>- - -\n\n# BASE理论 \n>BASE理论是对CAP的一种解决思路，包含三个思想：\n>- - -\n>* Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。\n>* Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。\n>* Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。\n>- - -\n>而分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论：\n>- - -\n>* AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。  \n>* CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态\n\n# 分布式事务解决方案\n>Seata提供了四种不同的分布式事务解决方案：\n>- - -\n>* XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入\n>* TCC模式：最终一致的分阶段事务模式，有业务侵入\n>* AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式\n>* SAGA模式：长事务模式，有业务侵入  \n\n**对比**\n![compare](http://xtzl.wentexl.cn/%E5%AF%B9%E6%AF%94.png)","categories":["SpringCloudAlibaba"],"tags":["Seata"]},{"title":"Sentinel","url":"/posts/60668/","content":"> 总结了Sentinel服务降级、服务熔断的有关知识\n<!--more-->\n# 重点\n>* 实例重启后如果进入sentinel的web界面，则必须先调用一个任意的方法才能被检测到\n>* fallback管的是运行异常，blockHandler管的是配置违规\n>* 当fallback和blockHandler同时起效的时，优先起效的是blockHandler方法\n>* 自带负载均衡\n\n\n# 依赖引入\n```xml\n    <!--SpringCloud ailibaba nacos -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n    </dependency>\n    <!--SpringCloud ailibaba sentinel-datasource-nacos 后续sentinel做持久化用到-->\n    <dependency>\n        <groupId>com.alibaba.csp</groupId>\n        <artifactId>sentinel-datasource-nacos</artifactId>\n    </dependency>\n    <!--SpringCloud ailibaba sentinel -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\n    </dependency>\n```\n# 服务端 yml 配置\n```yml\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibaba-sentinel-service\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n    sentinel:\n      transport:\n        # 8080会监控8401查看是否健康\n        dashboard: localhost:8080 #配置Sentinel dashboard地址\n        # 默认是8719端口号,如果被占用了会自动+1\n        # 指定应用与Sentinel控制台交互的端口，应用本地会起一个该端口占用的HttpServer\n        port: 8719\n\n\n      datasource:\n        ds1:\n          nacos:\n            server-addr: localhost:8848\n            dataId: ${spring.application.name}\n            groupId: DEFAULT_GROUP\n            data-type: json\n            rule-type: flow\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n\n```\n# 流控规则\n>* QPS: 每秒的请求数，一般指每秒查询率\n>* 单机阈值: 请求数的多少\n## PostMan测试\n![postman](http://xtzl.wentexl.cn/PostMan.png)\n\n## 流控效果\n### 预热\n>* ColdFactor冷加载因子默认是3\n>* 请求QPS从 threshold/3 开始，经预热时长之后，QPS才会逐渐达到指定QPS值\n>* 预热主要是为了保护系统\n### 快速失败\n>* 只要不满足流控规则，直接让该请求失败\n### 排队等等\n>* 只要每个请求的等待时间不超过设定的超时时间，则每个请求都排队等待响应\n>* 而处理的速度，根据流控规则的单机阈值来决定\n>* 其中超时时间的单位是ms\n>* 如果请求超时，则报错\n\n## 流控模式\n### 关联\n![connect](http://xtzl.wentexl.cn/%E5%85%B3%E8%81%94.png)\n### 直接\n>* 仅仅针对于一个方法而言\n\n# 降级与熔断策略\n>* 官网讲解\n![熔断](http://xtzl.wentexl.cn/%E5%AE%98%E7%BD%91%E7%86%94%E6%96%AD.png)\n\n## RT:慢调用比例\n>* 注意：Sentinel默认RT最大时间为4900毫秒，可通过-Dcsp.sentinel.statistic.max.rt=xxx修改  \n>* 慢调用比例 = 慢调用请求数/请求总数\n>* 在单位统计时长内，如果慢调用比例大于阈值，且请求数大于最小请求数值，则触发熔断\n>* 经过一个熔断时长后，进入探测恢复状态（HALF-OPEN）阶段，即接下来的一个请求响应时间小于rt(200ms),则熔断结束，否则会再次被熔断。\n>* 慢调用不是异常，如果异常的话是不会进行服务降级而是直接报错\n![慢比例](http://xtzl.wentexl.cn/%E6%85%A2%E6%AF%94%E4%BE%8B1.png)\n\n>- - -\n\n## 异常比例\n>* 当单位统计时长内，请求数目大于设置的最小请求数目（5），并且异常的比例大于阈值（0.07），则接下来的熔断时长（3s，时间窗口的值）内请求会自动被熔断。  \n>* 经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]。\n>![异常](http://xtzl.wentexl.cn/%E5%BC%82%E5%B8%B8%E6%AF%94%E4%BE%8B1.8.4.png)\n\n>- - -\n\n## 异常数\n>* 异常数一般都是按分钟统计的\n>* 单位统计时长内，异常数达到设定的异常数则进入服务熔断，调用服务降级的函数\n>* 服务熔断之后，经过一个熔断时长之后，才会进入探测恢复状态\n>![异常数](http://xtzl.wentexl.cn/%E5%BC%82%E5%B8%B8%E6%95%B01.8.4.png)\n\n\n# 热点监控\n>* 在web界面自定义热点规则，当请求违背了热点规则之后，则执行blocakHandler所指的的方法\n>* @SentinelResource 的value属性只要保持唯一性就好，一般与GetMapping的value保持一致\n>* 运行异常不属于热点监控的范围，热点监控只管是否违背热点规则，运行异常也就不会走blockHandler这个方法\n## Controller层\n```java\n    @GetMapping(\"/testHotKey\")\n    @SentinelResource(value = \"testHotKey\", blockHandler = \"deal_testHotKey\")\n    public String testHotKey(@RequestParam(value = \"p1\", required = false) String p1,\n                             @RequestParam(value = \"p2\", required = false) String p2) {\n        int age = 10 / 0;\n        return \"------testHotKey\";\n    }\n    // 兜底的方法\n    public String deal_testHotKey(String p1, String p2, BlockException exception) {\n        //sentinel系统默认的提示：Blocked by Sentinel (flow limiting)\n        return \"------deal_testHotKey,o(╥﹏╥)o\";\n    }\n```\n## Web界面配置\n> * 该图表示监控携带第0个参数的请求，窗口时长内的请求数不能超过1次，资源名为@SentinelResource的Value值\n>* 参数例外项：当指定参数为一特定值的时候，阈值有所不同\n![热点规则](http://xtzl.wentexl.cn/%E5%8F%82%E6%95%B0%E4%BE%8B%E5%A4%96.png)\n\n\n\n# Sentinel 自定义限流处理逻辑\n>* 违反我们自己配置的流控规则才需要blockHandler\n>* 在配置流控规则的时候，资源标识最好只使用@SentinelResource注解的Value属性作为唯一标识\n## @SentinelResource\n>- - -\n>* (value = \"byResource\",blockHandler = \"handleException\")\n>* value是唯一标识，blockHandler是指定处理方法(兜底方法)的方法名\n>- - -\n>* (value = \"customerBlockHandler\",   \nblockHandlerClass = CustomerBlockHandler.class, blockHandler = \"handlerException2\")\n>* blockHandlerClass指定处理类，blockHandler指定类中的哪个方法\n>* 注意在写Handler类的方法的时候，所有方法都必须是static的，且handler类无须加入容器\n>- - -\n >* 其中属性exceptionsToIgnore = {IllegalArgumentException.class}，表示忽略IllegalArgumentException这个异常属性，但是这个忽略异常属性，仅仅指的是在Java层面，也就是fallback方法不响应该异常，但是Sentinel仍然会检测到该异常\n\n # Sentinele同样支持Open-feign\n >修改yml支持Open-feign\n ```yml\n # 激活Sentinel对Feign的支持\nfeign:\n  sentinel:\n    enabled: true\n ```\n >- - -\n ```java\n@FeignClient(value = \"nacos-payment-provider\", fallback = PaymentFallbackService.class)\n ```\n > 其中，service层分为接口+实现类，上面的注解标注在接口，fallback指向实现类\n\n# Sentinel持久化\n## 依赖引入\n```xml\n        <dependency>\n            <groupId>com.alibaba.csp</groupId>\n            <artifactId>sentinel-datasource-nacos</artifactId>\n        </dependency>\n```\n## YML配置\n> 将Sentinel配置进Nacos中\n```yml\nspring:\n  cloud:\n     sentinel: \n        datasource:\n          ds1:\n            nacos:\n              server-addr: localhost:8848\n              dataId: ${spring.application.name}\n              groupId: DEFAULT_GROUP\n              data-type: json\n              rule-type: flow\n```\n\n> 需要手动写进Nacos\n>* 在Nacos中需要新建一个配置文件s\n>* 配置文件名DataId就是Sentinel的实例服务名\n>* 配置文件的内容是Json格式\n```json\n[\n    {\n        \"resource\": \"/rateLimit/byUrl\",\n        \"limitApp\": \"default\",\n        \"grade\": 1,\n        \"count\": 1,\n        \"strategy\": 0,\n        \"controlBehavior\": 0,\n        \"clusterMode\": false\n    }\n]\n```\n**解释如下:**\n![json](http://xtzl.wentexl.cn/json.png)","categories":["SpringCloudAlibaba"],"tags":["Sentinel"]},{"title":"Nacos","url":"/posts/33695/","content":">总结了关于Nacos注册、配置的相关知识\n<!--more-->\n# Nacos\n>* Nacos 就是注册中心 + 配置中心的组合\n>* 等价于 Nacos = Eureka + Config + Bus\n>* AP架构和CP架构都支持，可切换（C: 一致性 A：可用性  P:分区容错性）\n>* startup.cmd -m standalone  单机启动命令\n\n# 依赖引入\n> 父工程pom：\n```xml\n     <!--spring cloud alibaba 2.1.0.RELEASE-->\n            <dependency>\n                <groupId>com.alibaba.cloud</groupId>\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n                <version>2.1.0.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n\n```\n> 子工程pom：\n```xml\n        <!--SpringCloud ailibaba nacos -->\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n```\n\n# Nacos注册中心\n## 服务端Yml配置\n```yml\nserver:\n  port: 9002\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #配置Nacos地址\n        # 换成nginx的1111端口，做集群\n        #server-addr: 192.168.111.144:1111\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n\n```\n## 客户端Yml配置\n```yml\nserver:\n  port: 83\n\n\nspring:\n  application:\n    name: nacos-order-consumer\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n\n\nservice-url:\n  nacos-user-service: http://nacos-payment-provider\n```\n\n## 客户端Controller层\n> 由于在配置yml的时候，已经在service-url.nacos-user-service中配置过了，所以直接可用@Value注解进行引入\n```java\n  @Value(\"${service-url.nacos-user-service}\")\n    private String serverURL;\n```\n# Nacos 配置中心\n## 核心\n>* Nacos的Config配置自带动态刷新\n>* DataId必须按官方给定的格式命名\n## 新增依赖\n```xml\n     <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n        </dependency>\n\n```\n## yml配置\n>**bootstrap的优先级是高于application的**\n\n> bootstrap.yml\n```yml\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacos-config-client\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #服务注册中心地址\n      config:\n        server-addr: localhost:8848 #配置中心地址\n        file-extension: yaml #指定yaml格式的配置\n```\n>application.yml\n```yml\nspring:\n  profiles:\n    active: dev\n```\n## 在Nacos端的配置文件名格式如下(设置DataId):\n>${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}  \n> 例如: nacos-config-client-dev.yaml\n\n## 分组管理\n![分组](http://xtzl.wentexl.cn/%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86.png)\n>* yml中设置分组,意为选择DEV环境下的配置生效\n```yml\nconfig:\n    group: DEV_GROUP\n```\n>* 不同的组别可以存在DataId相同的配置\n## 命名空间NameSpace\n>* yml文件配置命名空间\n```yml\nconfig:\n    namespace: f2009b56-a85a-487a-afeb-0927aa03a199\n```\n# 切换Nacos的数据库\n>*  Nacos自带一个derby数据库，但是要统一使用mysql数据库\n>*  sql执行脚本在nacos的安装路径中conf目录下\n>* sql执行之后，需要修改conf下application.properties,(mysql8)修改如下\n```txt\nspring.datasource.platform=mysql\ndb.num=1\ndb.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC\ndb.user.0=root\ndb.password.0=root\n```\n","categories":["SpringCloudAlibaba"],"tags":["Nacos"]},{"title":"MQ-Notes","url":"/posts/44276/","content":"> 总结了关于消息中间件MQ 的知识点\n<!--more-->\n# 核心:四大天王\n>* RabbitMQ\n>* RocketMQ\n>* ActiveMQ\n>* Kafka\n\n# 引入依赖\n```xml\n        <!--添加消息总线RabbitMQ支持来实现广播-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n        </dependency>\n```\n# client和Config端都需要添加yml的MQ的相关支持\n```yml\n#rabbitmq相关配置\nrabbitmq:\n  host: localhost\n  port: 5672\n  username: guest\n  password: guest\n\n```\n# 只需要发送一次，则client端处处生效\n> **中心Config端 多增加如下MQ配置，include改为:bus-refresh**\n```yml\n##rabbitmq相关配置,暴露bus刷新配置的端点\nmanagement:\n  endpoints: #暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: 'bus-refresh'\n\n```\n\n# 运维发送全体通知和精确通知\n> * 全体通知：  \n> localhost:3344/actuator/bus-refresh  \n> 其中，3344指的是中心Config端的端口号\n>- - -\n>* 精确通知：  \n>localhost:3344/actuator/bus-refresh/config-client:3366  \n>其中，config-client指的是config的服务名称，3366是实例的端口号\n> - - -\n\n> 以上是利用RabbitMQ来实现动态刷新Config的优化\n>- - -\n# SpringCloud Stream\n> **重点**  \n>* 凡是涉及到监控、刷新的，必须要引入actuator这个依赖\n>* 消费端不同的组可以存在重复消费\n>* 消费端同一个组不能存在重复消费\n>* 不做处理的默认每个接收的实例都是一个组\n>* 消费端group属性十分重要，因为这个属性既可以解决重复消费，又可以解决消息持久化\n>- - -\n> **核心设计思想**  \n>*  SpringCloud Stream是一个构建消息驱动微服务的框架，应用程序通过inputs或者 outputs来与SpringCloud Stream中的binder进行交互，我们可以通过配置来binding ，而 SpringCloud Stream 的binder负责与中间件交互\n>*  SpringCloud Stream由一个中间件中立的核组成，应用通过SpringCloud Stream插入的input(相当于消费者consumer，它是从队列中接收消息的)和output(相当于生产者producer，它是发送消息到队列中的)通道与外界交流\n>*  Binder是SpringCloud Stream的一个抽象概念，是应用与消息中间件之间的粘合剂，目前SpringCloud Stream实现了Kafka和RabbitMQ的binder通过binder，可以很方便的连接中间件，可以动态的改变消息的destinations（对应于 Kafka的topic，RabbitMQ的exchanges），这些都可以通过外部配置项来做到，甚至可以任意的改变中间件的类型但是不需要修改一行代码\n\n## 架构图1\n![alt](http://xtzl.wentexl.cn/%E7%BC%96%E7%A0%81API.png)\n## 架构图2\n![alt](http://xtzl.wentexl.cn/SCS%E6%9E%B6%E6%9E%84%E5%9B%BE2.png)\n\n## Stream的yml文件配置\n> **消息生产者(生产端)：**\n```yml\nserver:\n  port: 8801\n\nspring:\n  application:\n    name: cloud-stream-provider\n  cloud:\n    stream:\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\n        defaultRabbit: # 表示定义的名称，用于于binding整合\n          type: rabbit # 消息组件类型\n          environment: # 设置rabbitmq的相关的环境配置\n            spring:\n              rabbitmq:\n                host: localhost\n                port: 5672\n                username: guest\n                password: guest\n      bindings: # 服务的整合处理\n        output: # 这个名字是一个通道的名称\n          destination: studyExchange # 表示要使用的Exchange名称定义\n          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”\n          default-binder: defaultRabbit  # 设置要绑定的消息服务的具体设置\n\neureka:\n  client: # 客户端进行Eureka注册的配置\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: send-8802.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为IP地址\n\n```\n>- - -\n> **消息接收者(消费端)**\n```yml\nserver:\n  port: 8803\n\nspring:\n  application:\n    name: cloud-stream-consumer\n  cloud:\n    stream:\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\n        defaultRabbit: # 表示定义的名称，用于于binding整合\n          type: rabbit # 消息组件类型\n          environment: # 设置rabbitmq的相关的环境配置\n            spring:\n              rabbitmq:\n                host: localhost\n                port: 5672\n                username: guest\n                password: guest\n      bindings: # 服务的整合处理\n        input: # 这个名字是一个通道的名称\n          destination: studyExchange # 表示要使用的Exchange名称定义\n          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”\n          default-binder: defaultRabbit # 设置要绑定的消息服务的具体设置\n          group: atguiguA\n\neureka:\n  client: # 客户端进行Eureka注册的配置\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: receive-8803.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为IP地址\n\n```\n\n## 业务层配置\n> **消息生产者(生产端)：**  \n> 仅仅是发送消息到消息队列而已\n> 其中关键注解是： @EnableBinding(Source.class)\n```java\n@RestController\npublic class SendMessageController\n{\n    @Resource\n    private IMessageProvider messageProvider;\n\n    @GetMapping(value = \"/sendMessage\")\n    public String sendMessage()\n    {\n        return messageProvider.send();\n    }\n\n}\n------------------------下面是Service层-------------------------------\n@EnableBinding(Source.class) //定义消息的推送管道\npublic class MessageProviderImpl implements IMessageProvider\n{\n    @Resource\n    private MessageChannel output; // 消息发送管道\n\n    @Override\n    public String send()\n    {\n        String serial = UUID.randomUUID().toString();\n        output.send(MessageBuilder.withPayload(serial).build());\n        System.out.println(\"*****serial: \"+serial);\n        return null;\n    }\n}\n```\n\n> **消息接收者(消费端)：**  \n> 从消息队列中取得信息\n> 其中关键注解是: @EnableBinding(Sink.class)\n```java\n@Component\n@EnableBinding(Sink.class)\npublic class ReceiveMessageListener {\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @StreamListener(Sink.INPUT)\n    public void input(Message<String> message) {\n        System.out.println(\"port:\" + serverPort + \"\\t接受：\" + message.getPayload());\n    }\n\n}\n```\n# 消息持久化\n> 消息持久化主要是依靠yml配置中binder下的input下的group属性，当停机之后如果消息队列中有消息在流通，配置了group属性的实例，重启之后仍然能够收到消息，如果没配置的话，将会错过消息","categories":["MessageQueue"],"tags":["MQ","SpringCloud-Stream"]},{"title":"Config","url":"/posts/8012/","content":"> 主要总结和介绍了Config配置组件的使用\n<!--more-->\n> 要测试的话，也要在Windows的host文件做修改：127.0.0.1 config-3344.com\n> 测试链接：http://config-3344.com:3344/main/config-dev.yml\n# 主启动类注解引入\n```java\n@EnableConfigServer\n```\n# 依赖引入\n```xml\n   <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-config-server</artifactId>\n        </dependency>\n```\n# 中心Config的yml 配置\n```yml\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://gitee.com/mx0425/springcloud-config.git #GitHub上面的git仓库名字\n          ####搜索目录\n          search-paths:\n            - springcloud-config\n      ####读取分支\n      label: master\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n\n```\n# Client端Config的yml配置\n```yml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: main #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址k\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n```\n# Client端手动版动态刷新\n>**Controller层**\n```java\n类名上添加注解\n@RefreshScope\n```\n```yml\n# 暴露监控端点: 实现动态刷新用的\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n\n```\n>* **localhost:3355/actuator/refresh** \n>* 此时需要发一个如上的固定的post请求来刷新，这种方式只能针对单个的端口，下例就是3355这个端口进行刷新。\n>- - -\n>* 这样显然有**弊端**：假如有多个微服务客户端3355/3366/3377。。。。每一个都要手动去刷新岂不是很麻烦？？  \n>- - -\n>**优化**: 通过广播，一次通知，处处生效  \n>**广播设计思想**: 广播通知的是中心config  \n\n> 具体优化思想，见博文 Cloud_MQ\n\n\n","categories":["SpringCloud"],"tags":["SpringCloudConfig"]},{"title":"GateWay","url":"/posts/4296/","content":">对服务网关GateWay的知识总结\n<!--more-->\n# 核心与注意点\n>* GateWay作为网关也需要注册进注册中心\n>* 路由、断言、过滤器\n>* 网关不能部署在Tomcat、Jetty等Servlet容器里，只能打成jar包执行\n>* ​依赖于netty和WebFlux \n>* GateWay不能加Web的起步依赖的jar包\n\n# 架构图\n![alt](http://xtzl.wentexl.cn/%E6%9E%B6%E6%9E%84%E5%9B%BE.png)\n# 依赖导入\n```xml\n      <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-gateway</artifactId>\n        </dependency>\n```\n# 第一种配置方法：yml配置\n>* 获取当地时区 ZonedDateTime.now();\n```yml\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n       #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名\n        - id: payment_routh\n          #uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/get/**         # 断言，路径相匹配的进行路由\n         #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n        - id: payment_routh2\n         # uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/lb/**         # 必须是真正提供服务的方法 \n         #- After=2020-05-13T21:55:10.016+08:00[Asia/Shanghai]\n         # -Before\n         # -Between=2020-05-13T21:55:10.016+08:00[Asia/Shanghai],2021-05-13T21:55:10.016+08:00[Asia/Shanghai]\n         #- Cookie=username,milo\n         #- Header=X-Request-Id, \\d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client: #服务提供者provider注册进eureka服务列表内\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultZone: http://eureka7001.com:7001/eureka\n\n```\n\n# 第二种配置方法：Config配置\n> 当访问/guonei的时候，自动转发到http://news.baidu.com/guonei\n```java\n   @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)\n    {\n        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();\n        routes.route(\"path_route_atguigu\",\n                r -> r.path(\"/guonei\")\n                        .uri(\"http://news.baidu.com/guonei\")).build();\n        return routes.build();\n    }\n\n```\n# yml配置的时候，断言选项\n![断言](http://xtzl.wentexl.cn/GateWay%E6%96%AD%E8%A8%80.png)\n\n# curl开发\n>*  判断是否携带名为X-Request-Id的请求头，且其值必须是一个大于0的整数  \n>* -Header=X-Request-Id, \\d+   \n>* curl http://localhost:9527/payment/lb -H \"X-Request-Id:123\"\n>- - -\n>* 判断请求是否携带cookie名为username，值为milo\n>*  -Cookie = username,milo\n>* curl http://localhost:9527/payment/lb --cookie \"username=123\"\n\n# 自定义过滤器\n> 主要是要实现GlobalFilter,Ordered这两个接口，而且要加入容器\n\n**放行**\n```java\nreturn chain.filter(exchange);\n```\n**拦截**\n```java\nreturn exchange.getResponse().setComplete();\n```\n```java\n@Component\n@Slf4j\npublic class MyLogGateWayFilter implements GlobalFilter,Ordered\n{\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain)\n    {\n        log.info(\"***********come in MyLogGateWayFilter:  \"+new Date());\n        String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\");\n        if(uname == null)\n        {\n            log.info(\"*******用户名为null，非法用户，o(╥﹏╥)o\");\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\n            return exchange.getResponse().setComplete();\n        }\n        return chain.filter(exchange);\n    }\n    @Override\n    public int getOrder()\n    {\n        return 0;\n    }\n}\n```","categories":["SpringCloudAlibaba"],"tags":["GateWay"]},{"title":"JavaUtils","url":"/posts/13372/","content":">主要介绍了Java的各种工具类\n<!--more-->\n# IdUtil\n>* 主要介绍了各种id生成策略\n>* 生成的Id是用不重复的 \n>* String serialNumber = IdUtil.simpleUUID();\n\n# TimeUnit\n>* TimeUnit.DAYS //天  \n>* TimeUnit.HOURS //小时  \n>* TimeUnit.MINUTES //分钟  \n>* TimeUnit.SECONDS //秒  \n>* TimeUnit.MILLISECONDS //毫秒  \n>* TimeUnit.NANOSECONDS //毫微秒  \n>* TimeUnit.MICROSECONDS //微秒  \n>- - -\n>**转换：**\n>* public long toMillis(long d)    //转化成毫秒  \n>* public long toSeconds(long d)  //转化成秒  \n>* public long toMinutes(long d)  //转化成分钟  \n>* public long toHours(long d)    //转化成小时  \n>* public long toDays(long d)     //转化天   \n>- - -\n>**延时：** \n>* TimeUnit.SECONDS.sleep( 5 );\n>* TimeUnit.HOURS.sleep(1);\n\n# ZoneDateTime\n>* ZoneDateTime.now();可以获得当前时间串，在gateway中可以配置使用\n\n# 产生随机数的2种方法\n>两者均是左开右闭\n```java\n// 产生1~3的随机数\n System.out.println((int) (Math.random()*3) +1);\n // 产生0~20的随机数\n System.out.println(new Random().nextInt(20));\n```\n# UUID\n**随机数的生成**\n>* UUID.randomUUID().toString()","categories":["JavaStudy"],"tags":["JavaUtils"]},{"title":"Hystrix","url":"/posts/64571/","content":">Hystrix属于服务降级部分，这里将会详细介绍关于Hystrix的相关知识\n<!--more-->\n# Hystrix介绍\n>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等。  \n>Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。  \n>- - -\n>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控(类似熔断保险丝)，向调用方返回—个符合预期的、可处理的备选响应(FallBack)。  \n>而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n\n# Hystrix核心\n> * 服务降级\n> * 服务熔断\n> * 接近实时的监控\n\n# 依赖导入\n```xml\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n        </dependency>\n```\n>- - -\n# 服务降级----------------\n# 服务提供端8001设置fallbcakMethod兜底\n>- - -\n>主启动类添加注解，开启断路器功能\n```java\n@EnableCircuitBreaker\n```\n>- - -\n> 解释：  \n>* 业务层添加。如果paymentInfo_TimeOut()在规定的3s内执行失败，则立即访问   paymentInfo_TimeOutHandler()方法作为fallbackMethod方法  \n> * 只要是当前服务不可用了，马上做服务降级\n> * 如果是在服务端配置的服务降级，不能通过80端口回调，只能自测\n```java\n    @HystrixCommand(fallbackMethod = \"paymentInfo_TimeOutHandler\",\n    commandProperties = {\n        @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"3000\")})\n    public String paymentInfo_TimeOut(Integer id)\n    {\n        try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }\n        return \"线程池:  \"+Thread.currentThread().getName()+\" id:  \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\"+\"  耗时(秒): 5\";\n    }\n\n    public String paymentInfo_TimeOutHandler(Integer id)\n    {\n        return \"线程池:  \"+Thread.currentThread().getName()+\"  8001系统繁忙或者运行报错，请稍后再试,id:  \"+id+\"\\t\"+\"o(╥﹏╥)o\";\n    }\n\n```\n\n# 客户端80设置fallbackMethod\n>主启动类添加注解  \n> 其中@EnableHystrix中也包含了@EnableCircuitBreaker\n```java\n@EnableHystrix\n```\n>- - -\n>客户端yml中的配置  \n\n```yml\nfeign:\n  hystrix:\n  #如果处理自身的容错就开启。开启方式与生产端不一样。\n    enabled: true \n```\n>通用fallback方法 :  \n\n> 若单个方法有具体指明fallback方法，则使用其具体的方法\n```java\n// hystrix 全局fallback方法标注在Controller的类头\n@DefaultProperties(defaultFallback = \"payment_Global_FallbackMethod\")\npublic class OrderFeignController{}\n```\n\n# 客户端80解决代码冗余和膨胀\n> 这样写的话，就不需要在Controller层进行指定了\n> 这样写的优先级仍然大于DefaultProperties的优先级\n```java\n// 在service层的注解添加fallback\n@FeignClient(value = \"cloud-provider-hystrix-payment\",fallback = PaymentFallbackServiceImpl.class)\n```\n```java\n// 书写service层的实现类\n@Component\npublic class PaymentFallbackServiceImpl implements PaymentFeignService {}\n```\n>- - -\n# 服务熔断-----------------------------------\n>## 核心\n> * 服务降级--熔断--慢慢恢复调用电路  \n>- - -\n\n\n> # 服务端\n> ## Controller层\n```java\n  //====服务熔断\n    @GetMapping(\"/payment/circuit/{id}\")\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id)\n    {\n        String result = paymentService.paymentCircuitBreaker(id);\n        log.info(\"****result: \"+result);\n        return result;\n    }\n```\n>## Serice层\n\n```java\n //=====服务熔断\n    @HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\",commandProperties = {\n        // 是否开启断路器v\n        @HystrixProperty(name = \"circuitBreaker.enabled\",value = \"true\"),\n        // 请求次数\n        @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),\n         // 时间窗口期，在这个时间以内，请求次数达到多少后跳闸\n        @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),\n        // 失败率达到多少后跳闸\n        @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\",value = \"60\"),\n    })\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id)\n    {\n        if(id < 0)\n        {\n            throw new RuntimeException(\"******id 不能负数\");\n        }\n        // 使用工具包生成流水号\n        String serialNumber = IdUtil.simpleUUID();\n\n        return Thread.currentThread().getName()+\"\\t\"+\"调用成功，流水号: \" + serialNumber;\n    }\n    public String paymentCircuitBreaker_fallback(@PathVariable(\"id\") Integer id)\n    {\n        return \"id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: \" +id;\n    }\n\n```\n\n# Hystrix断路器总结\n## 熔断需要依靠断路器\n![断路器](http://xtzl.wentexl.cn/%E6%96%AD%E8%B7%AF%E5%99%A8.png)\n\n## 断路器开启或关闭的条件\n>* 当满足一定的阀值的时候(默认10秒内超过20个请求次数)\n>* 当失败率达到一定的时候( 默认10秒内超过50%的请求失败)\n>* 到达以上阀值，断路器将会开启\n>* 当开启的时候，所有请求都不会进行转发\n>* 一段时间之后(默认是5秒)，这个时候断路器是半开状态，会让其中-一个请求进行转发。\n>* 如果成功，断路器会关闭，若失败，继续开启。\n\n# HystrixDashboard\n## 监控图详解\n![监控图](http://xtzl.wentexl.cn/%E7%9B%91%E6%8E%A7%E5%9B%BE.png)\n## 监控数据详解\n![监控数据](http://xtzl.wentexl.cn/%E7%9B%91%E6%8E%A7%E5%9B%BE%E6%95%B0%E6%8D%AE.png)","categories":["SpringCloud"],"tags":["Hystrix"]},{"title":"OpenFeign","url":"/posts/40393/","content":">主要记录了关于OpenFeign服务调用的知识\n<!--more-->\n\n# 核心\n>* 微服务接口 + @FeignClient\n>* Feign自带负载均衡配置项，默认支持Ribbon\n>* OpenFeign默认等待1秒钟，之后将会报超时错误\n>* 面向接口编程\n>* 主要就是在80端口多了一层Service\n>* 在Service层这里直接使用注解而不使用RestTemplate\n>* 更加方便和简洁\n>* @FeignClient()接口类中，使用@RequestParam时必须指定value\n>* Feign和热部署有可能会冲突，且在使用的时候，要注意接口层的参数是否有在请求体内的，如果没表明是否在请求体，会导致调用失败，如果在请求体，就要更换httpclient的依赖，否则可能会出现Get请求被自动转成Post请求的情况\n\n\n# 依赖引入\n```xml\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-openfeign</artifactId>\n        </dependency>\n```\n# 主启动类\n```java\n@EnableFeignClients\n```\n# 80端微服务接口\n**Serice端**\n```java\n@Component\n@FeignClient(value = \"cloud-payment-service\")\npublic interface PaymentFeignService\n{\n    // 这里面的GetMapping是指的是服务实例中的方法的路径，并且会自动将获取到的路径变量加到路径中去\n    @GetMapping(value = \"/payment/get/{id}\")\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id);\n}\n```\n**Controller端**\n```java\npublic class OrderFeignController\n{\n    @Resource\n    private PaymentFeignService paymentFeignService;\n    @GetMapping(value = \"/consumer/payment/get/{id}\")\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id)\n    {\n        return paymentFeignService.getPaymentById(id);\n    }\n\n}\n```\n\n# 设置超时时间\n```yml\n#设置feign客户端超时时间(OpenFeign默认支持ribbon)\nribbon:\n  #指的是建立连接所用的时间，适用于网络状况正常的情况下, 两端连接所用的时间\n  ReadTimeout: 5000\n  #指的是建立连接后从服务器读取到可用资源所用的时间\n  ConnectTimeout: 5000\n```\n# 设置OpenFeign的日志\n## 自定义Config类，加入Bean设置日志级别\n```java\n@Configuration\npublic class FeignConfig\n{\n    @Bean\n    Logger.Level feignLoggerLevel()\n    {\n        return Logger.Level.FULL;\n    }\n}\n```\n## 在yml配置中设置日志的监控接口\n```yml\nlogging:\n  level:\n    # feign日志以 debug 级别监控 com.atguigu.springcloud.service.PaymentFeignService 接口，debug级别会直接在控制台console中打印出来\n    xtzl.ljw.service.PaymentFeignService: debug\n```\n","categories":["SpringCloud"],"tags":["OpenFeign"]},{"title":"Sleuth","url":"/posts/15024/","content":"> 分布式请求链路跟踪  :   \n> 总结了Springcloud-Sleuth的相关知识\n<!--more-->\n# zipkin  \n>* 安装使用jar包，然后直接敲 java -jar xxx.jar 这个命令就好\n>* 图形化界面端口号9411  \n\n**链路图:**\n![链路图](http://xtzl.wentexl.cn/Sleuth%E5%9B%BE.png)\n>* span 表示链路来源：通俗来说 span 就是一次请求信息\n>* Trance 类似于树结构的Span集合，表示一条调用链路，存在唯一标识\n\n**依赖引入**\n```xml\n     <!--包含了sleuth+zipkin-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zipkin</artifactId>\n        </dependency>\n```\n**yml配置**\n> yml解释：\n>* base-url: 监控的数据需要发到9411上去  \n>* 采样率一般0.5就够了，表示只需要一半的数据就好\n```yml\nspring:\n    zipkin:\n        base-url: http://localhost:9411\n    sleuth:\n        sampler:\n        #采样率值介于0到1之间，1则表示全部采集\n        probability: 1\n```\n\n","categories":["SpringCloud"],"tags":["Sleuth"]},{"title":"Ribbon","url":"/posts/49475/","content":"> 整理了关于Ribbon负载均衡的相关知识\n<!--more-->\n# 核心\n>* 主要核心就是负载均衡\n\n# 依赖引入\n```xml\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n      <version>2.2.1.RELEASE</version>\n      <scope>compile</scope>\n    </dependency>\n```\n# Ribbon的核心组件IRule七种负载均衡的选择方式\n>- - -\n>(出厂默认)RoundRobinRule： 轮询，轮流访问不同的实例\n>- - -\n>RandomRule : 随机，随机访问不同的实例\n>- - -\n>RetryRule:  \n先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内进行重试，获取可用的服务。\n>- - -\n>WeightedResponseTimeRule:  \n对RoundRobinRule的扩展，响应速度越快的实例选择权重就越大，越容易被选择。\n>- - -\n>BestAvailableRule:  \n会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务。\n>- - - \n>AvailabilityFilteringRule:  \n先过滤掉故障实例，再选择并发较小的实例。\n>- - -\n>ZoneAvoidanceRule:  \n>默认规则，复合判断server所在区域的性能和server的可用性选择服务器。\n>- - -\n# Ribbon修改负载均衡的方式\n> **一定不能在主配置类可以扫到的包下，必须新建一个主配置类扫不到的包**\n> 注意点：  \n> * 注解里的服务名要小写\n> * 配置类名不能是MyRule，否则报错\n```java\n// IRule配置类添加\n@Configuration\npublic class MySelfRule {\n    @Bean\n    public IRule myrule(){\n        // 修改为随机方式\n        return new RandomRule(); \n    }\n}\n\n//80端口主运行类注解添加\n//其中name表示的是微服务名称\n@RibbonClient(name = \"cloud-payment-service\",configuration = MySelfRule.class)\n```\n# Ribbon的轮询算法\n> rest接口的第几次请求数 % 服务器集群实例数量 = 实际调用的服务器(实例)的下标\n```java\n// 获取指定服务的所有实例集合\n List<ServiceInstance> instances = discoveryClient.getInstances(\"consul-provider-payment\");\n 例如：\n instances[0]=127.0.0.1:8001\n instances[1]=127.0.0.1:8002\n\n```\n\n\n\n","categories":["SpringCloud"],"tags":["Ribbon"]},{"title":"Consul","url":"/posts/29713/","content":">总结了关于Consul注册中心的相关知识点\n<!--more-->\n# 小知识\n>* 启动consul可以配置环境变量\n>* consul agent -dev 命令来启动consul\n>* Consul的首页： http://localhost:8500\n\n# 依赖导入\n```xml\n   <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n        </dependency>\n```\n# application.yml 配置\n```yml\n###consul服务端口号\nserver:\n  port: 8006\n\nspring:\n  application:\n    name: consul-provider-payment\n  ####consul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n\n```\n# 主启动类\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\n```\n\n","categories":["SpringCloud"],"tags":["Consul"]},{"title":"GitWords","url":"/posts/33301/","content":">记录了git的常用命令\n<!--more-->\n# Git颜色\n>* 红褐色：创建之后没有add，没提交，不在版本控制范围之内，这时候文件是红褐色的，需要先add文件；\n>* 绿色：add之后是文件绿色的，没有提交（commit）;\n>* 蓝色：原本拉取过来之后就有一个文件，改动过后没有提交（commit）是蓝色的，提交之后，变成正常颜色。\n# Git常用操作命令\n>* git ls-files 查看暂存区文件\n>- - -\n>* git init 初始化仓库\n>- - -\n>* git add . 添加所有文件进暂存区\n>- - -\n>* git commit 提交到本地仓库\n>- - -\n>* git push 推送到远程仓库\n>- - -\n>* git pull 从远程仓库拉取最新代码\n>* git pull origin main // 从origin远程仓库拉取分支main的代码到本地的当前分支\n>* git pull -rebase\n>- - -\n>* git checkout -b master 新建一个master分支\n>- - -\n>* git branch -al 查看所有本地分支\n>- - -\n>* git checkout 本地分支名 切换到其他的本地分支\n>- - -\n>* git remote add origin git@github.com:xxxx/xx.git //origin是自定义的远程库的名字，这是给本地仓库添加远程仓库\n>- - -\n>* git remote rm origin 与远程仓库解绑\n>- - -\n>* git remote -v 查看远程仓库的相关信息\n>- --\n>* git push -u origin master  //把当前分支master推送到远程；远程库是空的，所以第一次push加上-u参数；不仅推送了且两个master分支相关联，后续push命令简化git push origin master\n>* git push origin master:main //把本地的master分支上传到origin远程仓库的main分支去\n>* git push origin main // 当且仅当本地分支和远程分支名相同的时候可以直接这样push\n>- - -\n>* git clone git@github.com:lengnuann/L.git xtzl/ljw/ 克隆指令将远程仓库的代码克隆到本地的xtzk/ljw这个文件夹之下\n>- - -\n>* git log 查看日志\n>- - -\n>* git branch --set-upstream-to origin/main master 关联分支，将远程仓库的main分支和master相关联，如果执行失败，先去IDEA的Git下的Pull中获取分支，多刷新一下\n>- - -\n>* git stash 暂存工作区的内容\n>- - -\n>* git stash pop 恢复暂存的工作区内容\n>- - -\n>* git stash list 查询工作区所有stash的列表\n>- - -\n>* git stash apply 例如：git stash apply stash@{2} 表示指定stash@{2}这个暂存版本，如果不指定，则git stash pop默认恢复最新的一次stash\n>- - -\n>* git stash clear 清空stash\n>- - -\n>* git branch --set-upstream-to=gitee/master master :关联远程分支与本地分支，第二个master指的是第本地分支，gitee/master，指的是gitee设置远程仓库名，中的远程分支master,其中远程仓库必须有该分支\n>- - -\n>* git reset --hard 6b2b7aa ：强制回退到某个版本，将不会保存原来的代码（慎用！！！）\n>- - -\n>* git branch  --track  experimental  origin/experimental ：同样是追踪分支\n>* git branch -m master main 将matser分支更名为main分支 \n>- - - \n>* git config --global push.default simple  //设置默认行为为simple。 Git2.0以后\n >- - -\n >* git config --global push.default matching //设置默认行为为matching。Git2.0以前\n >- - -\n >* git reflog // 查看版本信息\n\n# 三种新建项目绑定gitee的远程仓库方式\n# git clone\n> 可以直接git clone远程仓库，就默认绑定clone的那个分支和本地的master分支了\n\n# git remote add -f url\n> 添加 -f 参数相当于执行一次git fetch操作，将会把远程的同名分支都绑定到本地的分支\n> 然后输入 git pull origin master,即可将远程origin的仓库中的master分支绑定拉取到当前分支，如果本地分支没有远程分支已有的分支，则自动在本地创建，但是这样做的弊端就是每次都要手动选择拉取远程仓库的哪一个分支\n\n# git remote add url \n> 执行完这个之后需要手动再执行一次 git fetch\n> git fetch 之后，会自动将远程仓库的同名分支与本地仓库进行匹配绑定，如果本地没有分支，则自动在本地新建同名分支并绑定。\n\n# 两个独立仓库的合并\n> 即便是远程仓库和本地仓库并没有历史相同版本点，也可以进行合并  \n>git pull origin master –allow-unrelated-histories\n> 如果合并失败，就只能使用rebase了\n> git pull --rebase origin master","categories":["Accumulate"],"tags":["git"]},{"title":"LinuxWords","url":"/posts/17418/","content":">总结了一些关于linux的操作命令\n<!--more-->\n\n># SCP命令\n>## 将本地linux服务器的文件拷贝到远程的linux服务器上\n```linux\nscp  /root/file1.txt  username@202.202.146.245:/home/S12004060119/\n```\n>## 将远程linux的文件拷贝到自己的linux本地服务器\n```linux\nscp  username@202.202.146.245:/home/S12004060119/file.txt /root/sh/\n```\n>## 把本地Windows系统的文件夹传到远程linux服务器上\n```linux\nscp -P 22 -r E:\\weixin\\ S12004060119@202.202.146.245:/home/S12004060119/\n```\n># 快捷键\n>Ctrl+l  ：清屏  \nCtrl+o ：执行当前命令，并选择上一条命令  \nCtrl+s ：阻止屏幕输出  \nCtrl+q ：允许屏幕输出  \nCtrl+c ：终止命令  \nCtrl+z ：挂起命令  \nCtrl+d ：输入结束，即EOF的意思，或者注销linux系统\n\n\n# 基本命令\n>* pwd命令  \n>查看当前用户所在的路径\n>* passwd命令  \n>格式： passwd 用户名\n>给用户指定密码\n>* init 命令  \n>Int 3：字符界面\n>Int 5：图形界面\n>* set nu 命令  \n>set nu表示设置行号\n>set nonu表示取消行号\n>* cat命令  复制文件  \n>Cat file1.txt>>file2.txt\n>* cp复制  \n>cp file1.txt /*/*/*\n>* mv命令  \n>mv a b 实现重命名  \n>mv 文件名 移动目的地后的文件名  \n>mv 文件名 修改后的文件名\n","categories":["Accumulate"],"tags":["linux"]},{"title":"IDEA_Hotkeys","url":"/posts/10025/","content":"> IDEA的使用快捷键\n<!--more-->\n>**IDEA使用的快捷键**   \n\n>ctrl + D：复制上一行  \n>- - -\n>Ctrl+D: 同时也可以表示结束输入  \n>- - -\n>Shift + alt +↑（↓） ：上下移动某一行  \n>- - -\n>ctrl+/ ：注释  \n>- - -\n>ctrl+r : 查找和替换  \n>- - -\n>ctrl+alt+t: 抓异常快捷键  \n>- - -\n>shift连按两次：查询  \n>- - -\n>ctrl+alt+b：通过接口查看其实现类 \n>- - - \n>alt+insert+fn : 生成getter和setter方法  \n>- - -\n>ctrl+f: 搜索查看  \n>- - -\n>ctrl+a：一键全选  \n>- - -\n>shift+home:选中单行  \n>- - -\n>Ctrl+i:  选择实现方法  \n>- - -\n>Ctrl+Q: 查看上下文信息\n>- - -\n>shift+tab:取消缩进\n>- - -\n>Ctrl+alt+B: 显示实现类\n>- - -\n>Ctrl+shift+n : 查找类或者文件 \n>- - -\n>Ctrl + O : 快速重写\n>- - -\n>Ctrl + P : 查看参数\n>- - -\n>- - -\n>**调试**\n>* F8单步调试。不进入函数内部\n>- - -\n>* F7 单步调试 进入函数肉部\n>- - -\n>* Shift+F7 选择要进入的函数\n>- - -\n>* Shift+F8 跳出函数\n>- - -\n>* Alt+F9 运行到断点\n>- - -\n>* Alt+F8 执行表达式查看结果\n>- - -\n>* F9继续执行，进入下一个断点或执行完程序\n>- - -\n>* Ctr|+F8 设置/取消当前行断点\n>- - -\n>* Ctrl+Shift+F8 查看断点\n>- - -","categories":["Accumulate"],"tags":["Hotkeys"]},{"title":"Eureka","url":"/posts/57702/","content":">关于EureKa的知识笔记：Eureka的服务注册与发现\n<!--more-->\n# 小知识\n> * Eureka不用自己注册自己\n> * 注意启动顺序，服务端必须先启动才能检索到客户端\n> * 集群配置：互相注册，相互守望\n> * 配置host之后记得在cmd使用ipconfig /flushdns刷新一下\n> * 大坑！！！:配置集群之后，直接点击链接是访问不了的！！多了一层路径！必须要手动输入地址!\n> * defaultZone如果有多个url，不同的url通过逗号隔开\n\n># 依赖引入\n>## 服务注册端 server\n```xml\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n        </dependency>\n```\n>## 客户端 client\n```xml\n         <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n```\n\n># 单机版在Application.yml中配置\n>## 单机版在server端中的yml配置\n```yml\neureka:\n instance:\n   hostname: localhost  #eureka服务端的实例名字\n client:\n   register-with-eureka: false    #表示不向注册中心注册自己\n   fetch-registry: false   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\n   service-url:\n     #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n     defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\n```\n>## 单机版在client端的yml配置\n```yml\neureka:\n  client:\n    #表明自己需要注册进Eureka中\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有信息，默认为true。\n    #单节点无所谓，集群的话必须设置为true才能配合ribbon使用负载均衡\n    fetch-registry: true\n    service-url:\n      #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n      #单机指向自己\n      defaultZone: http://localhost:7001/eureka\n\n```\n\n\n> # 集群版在Application.xml中的配置\n> ## 在Client端的yml配置\n>- - -\n> 最主要的在于defalutZone的变化  \n> eureka7001.com是host文件配置的主机名\n> \n```yml\neureka:\n  client:\n    register-with-eureka: true\n    fetch-registry: true\n    service-url:\n    #集群指向所以注册中心的eureka\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n```\n>## 在Server端的yml配置\n```yml\neureka:\n  instance:\n    hostname: eureka7002.com  #eureka服务端的实例名字\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n    service-url:\n    #集群指向其他eureka\n      defaultZone: http://eureka7001.com:7001/eureka\n```\n\n># 在主运行类中的注解标识\n>## Server端使用的主键\n```java\n@EnableEurekaServer\n```\n>## Client端使用的注解\n```java\n@EnableEurekaClient\n```\n\n># 服务发现\n> 将服务信息放到到注册中心去  \n> 通过服务发现来活动该服务的信息\n```java\n    // Controller 添加\n    @Resource\n    private DiscoveryClient discoveryClient;\n    \n    // 主运行类添加\n    @EnableDiscoveryClient\n```\n\n# Instance配置\n```yml\n  instance:\n    # 微服务下实例名称修改\n    instance-id: payment8002\n    # 显示IP地址\n    prefer-ip-address: true\n```\n># Eureka的自我保护机制\n>自我保护机制:默认情况下EurekaClient定时向EurekaServer端发送心跳包  \n如果Eureka在server端在一定时间内(默认90秒)没有收到EurekaClient发送心跳包 ,便会直接从服务注册列表中剔除该服务  \n>但是在短时间( 90秒中)内丢失了大量的服务实例心跳,\n这时候EurekaServer会开启自我保护机制,不会剔除该服务(该现象可能出现在网络不通的情况使得 EurekaClient为出现宕机  \n>此时如果换做别的注册中心如果一定时间内没有收到心跳会将剔除该服务,这样就出现了严重失误,因为客户端还能正常发送心跳只是网络延迟问题，而保护机制是为了解决此问题而产生的)\n\n># 关闭Eureka的自动保护机制\n>server端\n```yml\n## Server端的yml中设置关闭自我保护机制，保证不可用服务被及时踢除\neureka:\n  server:\n     enable-self-preservation: false\n     eviction-interval-timer-in-ms: 2000\n```\n>client端设置心跳响应时间\n```yml\neureka:\n  instance:\n#    Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\n   lease-renewal-interval-in-seconds: 1\n#    Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\n   lease-expiration-duration-in-seconds: 2\n```\n","categories":["SpringCloud"],"tags":["Eureka"]},{"title":"Summary","url":"/posts/42402/","content":">介绍和总结整个SpringCloud的理论体系\n# SpringCloud架构图\n![SpringCloud架构图](http://xtzl.wentexl.cn/SpringCloud%E6%9E%B6%E6%9E%84%E5%9B%BE.png)\n\n<!--more-->\n# 注册中心的异同点\n>## **CAP**\n>- - -\n>**解释**：  \n>C :(强一致性):   对某个指定的客户端来说，读操作保证能够返回最新的写操作结果。  \n>A :(可用性):     非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应)  \n>P :(分区容错性): 当出现网络分区后，系统能够继续“履行职责”。\n>- - -\n>* 分布式系统理论上不可能选择CA架构，只能选择CP或者AP 架构。\n>* CAP理论关注粒度是数据，而不是整个系统的设计策略\n>* AP(Eureka) ; CP(Consul) ; HA(高可用，也是Eureka)  \n>![CAP](http://xtzl.wentexl.cn/SpringCloud/CAP.png)\n\n\n# SpringCloud总图\n![总图](http://xtzl.wentexl.cn/SpringCloud.png)\n\n\n","categories":["SpringCloud"],"tags":[]},{"title":"Dependencies","url":"/posts/18669/","content":"> 该博文主要记录了在Cloud微服务开发中常用的依赖\n\n# 父工程\n```xml\n<!-- 统一管理jar包版本 -->\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n        <junit.version>4.12</junit.version>\n        <log4j.version>1.2.17</log4j.version>\n        <lombok.version>1.16.18</lombok.version>\n        <mysql.version>5.1.47</mysql.version>\n        <druid.version>1.1.16</druid.version>\n        <mybatis.spring.boot.version>1.3.0</mybatis.spring.boot.version>\n    </properties>\n\n    <!-- 1、只是声明依赖，并不实际引入，子项目按需声明使用的依赖 -->\n    <!-- 2、子项目可以继承父项目的 version 和 scope -->\n    <!-- 3、子项目若指定了 version 和 scope，以子项目为准 -->\n    <dependencyManagement>\n        <dependencies>\n            <!--spring boot 2.2.2-->\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-dependencies</artifactId>\n                <version>2.2.2.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <!--spring cloud Hoxton.SR1-->\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Hoxton.SR1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <!--spring cloud alibaba 2.1.0.RELEASE-->\n            <dependency>\n                <groupId>com.alibaba.cloud</groupId>\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n                <version>2.1.0.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n\n<!-- 以上依赖不能出现在子工程 -->\n\n\n            <dependency>\n                <groupId>mysql</groupId>\n                <artifactId>mysql-connector-java</artifactId>\n                <version>${mysql.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.alibaba</groupId>\n                <artifactId>druid</artifactId>\n                <version>${druid.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>org.mybatis.spring.boot</groupId>\n                <artifactId>mybatis-spring-boot-starter</artifactId>\n                <version>${mybatis.spring.boot.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>junit</groupId>\n                <artifactId>junit</artifactId>\n                <version>${junit.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>log4j</groupId>\n                <artifactId>log4j</artifactId>\n                <version>${log4j.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>org.projectlombok</groupId>\n                <artifactId>lombok</artifactId>\n                <version>${lombok.version}</version>\n                <optional>true</optional>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n\n# 子工程\n```xml\n\n    <dependencies>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/com.alibaba/druid -->\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid-spring-boot-starter</artifactId>\n            <version>1.2.8</version>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-jdbc</artifactId>\n        </dependency>\n           <!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n     </dependencies>\n```\n# 通用工程依赖\n```xml\n <dependencies>\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all -->\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-all</artifactId>\n            <version>5.1.0</version>\n        </dependency>\n</dependencies>\n\n```","categories":["SpringCloud"],"tags":["dependencies"]},{"title":"Configuration_header","url":"/posts/65104/","content":">在Web开发中，该博文对常用配置类的配置头进行了总结\n<!--more-->\n# Web开发常用配置头的总结\n\n>## Mabatis的 Mapper.xml 配置头\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"xtzl.ljw.Dao.PaymentMapper\">\n</mapper>\n``` \n \n>## Bean.xml 配置头\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n</beans>\n\n```","categories":["Accumulate"],"tags":["Configuration_header"]},{"title":"Mabtis && MybatisPlus","url":"/posts/31024/","content":">总结了Mabtis和plus的一些小细节的知识\n<!--more-->\n\n# Mabatis&&Plus 小知识总结\n\n## type-aliases-package\n### type-aliases-package作用\n>在Mybatis的mapper.xml文件中resultType的type或者paramterType会返回自定义entity  \n此时可以用全类名名来指定这些实体。\n### type-aliases-package配置\n```yml\nmybatis:\n    type-aliases-package=xtzl.ljw.entities\n```\n\n## 指定Mapper路径\n```yml\nmybatis:\n    mapper-locations: classpath:mapper/*.xml\n```\n## useGeneratedKeys\n>在使用useGeneratedKeys=\"true\"后返回值是1，期待返回实体主键\n>insert方法返回值依然是修改行数  \n需要从传入的实体中取对应属性值。  \n\n比如user表对应User类，主键是id\n那么int i =insertUser（user）;  \n方法执行后 i 还是1\n\n但是user.getId();得到的值就是主键了\n>- - -\n>一般来说需要和 keyProperty=\"id\" 联用，意为指定主键\n\n# MybatisPlus配置\n## 接口配置\n### Mapper父类\n```java\n@Mapper\npublic interface stuTeaMapper extends BaseMapper<StuTea> {}\n```\n### Service父类接口\n```java\npublic interface StuTeaService extends IService<StuTea>\n```\n### Service父类实体\n```java\n@Service\npublic class StuTeaServiceImpl extends ServiceImpl<stuTeaMapper,StuTea> implements StuTeaService {}\n```\n> - - -\n## yml配置\n```yml\n# mybatis_plus配置\nmybatis-plus:\n  mapper-locations: classpath:/mapper/*.xml\n  configuration:\n    #将数据库的带下划线给去掉然后映射到实体类的属性上去\n    map-underscore-to-camel-case: true\n    # 可返回自增长的主键\n    use-generated-keys: true\n```\n","categories":["TechStack"],"tags":["Mabtis"]},{"title":"JavaNorms","url":"/posts/17711/","content":"> 在学习过程中，对一些常见的开发格式和开发规范，以及一些规范类进行了整理和总结\n<!--more-->\n\n# 规范类:\n## POJO 类\n```markdown\n\"Plain Ordinary Java Object\"，简单普通的java对象。主要用来指代那些没有遵循特定的java对象模型，约定或者框架的对象。\n\nPOJO的内在含义是指那些:\n有一些private的参数作为对象的属性，然后针对每一个参数定义get和set方法访问的接口。\n没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。\n```\n\n## JavaBean\n```markdown\nJavaBean 是一种JAVA语言写成的可重用组件。JavaBean符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。\n它的方法命名，构造及行为必须符合特定的约定:\n    · 所有属性为private。\n    · 这个类必须有一个公共的缺省构造函数。即是提供无参数的构造器。\n    · 这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范。\n    · 这个类应是可序列化的。实现serializable接口。\n\n因为这些要求主要是靠约定而不是靠实现接口，所以许多开发者把JavaBean看作遵从特定命名约定的POJO\n```\n# Rest风格详情介绍\n>* GET （常用于查询）\n>- - -\n>* POST（常用于保存）\n>- - -\n>* PUT（常用于更新修改）\n>- - -\n>* DELETE（常用于删除）\n\n## 传统风格: RequestMapping\n><![传统风格](http://xtzl.wentexl.cn/CT.png)  \n## Restful风格: 增删改查\n![Rest](http://xtzl.wentexl.cn/Rest%E9%A3%8E%E6%A0%BC.png)\n## 两种模式的区别：\n>**风格与规则的区别：**  \n>Restful风格要简洁了很多，并且把行为都隐藏了  \n风格是一种约定俗成的方式，这种约定并不是一定要遵守的，可以不去使用这种约定，即也可以使用传统风格。而规范呢是一种大家必须遵守的规则，你如果不按照这个规范来书写代码，那么就不被允许运行。  所以被叫做REST风格，而不是叫做REST规范。  \n\n\n","categories":["JavaStudy"],"tags":["JavaNorms"]},{"title":"Annotation","url":"/posts/54839/","content":"> 注解的使用\n<!--more-->\n\n# 常用注解的解释与使用\n\n## 与 SQL 有关的注解\n### @Param\n首先明确这个注解是为SQL语句中参数赋值而服务的。    \n\n @Param的作用就是给参数命名，比如在mapper里面某方法A（int id）  \n 当添加注解后A（@Param(\"userId\") int id）  \n 也就是说外部想要取出传入的id值，只需要取它的参数名userId就可以了。  \n 将参数值传如SQL语句中，通过#{userId}进行取值给SQL的参数赋值\n\n```SQL\nmapper:\npublic User selectUser(@Param(\"userName\") String name,@Param(\"password\") String pwd);\n\nxml:\n<select id=\"selectUser\" resultMap=\"User\">  \n   select * from user  where user_name = #{userName} and user_password=#{password}  \n</select>\n可发现，userName为映射名，相当于起的是个别名\n\n注意点：  \n·当使用了@Param注解来声明参数的时候，SQL语句取值使用#{}，${}取值都可以。\n·当不使用@Param注解声明参数的时候，必须使用的是#{}来取参数。使用${}方式取值会报错。\n·不使用 @Param注解时，参数只能有一个，并且是Javabean。在SQL语句里可以引用JavaBean的性，而且只能引用JavaBean的属性。\n\n\n实际上：\n即便是不使用这个注解，也可以直接通过#{}去访问NewUser的成员变量，也是可以的，但是也只能有一个参数，这个参数就只能是NewUser这个JavaBean对象\n    <insert id=\"insertN\" parameterType=\"xtzl.boot.bean.NewUser\">\n        insert into user (username,password,sex,status) values (#{username},#{password},#{sex},#{status})\n    </insert>\n\n```\n### @TableField\n>@TableField(exist = false) 注解加载bean属性上，表示当前属性不是数据库的字段，但在项目中必须使用，这样在新增等使用bean的时候，mybatis-plus就会忽略这个，不会报错。\n```java\n    // 插入\n    @TableField(fill = FieldFill.INSERT)\n    private LocalDateTime createTime;\n    // 插入或更新的时候填充字段\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private LocalDateTime updateTime;   \n\nDEFAULT ：默认不处理\nINSERT ： 插入操作时进行填充字段\nUPDATE ：更新操作时填充字段\nINSERT_UPDATE ：插入和更新操作时填充字段\n\n\n```\n# Spring有关注解\n## @EnableWebSecurity\n>**EnableWebSecurity注解有两个作用**\n>* 1: 加载了WebSecurityConfiguration配置类, 配置安全认证策略。\n>* 2: 加载了AuthenticationConfiguration, 配置了认证信息。\n## @PostConstruct\n> 该注解主要用于初始化的时候使用，标注了该注解的方法，将会在所在类的依赖注入之后执行    \n> 类的构造方法是造本类的依赖注入之前就会执行\n## @ControllerAdvice\n>@ControllerAdvice就是@Controller 的增强版。@ControllerAdvice主要用来处理全局数据，一般搭配@ExceptionHandler、@ModelAttribute以及@InitBinder使用。可以指定某个包下的所有Controller，也可以自定义注解，指定包含了自定义注解的Controller\n>- - -\n## @ModelAttribute\n>表示此方法会在执行目标Controller方法之前执行\n## @InitBinder\n>@ControllerAdvice结合@InitBinder还能实现请求参数预处理，即将表单中的数据绑定到实体类上时进行一些额外处理。\n### 使用\n```java\n@InitBinder\n    public void initBinder(WebDataBinder dataBinder){\n        /*\n         * 创建一个字符串微调编辑器\n         * 参数{boolean emptyAsNull}: 是否把空字符串(\"\")视为 null\n         */\n        StringTrimmerEditor trimmerEditor = new StringTrimmerEditor(true);\n        /*\n         * 注册自定义编辑器\n         * 接受两个参数{Class<?> requiredType, PropertyEditor propertyEditor}\n         * requiredType：所需处理的类型\n         * propertyEditor：属性编辑器，StringTrimmerEditor就是 propertyEditor的一个子类\n         */\n        dataBinder.registerCustomEditor(String.class, trimmerEditor);\n        //日期格式的字符串转换成Date对象\n       dataBinder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"), false));\n        \n   dataBinder.addValidators(paramVOValidator);\n\n}\n```\n## @ExceptionHandler\n>@ControllerAdvice最常见的使用场景就是全局异常处理。比如文件上传大小限制的配置，如果用户上传的文件超过了限制大小，就会抛出异常,此时可以通过@ControllerAdvice结合@ExceptionHandler定义全局异常捕获机制\n## 批注\n>这三个注解都可以在普通的Controller类上使用,ControllerAdvice只是作用范围可以自定义(默认全部)\n>- - -\n\n","categories":["Accumulate"],"tags":["Annotation"]},{"title":"Maven","url":"/posts/35182/","content":"\n> 关于Maven的一些小知识点\n<!--more-->\n\n# 直接手动从中央仓库下载依赖\n>## 地址：https://www.mvnrepository.com/\n>## 下载格式\n```markdown\n    mvn dependency:get -DremoteRepositories=https://mvnrepository.com/artifact/org.projectlombok/lombok -DgroupId=org.projectlombok -DartifactId=lombok -Dversion=1.18.12\n\n特别注意： 等号后面一定不能留空格，否则会出现找不到坐标的错误\n\n```\n# 坐标\n>注：groupId 在新建项目的时候可以自行指定，以便于在项目中新建通用模块之后导入其他模块\n> - - - \n> groupId和artifactId是maven管理项目包时用作区分的字段，就像是地图上的坐标。  \nartifactId：artifactId一般是项目名或者模块名。  \ngroupId：groupId分为几个字段，例如cn.com.fullstack，前面的com叫【域】，后面的是你自己起的域名。\n>- - -\n>groupId一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。  \n域又分为org、com、cn等等许多，其中org为非营利组织，com为商业组织。  \n举个apache公司的tomcat项目例子：这个项目的groupId是org.apache，它的域是org（因为tomcat是非营利项目），公司名称是apache，artigactId是tomcat。","categories":["TechStack"],"tags":["maven"]},{"title":"Notes","url":"/posts/52648/","content":"\n> SpringCould的学习随堂笔记\n\n<!--more-->\n\n# SpringCould 随堂笔记\n\n>## 父工程框架  \n  \n> ### 父工程统一管理Jar包\n```xml\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>12</maven.compiler.source>\n    <maven.compiler.target>12</maven.compiler.target>\n    <junit.version>4.12</junit.version>\n    <lombok.version>1.18.10</lombok.version>\n    <log4j.version>1.2.17</log4j.version>\n    <mysql.version>8.0.21</mysql.version>\n    <druid.version>1.0.9</druid.version>\n    <mybatis.spring.boot.version>2.2.2</mybatis.spring.boot.version>\n  </properties>\n```\n>### 必要依赖\n```xml\n    <dependencies>\n      <!--spring boot 2.2.2-->\n      <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-dependencies</artifactId>\n        <version>2.2.2.RELEASE</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      <!--spring cloud Hoxton.SR1-->\n      <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-dependencies</artifactId>\n        <version>Hoxton.SR1</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      <!--spring cloud alibaba 2.1.0.RELEASE-->\n      <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n        <version>2.1.0.RELEASE</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n\n```\n\n\n>## 子工程application配置文件\n### 数据源配置\n```yml\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: org.gjt.mm.mysql.Driver\n    url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&characterEncoding=utf-8&useSSL=false\n    username: root\n    password: root\n\n```\n### 唯一标识\n```yml\nspring:\n  application:\n    name: cloud-payment-service\n```\n## Devtools 开启热部署\n> 注：电脑不太行不建议开启，太锤子卡了\n>1. 导入jar包\n>2. 引spring-boot-maven-plugin插件\n>3. 在IDEA的Compile中调设置.\n>4. 重启IDEA\n\n\n## RestTemplate\n> 可用 订单80端口去调用8001端口的服务进行操作\n```java\n  @Bean\n    public RestTemplate getRestTemplate(){\n        return new RestTemplate();\n    }\n```\n> ### 两种方式：\n```java\n  // 第一种是写死的，第二种是URL为集群的服务名\n  // 微服务可能有多个端口\n   // public static final String PAYMENT_URL=\"http://localhost:8001\";\n    public static final String PAYMENT_URL=\"http://CLOUD-PAYMENT-SERVICE\";\n    @Resource\n    private RestTemplate restTemplate;\n\n    // GET请求实际上调用了POST请求\n    @GetMapping(\"/consumer/payment/create\")\n    public CommonResult<Payment> create(Payment payment){\n        return restTemplate.postForObject(PAYMENT_URL+\"/payment/create\",payment,CommonResult.class);\n    }\n\n    @GetMapping(\"/consumer/payment/get/{id}\")\n    public CommonResult<Payment> getPayment(@PathVariable(\"id\") Long id){\n        System.out.println(id);\n        log.info(String.valueOf(id));\n        return restTemplate.getForObject(PAYMENT_URL+\"/payment/get/\"+id,CommonResult.class);\n    }\n\n坑： 此处我使用@Pathgram 无法获取到路径变量\n```\n**细节**  \n>在微服务的Controller中，涉及到POST请求，一定不要忘记加@RequstBody这个注解，当80端口的请求到微服务端口的方法时\n```java\n    @PostMapping(\"/payment/create\")\n    public CommonResult create(@RequestBody Payment payment){\n    }\n```\n# 负载均衡\n> 微服务没被写死端口号的时候\n> 在配置类里面必须加 @LoadBalanced 才行\n> @LoadBalanced赋予RestTemplate负载均衡的能力:轮班值日\n```java\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate(){\n        return new RestTemplate();\n    }\n```\n>**RestTemplate返回对象选择**\n![RestTemplate返回](http://xtzl.wentexl.cn/restTemplate%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1.png)\n\n","categories":["SpringCloud"],"tags":[]},{"title":"CppFunctions","url":"/posts/12049/","content":"> 总结了C++常用函数\n\n<!-- more-->\n\n># C++ 函数总结\n\n>## 判断大小写\n```Cpp\n//用来判断一个字符是否为字母，如果是字符则返回非零，否则返回零。\n 1.isalpha()\n\n//用来判断一个字符是否为数字或者字母，也就是说判断一个字符是否属于a~z||A~Z||0~9。是返回非零，不是返回0。\n2.isalnum()\n\n//用来判断一个字符是否为小写字母，也就是是否属于a~z。是返回非零，不是返回0。\n3.islower()\n\n//用来判断一个字符是否为大写字母。是返回非零，不是返回0。\n4.isupper()\n\n//a为字符时，如果a是小写字母则将其转换为大写字母，否则不变。a为数字则将其按ASCLL码转换为对应字符。（其实即使a是字符，输入之后还是会将其转换为int类型）\n5. char c = toupper(a)\n\n//a为字符时，如果a是大写字母则将其转换为小写字母，否则不变。a为数字则将其按ASCLL码转换为对应字符。\n6.char c=tolower(a)\n\n//用来判断一个字符是否为数字，如果是数字则返回非零，否则返回零。\n7.isdigit()\n\n//将数字转换为字符串，这里注意如果是浮点型数转字符，会将精度范围内小数点后的数全部显示出来\n8.to_string()\n//数字转字符串：例如：\nfloat b = 2.;\ns = to_string(b);\ncout << s<<\" \"<<s.size();\n输出为：2.000000 8\n```\n\n# 字符串\n> ## 字符串的一些常用操作\n```Cpp\n  // count删了之后只替换一个字符\n  str.replace(index,count,instead) ->void\n  // 重载很多，startIndex默认为0，从字符串下标为0开始找\n  str.find(tagetStr,startIndex) -> first_index\n\n```\n> ## 字符串的复制和拼接\n  ```Cpp\n  strcpy函数进行字符串的复制\n  //将 first_name 复制给 full_name\n  strcpy(full_name, first_name);   \n\n------------------------------------------------------------------------\n\n  strcat()函数进行字符串的拼接\n  //将 last_name 拼接在 full_name 之后\n  strcat(full_name, last_name);   \n\n  // 字符与字符串之间可以用 + 来连接\n  string s; char ch;\n  s = s + ch;\n  ```\n\n## 字符串与整数的转换\n```Cpp\n// nums为字符串，stoi函数存在于头文件<string>中\nint k = stoi(nums);\n\n// num为整数，to_string函数也在string中\nstring s=to_string(num)\n```\n\n## 字符与整数的互换\n```Cpp\n// 字符转整数，直接强转\nchar c='8' ;\nint a ;\na =(int) (c - '0') ;\n\n// 整数转字符\nint b;\nchar c;\nc = b + '0'\n\n```\n\n# algorithm 函数中的reverse\n```Cpp\nreverse无返回值\n\nstr.begin()是指向str的第一个元素\nstr.end()是指向最后一个元素的后一个位置\n\n1.reverse(str.begin(),str.end()) 反转整个字符串\n \t \n2.reverse(vector.begin(),vector.end()) 反转向量\n \n3.reverse(a,a+strlen(a)) 反转数组\n```","categories":["C/CPP"],"tags":["functions"]},{"title":"CppHeadFiles","url":"/posts/56443/","content":"> 介绍与总结了C++的常用头文件\n\n<!-- more -->\n# C++头文件总结\n## 多函数头文件\n```markdown\n1.include<iostream> 输入输出流，得调用这个头文件才能使用cin,cout\n\n2.#include<iomanip> 可以调用一些函数，如fixed()<<setprecision()等\n\n3.#include<cmath> 用于调用一些数学函数\n\n4.#include<string> 调用这个头文件才可以调用字符串类型的变量\n\n5.#include<algorithm> 用于调用各种函数，如sort()\n\n```\n\n## 数据结构头文件\n```markdown\n#include<list> : 列表 \n\n#include<map> ： map集合\n\n#include<queue> : 队列\n\n#include<vector> : 不定长数组\n\n#include<stack> : 栈\n\n```\n\n","categories":["C/CPP"],"tags":[]},{"title":"CppLei","url":"/posts/20863/","content":">介绍了C++中常用的类型、关键字\n<!-- more -->\n\n# C++常用类型及其关键字整理\n>* 在C++中，指针和数组都是采用的引用传递，普通结构体，类，和其他基础类型都是采用的值传递\n>* 只有加了&才能让其他类型的数据使用引用传递\n>* 如果是指针传递，指针变量本身没加&就仍然是值传递，但是指针指向的地址上的改变是形参和实参一致的\n>## Bool 类型\n```cpp\nbool 变量是 值保存  真或者假这个值 （TRUE 或者 FAUSE），1表示真，0 表示假。在Ｃ语言中所有的非零值都为真所以给bool变量赋值，赋值为0则为0。赋值为非0 则为1。\n```\n>## Cout 关键字\n```cpp\nCout<<“sadasd”<< endl\n```\n>## Cin： 输入\n```cpp\nCin >> n;\n\nCin.getline(arrchar,20);\n\n// 直接使用string库函数中的getline可以得到一个字符串输入s\nvoid main() {s\n\tint A;\n\tint B;\n\tstring str;\n\n\t// 可接收一个包含空格的字符串，并赋值给str,最好将getline先在前面\n\tgetline(cin, str);\n\t// cin遇到空格和回车都会执行结束\n\tcin >> A;\n\tcin >> B;\n\n\tint C = A + B;\n\tcout << C;\n\tcout << str;\n}\n\n注：getline()函数中的arrchar是表示的字符数组，20表示的是最多输入19个字符，或者遇到回车结束\n```\n>## const 类型\n```Cpp\nconst int max =500;\nconst static int arr[] = {1,2,3,4}\t\n注：const关键字主要是用来声明常量的，定义之后不能改变了\n```\n>## string 关键字\n```Cpp\nstring s1=”asd”;\n\nstring s2=”asdasd”;\n\nString s= s1+s2; // 字符串的拼接\n\n类比java的input.nextline（获取输入的整个一行）\ngetline(cin,s);// 获取输入的整个一行并赋值给字符串变量s\n\ns.length() // 获取字符串的长度，会包括空格\n\nS.substr(start,counts); // 从下标为start开始取，一共取counts个字符\n\nS.substr(start); // 从下标为start开始取，取遍整个字符串后面的所有字符\n```\n>## 结构体\n```Cpp\n    struct stu{\n        string name;\n        int age;\n    }\n\n    void main(){\n        stu a[10];\n    }\n\n    注:结构体可以直接用名字进行引用\n```\n>## &的引用\n```markdown\n    可在自定义的函数的参数前加一个&，main函数直接传参数，便可在地址上修改参数的值\n```\n>## Pair类型\n```cpp\n    定义和初始化：\n    pair<int,int> data;\n\n    pair<int,int> p2(p1); // 用已经有的pair对象p1来初始化p2\n    \n    pair<int,double> p3(1,1.2); \n\n    pair<int,int> p4 ;  //没有写初始化值，自动初始化为(0,0)\n\n注：每个pair可以存储两个值，这两个值可以是不同的数据类型，存储的值可以是基本数据类型，也可以是自己定义的数据类型\n```\n\n>## 可变数组 Vectory\n```cpp\n   vector <int> arr; \n\tarr.resize(10); // 给该数组分配十个空间\n\tarr[0] = 1;\n\tarr.push_back(20); // 将20放到数组的最后\n\tvector <int> arr2 (10,3); // 给开辟10个空间，给每个空间都初始化为3\n\t// 使用arr[0]=1,这样的方式赋值的时候，一定是已经给数组分配过空间了的，否则编译失败\n\t// 但是使用pushback的话，可以先不分配空间\n\n\t// 迭代器自动遍历整个数组\n\t// arr.end()的位置是在数组的最后一个元素的下一个位置\n\tfor (auto p = arr2.begin(); p != arr2.end(); p++) {\n\t\tcout << *p << \" \";\n\t\tcout << *p << endl;\n\t}\n\n```\n\n>## set集合 ： 存储不含重复元素的集合\n```cpp\n\n    set<int> sarr; \n\tsarr.insert(1); // 给集合添加元素 1\n\tsarr.insert(2); // 给集合添加元素 2\n\tsarr.insert(3); // 给集合添加元素 3\n\n\tsarr.find(3); // 返回值是指针，在集合中寻找有没有3\n\n\tif (sarr.find(1)==sarr.end()) { // 指针指向最后一个元素的下一个位置\n\t\t// 查找失败，集合中没有\n\t\tcout << \"集合中没有这个元素\" << endl ;\n\t}\n\telse {\n\t\t// 找到了\n\t\tcout << *sarr.find(1) << endl;\n\t}\n\tsarr.erase(2);// 从集合中删除 2 这个元素\n\n\t// set集合的遍历\n\tfor (auto p = sarr.begin(); p != sarr.end(); p++) {\n\t\tcout << *p << endl;\n\t}\n\n```\n\n>## map集合 ： 存储键值对的集合\n```cpp\n    map<string,int> mymap;\n\t//添加元素\n\tmymap[\"xt\"] = 3; \n\tmymap[\"zl\"] = 4;\n\tmymap.insert({ \"xxx\",4 });\n\tfor (auto p = mymap.begin(); p != mymap.end(); p++) {\n\t\t// first 表示的是键，second 表示的是值\n\t\t// p代指map集合中的一个元素，实际上是个指针，指向结构体\n\t\tcout << p->first << \" : \" << p->second << endl;\n\t}\n\n```\n\n>## 栈 stack ：先入后出\n```cpp\n    stack<int> sta;\n\tsta.push(1);\n\tsta.push(2);\n\n\t// 打印栈顶元素\n\tcout << sta.top() << endl;\n\tsta.pop(); // 出栈且无返回值\n\tsta.size(); // 获取栈的长度\n```\n>## 队列：先入后出\n```cpp\n    queue<int>qu;\n\t// 入队\n\tqu.push(1);\n\tqu.push(2);\n\tqu.push(3);\n\t// 出队\n\tqu.pop();\n\t// 获取队首\n\tqu.front();\n\t// 获取队尾\n\tqu.back();\n\t// 长度\n\tqu.size();\n    // 入队            \n    pos.emplace(x);\n```\n>## bitset数组\n```cpp\n定义：类似一个字符数组，直接输出的话，是一个二进制数，如果按照数组输出的话，和直接输出相反\n\nbitset<5> b;\t\t // 表示5个二进制位，初始化为0 ： 00000\n\tbitset<5> b(3);\t    // 1是无符号数，输出b为 ：00011 , 此时括号里的数就是二进制数所表示的十进制数\n\tbitset<5> b(\"111\"); //111是字符串，表示在b的低3位是1 : 00111\n\tstring s; int pos, n;\n\tbitset<5>b(s, pos, n);// 类似于上面那个，但是这个是截取部分s然后作为参数，从下标为pos开始，读取n个字符\n    \n    // 下面的是返回为bool类型的函数 ： \n\tb.any(); // 是否有 1\n\tb.none(); //是否不存在1\n\tb.count();//1的个数\n\tb.size();//b中的元素个数\n\tb.test(3);//下标为3的元素是不是 1 \n    \n    // 操作函数\n\tb.flip(); // 所有位取反\n\tb.flip(i); // 第i为取反\n\tb.reset(); // 所有位归零\n\tb.reset(i);// 第i位归零\n\t\n\tunsigned long long1=b.to_ulong();// 转换成unsignedlong的类型\n```\n\n>## sort排序\n```cpp\n    vector<int> arr3(10); // 先分配十个空间\n\n\t// 默认为升序\n\tsort(arr3.begin(), arr3.end()); // 从begin到end这部分进行排序，左开右闭[ )，因为end所在的位置是没有数据的\n\t\n\tvector<int> arr4(10);\n\tsort(arr4.begin(), arr4.end(), cmp); // begin的是x，end的是y\n\n// cmp自定义排序\n// 返回1就顺序不变，如果返回0就会自动交换位置，实际上就是利用了快速排序的原理\n    bool cmp(int x, int y) { \n\t    return x > y; //降序\n    }\n\n// swap交换\n    swap(a[1],a[2]); // 表示把a数组中的下标为1和2的元素位置进行交换\n\n```\n","categories":["C/CPP"],"tags":["grammer","cpp"]},{"title":"Markdown 教程","url":"/posts/33206/","content":"\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n> Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\n> Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\n> Markdown 编写的文档后缀为 `.md`, `.markdown`。\n\n<!-- more -->\n末尾连续两次空格是换行\n\n# 标题\n👆 看起来就像上面这个。Markdown 标题有两种格式。\n\n## 使用 `=` 和 `-` 标记一级和二级标题\n`=` 和 `-` 标记语法格式如下：\n```markdown\n我展示的是一级标题\n=================\n\n我展示的是二级标题\n-----------------\n```\n\n## 使用 `#` 号标记\n使用 `#` 号可表示 1-6 级标题，一级标题对应一个 `#` 号，二级标题对应两个 `#` 号，以此类推。\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n# 段落样式\nMarkdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。\n当然也可以在段落后面使用一个空行来表示重新开始一个段落。\n\n## 字体\nMarkdown 可以使用以下几种字体：\n> *斜体文本*\n> **粗体文本**\n> ***粗斜体文本***\n```markdown\n*斜体文本*\n_斜体文本_\n\n**粗体文本**\n__粗体文本__\n\n***粗斜体文本***\n___粗斜体文本___\n```\n\n## 分隔线\n可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。\n也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n> - - -\n> 我\n> - - -\n> 裂\n> - - -\n> 开\n> - - -\n> 了\n>\n> - - -\n```markdown\n***\n* * *\n*****\n- - -\n----------\n```\n\n## 删除线\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 `~~` 即可，实例如下：\n> RUNOOB.COM\n> GOOGLE.COM\n> ~~BAIDU.COM~~\n```markdown\nRUNOOB.COM\nGOOGLE.COM\n~~BAIDU.COM~~\n```\n\n## 下划线\n下划线可以通过 HTML 的 `<u>` 标签来实现：\n> <u>带下划线文本</u>\n```html\n<u>带下划线文本</u>\n```\n\n## 脚注\n脚注是对文本的补充说明。Markdown 脚注的格式如下:\n```markdown\n[^要注明的文本]\n```\n以下实例演示了脚注的用法：\n> 阿米娅[^阿米娅]\n```markdown\n创建脚注格式类似这样 [^阿米娅]\n[^阿米娅]: 博士，您还有很多事情需要处理。现在还不能休息哦。\n```\n\n# Markdown 列表\nMarkdown 支持有序列表和无序列表。\n无序列表使用星号(`*`)、加号(`+`)或是减号(`-`)作为列表标记：\n> * 第一项\n> * 第二项\n> * 第三项\n```markdown\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n```\n有序列表使用数字并加上 `.` 号来表示，如：\n> 1. 第一项\n> 2. 第二项\n> 3. 第三项\n```markdown\n1. 第一项\n2. 第二项\n3. 第三项\n```\n\n## 列表嵌套\n列表嵌套只需在子列表中的选项添加四个空格即可：\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n\n\n```markdown\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n```\n\n# Markdown 区块\nMarkdown 区块引用是在段落开头使用 `>` 符号 ，然后后面紧跟一个空格符号：\n> 这是一个区块\n```markdown\n> 这是一个区块\n```\n另外区块是可以嵌套的，一个 `>` 符号是最外层，两个 `>` 符号是第一层嵌套，以此类推：\n> 最外层\n> > 第一层嵌套\n> >\n> > > 第二层嵌套\n```markdown\n> 最外层\n> > 第一层嵌套\n> > > 第二层嵌套\n```\n\n## 区块中使用列表\n区块中使用列表实例如下：\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n```markdown\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n```\n\n## 列表中使用区块\n如果要在列表项目内放进区块，那么就需要在 `>` 前添加四个空格的缩进。\n区块中使用列表实例如下：\n* 第一项\n  > 菜鸟教程\n  > 学的不仅是技术更是梦想\n* 第二项\n```markdown\n* 第一项\n    > 菜鸟教程\n    > 学的不仅是技术更是梦想\n* 第二项\n```\n\n# Markdown 代码\n如果是段落上的一个函数或片段的代码可以用反引号把它包起来（\\`），例如：\n`printf()` 函数\n```markdown\n`printf()` 函数\n```\n## 代码区块\n代码区块使用 4 个空格或者一个制表符（Tab 键）。\n也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：\n实例如下：\n```javascript\n$(document).ready(function () {\n    alert('RUNOOB');\n});\n```\n\n# Markdown 链接\n链接使用方法如下：\n> [链接名称](#链接地址)\n> 或者直接使用链接地址\n> <https://github.com/Yue-plus>\n```markdown\n[链接名称](链接地址)\n<https://github.com/Yue-plus>\n```\n\n## 高级链接\n可以通过变量来设置一个链接，变量赋值在文档末尾进行：\n> 这个链接用 `1` 作为网址变量 [Google][1]\n> 这个链接用 `mysite` 作为网址变量 [Yue_plus][mysite]\n```markdown\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 mysite 作为网址变量 [Yue_plus][mysite]\n然后在文档的结尾为变量赋值（网址）\n\n  [1]: http://www.google.com/\n  [mysite]: https://github.com/Yue-plus\n```\n\n# Markdown 图片\nMarkdown 图片语法格式如下：\n```markdown\n![alt 属性文本](图片地址)\n![alt 属性文本](图片地址 \"可选标题\")\n```\n开头一个感叹号 !\n接着一个方括号，里面放上图片的替代文字\n接着一个英文括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 'title' 属性的文字。\n> ![罗德岛集结](https://ak.hypergryph.com/upload/images/20190228/118078295785f64dac736c6ade50bb76.jpg \"罗德岛集结\")\n```markdown\n![罗德岛集结](https://ak.hypergryph.com/upload/images/20190228/118078295785f64dac736c6ade50bb76.jpg \"罗德岛集结\")\n```\n当然，你也可以像网址那样对图片网址使用变量:\n```markdown\n这个链接用 `2` 作为网址变量 [凯尔希][2].\n然后在文档的结尾为变量赋值（网址）\n\n[2]: https://ak.hypergryph.com/upload/images/20190228/143666074a406ecaa6cd4271dc7c5127.jpg\n```\nMarkdown 还没有办法指定图片的高度与宽度，如果需要的话，也可以使用普通的 `<img>` 标签。\n> <img src=\"https://ak.hypergryph.com/assets/index/images/ak/common/story/item_infected.png\" width=\"200px\">\n```html\n<img src=\"https://ak.hypergryph.com/assets/index/images/ak/common/story/item_infected.png\" width=\"200px\">\n```\n\n# Markdown 表格\nMarkdown 制作表格使用 `|` 来分隔不同的单元格，使用 `-` 来分隔表头和其他行。\n语法格式如下：\n\n| 表头   | 表头   |\n| ------ | ------ |\n| 单元格 | 单元格 |\n| 单元格 | 单元格 |\n\n```markdown\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n```\n\n可以设置表格的对齐方式：\n\n`-:` 设置内容和标题栏居右对齐。\n`:-` 设置内容和标题栏居左对齐。\n`:-:` 设置内容和标题栏居中对齐。\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n# Markdown 高级技巧\n##支持的 HTML 元素\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n目前支持的 HTML 元素有：`<kbd>` `<b>` `<i>` `<em>` `<sup>` `<sub>` `<br>`等，如：\n> 使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n```markdown\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n```\n\n## 转义\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\n> \\*\\* 正常显示星号 \\*\\*\n```markdown\n**文本加粗** \n\\*\\* 正常显示星号 \\*\\*\n```\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n```markdown\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n```\n\n## 数学公式\n当需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n\n> 参考 [使用 `hexo-filter-mathjax` 过滤器来显示数学公式](https://github.com/Yue-plus/hexo-theme-arknights#数学公式)\n\n> 可以在行内包含数学公式： $i\\hbar\\frac{\\partial}{\\partial t}\\psi=-\\frac{\\hbar^2}{2m}\\nabla^2\\psi+V\\psi$ 注意单 `$` 内部不能有空格！\n> $$\n> \\begin{eqnarray\\*}\n> \\nabla\\cdot\\vec{E}&=&\\frac{\\rho}{\\epsilon_0}\\\\\\\\\n> \\nabla\\cdot\\vec{B}&=&0\\\\\\\\\n> \\nabla\\times\\vec{E}&=&-\\frac{\\partial B}{\\partial t}\\\\\\\\\n> \\nabla\\times\\vec{B}&=&\\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t}\\right)\\\\\\\\\n> \\end{eqnarray\\*}\n> $$\n\n```markdown\n可以在行内包含数学公式： $i\\hbar\\frac{\\partial}{\\partial t}\\psi=-\\frac{\\hbar^2}{2m}\\nabla^2\\psi+V\\psi$ 注意单 `$` 内部不能有空格！\n$$\n\\begin{eqnarray\\*}\n\\nabla\\cdot\\vec{E}&=&\\frac{\\rho}{\\epsilon_0}\\\\\\\\\n\\nabla\\cdot\\vec{B}&=&0\\\\\\\\\n\\nabla\\times\\vec{E}&=&-\\frac{\\partial B}{\\partial t}\\\\\\\\\n\\nabla\\times\\vec{B}&=&\\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t}\\right)\\\\\\\\\n\\end{eqnarray\\*}\n$$\n```\n\n[^阿米娅]: 博士，您还有很多事情需要处理。现在还不能休息哦。\n\n[1]: http://www.google.com/\n[mysite]: https://github.com/Yue-plus","categories":[],"tags":["Markdown"]}]