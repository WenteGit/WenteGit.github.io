[{"title":"theAlgorithm","url":"/posts/26841/","content":"> 算法总结\n<!--more-->\n\n># 全排列\n## 将字符串中的每个字母转变大小写,返回所有可能得到的字符串集合 \n**算法思路：**    \n如果下一个字符 c 是字母，将当前已遍历过的字符串全排列复制两份。  \n在第一份的每个字符串末尾添加 lowercase(c)，在第二份的每个字符串末尾添加 uppercase(c)。  \n如果下一个字符 c 是数字，将 c 直接添加到每个字符串的末尾。  \n\n**编程语言: Python**\n```Py\ndef letterCasePermutation(self, S):\n        ans = [[]]\n        for char in S:\n            n = len(ans)\n            \n            if char.isalpha():\n                for i in xrange(n):\n                    ans.append(ans[i][:])\n                    ans[i].append(char.lower())\n                    ans[n+i].append(char.upper())\n            else:\n                for i in xrange(n):\n                    ans[i].append(char)\n\n```\n># DFS 深度优先\n># BFS 广度优先\n># 递归与回溯\n>题目描述:  \n>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>>ans;\n    vector<int>temp;\n    vector<vector<int>> combine(int n, int k) {\n        dfs(1, n, k);\n        return ans;\n    }\n    // 1 2 3 4\n    void dfs(int cur,int n,int k) {\n// 如果当前temp的大小为s，未确定状态的区间[cur,n] 的长度为t，如果s + t < ks+t<k\n// 那么即使 tt 个都被选中，也不可能构造出一个长度为k的序列\n        if (temp.size() + (n - cur + 1) < k) {\n            return;\n        }\n        if (temp.size() == k) {\n            ans.push_back(temp);\n            return;\n        }\n\n        temp.push_back(cur);\n        dfs(cur + 1, n, k);\n        temp.pop_back();\n        dfs(cur + 1, n,k);\n    }\n};\n\n```\n\n># 二分查找\n># 双指针\n># 滑动窗口\n># DP动态规划\n## 各个房间内都有一定的现金，相邻的房间不可同时偷，求最好的偷取方案。\n**算法思路：**  \n依次保存偷当前房间的话，算上之前的一共能偷到的总金额  \n**编程语言：C++**\n```cpp\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        if (nums.empty()) {\n            return 0;\n        }\n        else if (nums.size() == 1) {\n            return nums[0];\n        }\n        else if (nums.size() == 2) {\n            return nums[0] > nums[1] ? nums[0] : nums[1];\n        }\n\n        vector<int> dp(nums.size(), 0);\n        dp[0] = nums[0];\n        dp[1] = max(nums[0], nums[1]);\n\n        for (int i = 2; i < nums.size(); i++) {\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\n        }\n        return dp[nums.size() - 1];\n    }\n};\n\n```\n## 给定一个三角形 triangle ，找出自底向上求的最小路径和。\n**算法思路**\n> 从倒数第二排开始，每次将该层的元素的下一层的相邻元素的最小的保存到该层元素，逐层返回到最顶层，则最顶层保存的就是最小路径  \n\n**编程语言：C++**\n```cpp\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int size = triangle.size();\n        for (int i = size -2; i >=0 ; i--) {\n            for (int j = 0; j < triangle[i].size(); j++) {\n                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);\n            }\n        }\n        return triangle[0][0];\n    }\n};\n\n```\n\n># 可用数组装链表，这样就可以让每一个链表都有一个下标了\n```Python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def reorderList(self, head: ListNode) -> None:\n        if not head:\n            return\n\n        vec = list()\n        node = head\n        while node:\n            vec.append(node)\n            node = node.next\n        i, j = 0, len(vec) - 1\n        while i < j:\n            vec[i].next = vec[j]\n            i += 1\n            if i == j:\n                break\n            vec[j].next = vec[i]\n            j -= 1\n\n        vec[i].next = None\n```\n\n\n# Cpp综合积累\n\n> ## 函数方法\n### vector\n> vector也可以当做栈来使用  \n> 如下：pop_back表示出栈，push_back表示入栈  \n> arr.back 表示获取栈顶元素  \n> arr.front 表示获取栈底元素或者叫做队列头元素\n```Cpp\n    vector<int>arr = { 1,2,3 };\n    arr.pop_back();\n    cout<<arr.back();\n    cout << arr.front();\n```\n## 关键字\n### new关键字\n> new关键字可用作new一个新的对象出来，并返回一个指针类型的变量指向该对象，可以new类，也可以new结构体","categories":["Algorithm"],"tags":["Algorithm"]},{"title":"Redis","url":"/posts/27273/","content":"> 介绍了关于Redis的相关内容\n<!--more-->\n# 缓存注解\n```java\n@CacheConfig\n是一个类级别的注解，允许共享缓存的名称。\n一个类可能会有多个缓存操作而这些缓存操作可能是重复的，这时候可以使用@CacheConfig.\n```\n>- - -\n```java\n@Cacheable\n* 代表从缓存中查询指定的key，如果有，从缓存中取，不再执行方法。\n* 如果没有则执行方法，并且将方法的返回值和指定的key关联起来，放入到缓存中。\n\n主要参数：\n* value : 缓存的名称，在spring配置中定义，必须指定至少一个。\n* key: 缓存的key，可以为空，如果指定要按照spel表达式编写，如果不指定，则缺省按照方法的所有参数进行组合。\n* condition: 缓存的条件，可以为空，使用spek编写，返回true或false,只有为true使才进行缓存。\n\nExample:\n@Cacheable(value=\"thisredis\", key=\"'users_'+#id\")\npublic User findUser(Integer id) {}\n```\n>- - -\n>如果在类上配置了@CacheConfig,那么此时@Cacheable中的value就会取代@CacheConfig中cacheNames。  \n>如果在类上配置了@CacheConfig(cacheNames = \" \"),在该类下的@Cacheable中可以不用配置value。\n>- - -\n```java\n@CacheEvict\n标记在方法上，方法执行完毕之后根据条件或key删除对应的缓存。\n\nExample:\n@CacheEvict(value=\"thisredis\",   key=\"'users_'+#id\",condition=\"#id!=1\")\npublic void delUser(Integer id) {}\n\n主要参数：\nallEntries : 布尔类型 表示是否需要清除缓存中的所有元素。\nkey: 需要删除的缓存的key\n\n当我们在更新数据库的数据时，要使用@CacheEvict，需要把redis的缓存清空，否则查询的数据就是redis缓存中的数据，这样就会导致数据库和缓存数据不一致的问题。（页面不能及时的同步更新后的数据）。\n\n加上@CacehEvict 就会在查询数据时发现数据时最新的，与数据库保持一致。\n```","categories":[],"tags":["Redis"]},{"title":"IDEA_Hotkeys","url":"/posts/10026/","content":">日常学习的一个随笔\n<!--more-->\n# 获取request对象\n```java\n ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n```","categories":[],"tags":["随笔"]},{"title":"VersionController","url":"/posts/8310/","content":">总结了关于Spring全家桶以及Maven依赖的版本后缀意义，以及依赖关系\n>为了预防版本冲突或者版本不一致所导致的BUG\n<!--more-->\n\n# Maven版本后缀\n>* SNAPSHOT(快照版本Snapshot)\n>* RELEASE(发布版本release)\n>* Alpha：内测版，BUG 多，开发人员开发过程中使用，希腊字母α，第一，指最初版 \n>* Beta：早期版本，有缺陷，无大 BUG，可能加入新功能，进一步开发完善。\n>* Gamma: 经 beta 版，完善修改，成为正式发布的候选版本（Release Candidate）\n>* RC：(Release Candidate)：候选版本，几乎就是正式版了，一般需要 ASF 投票通过后，才会形成正式版本。\n>* GA：（Ggeneral Availability）：发行稳定版，官方推荐使用此版本。\n>* R，RELEASE：正式版，等价于 GA。\n>- - -\n>**其他版本**\n>Alpha：内部测试版  \nBeta：外部测试版  \nBuild：修正版  \nCorporation 或 Enterprise：企业版  \nDelux：豪华版  \nDEMO：演示版，有功能限制  \nFree：免费版  \nFull：完全版  \nFinal：正式版  \nPro(professional)：专业版  \nPlus：加强版  \nRetail：零售版  \nRelease：发行版，有时间限制  \nShareware：共享版，虽然不会要求注册但是一般也有功能限制  \nSR：修正版  \nTrial：试用版（一般有时间或者功能限制）  \n\n# SpringCloudAlibaba 与 SpringCloud 与 Springboot 的对应关系\n>![alt](http://xtzl.wentexl.cn/%E4%B8%BB%E7%89%88%E6%9C%AC.png)\n\n# SpringCloud的组件\n>![alt](http://xtzl.wentexl.cn/Cloud%E7%BB%84%E4%BB%B6.png)","categories":["version"],"tags":["version"]},{"title":"Swagger2","url":"/posts/35285/","content":"\n> 描述了关于Swagger的简介和简单使用\n<!--more-->\n# 地址：\n>http://服务器ip:端口/swagger-ui.html\n# 什么是swagger2\n>编写和维护接口文档是每个程序员的职责，根据Swagger2可以快速帮助我们编写最新的API接口文档，再也不用担心开会前仍忙于整理各种资料了，间接提升了团队开发的沟通效率。\n# 常用注解\n>* @Api：修饰整个类，描述Controller的作用\n>* @ApiOperation：描述一个类的一个方法，或者说一个接口\n>* @ApiParam：单个参数描述\n>* @ApiModel：用对象来接收参数\n>* @ApiModelProperty：用对象接收参数时，描述对象的一个字段\n>* @ApiImplicitParam：一个请求参数\n>* @ApiImplicitParams：多个请求参数\n# 依赖\n```xml\n  <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui -->\n <dependency>\n      <groupId>io.springfox</groupId>\n      <artifactId>springfox-swagger-ui</artifactId>\n      <version>2.9.2</version>\n  </dependency>\n  <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 -->\n  <dependency>\n      <groupId>io.springfox</groupId>\n      <artifactId>springfox-swagger2</artifactId>\n      <version>2.9.2</version>\n      <scope>compile</scope>\n  </dependency>\n\n```","categories":["Utils"],"tags":["Swagger2"]},{"title":"JSTL 表达式","url":"/posts/9859/","content":"<!--more-->\n# JSTL\n##\t1. 概念：JavaServer Pages Tag Library  JSP标准标签库\n\t\t* 是由Apache组织提供的开源的免费的jsp标签\t\t<标签>\n\n##\t2. 作用：用于简化和替换jsp页面上的java代码\n\n##\t3. 使用步骤：\n\t\t1. 导入jstl相关jar包\n\t\t2. 引入标签库：taglib指令：  <%@ taglib %>\n\t\t3. 使用标签\n\n##\t4. 常用的JSTL标签\n\t\t1. if:相当于java代码的if语句\n\t\t\t1. 属性：\n\t            * test 必须属性，接受boolean表达式\n\t                * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容\n\t                * 一般情况下，test属性值会结合el表达式一起使用\n       \t\t 2. 注意：\n\t       \t\t * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签\n\t\t2. choose:相当于java代码的switch语句\n\t\t\t1. 使用choose标签声明         \t\t\t相当于switch声明\n            2. 使用when标签做判断         \t\t\t相当于case\n            3. 使用otherwise标签做其他情况的声明    \t相当于default\n\n\t\t3. foreach:相当于java代码的for语句\n\n##\t5. 练习：\n\t\t* 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中\n\n\n\n\n\n# 三层架构：软件设计架构\n##\t1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互\n##\t2. 业务逻辑层：处理业务逻辑的。\n##\t3. 数据访问层：操作数据存储文件。","categories":["java"],"tags":["JSYL表达式"]},{"title":"EL 表达式","url":"/posts/5361/","content":">总结了关于EL表达式的相关知识\n<!--more-->\n>EL 表达式\n\n#\t1. 概念：Expression Language 表达式语言\n#\t2. 作用：替换和简化jsp页面中java代码的编写\n#\t3. 语法：${表达式}\n#\t4. 注意:\n>\tjsp默认支持el表达式的。如果要忽略el表达式\n##\t1. 设置jsp中page指令中：isELIgnored=\"true\" 忽略当前jsp页面中所有的el表达式\n##\t2. \\${表达式} ：忽略当前这个el表达式\n\n\n#\t5. 使用：\n##\t\t1. 运算：\n\t\t\t* 运算符：\n\t\t\t\t1. 算数运算符： + - * /(div) %(mod)\n\t\t\t\t2. 比较运算符： > < >= <= == !=\n\t\t\t\t3. 逻辑运算符： &&(and) ||(or) !(not)\n\t\t\t\t4. 空运算符： empty\n\t\t\t\t\t* 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0\n\t\t\t\t\t* ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0\n\t\t\t\t\t* ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度>0\n##\t\t2. 获取值\n\t\t\t1. el表达式只能从域对象中获取值\n\t\t\t2. 语法：\n###\t\t\t1. ${域名称.键名}：从指定域中获取指定键的值\n\t\t\t\t\t* 域名称：\n\t\t\t\t\t\t1. pageScope\t\t--> pageContext\n\t\t\t\t\t\t2. requestScope \t--> request\n\t\t\t\t\t\t3. sessionScope \t--> session\n\t\t\t\t\t\t4. applicationScope --> application（ServletContext）\n\t\t\t\t\t* 举例：在request域中存储了name=张三\n\t\t\t\t\t* 获取：${requestScope.name}\n\n###\t\t\t\t2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。\n\n\n\n##\t\t\t\t3. 获取对象、List集合、Map集合的值\n\t\t\t\t\t1. 对象：${域名称.键名.属性名}\n\t\t\t\t\t\t* 本质上会去调用对象的getter方法\n\n\t\t\t\t\t2. List集合：${域名称.键名[索引]}\n\n\t\t\t\t\t3. Map集合：\n\t\t\t\t\t\t* ${域名称.键名.key名称}\n\t\t\t\t\t\t* ${域名称.键名[\"key名称\"]}\n\n\n##\t\t3. 隐式对象：\n\t\t\t* el表达式中有11个隐式对象\n\t\t\t* pageContext：\n\t\t\t\t* 获取jsp其他八个内置对象\n\t\t\t\t\t* ${pageContext.request.contextPath}：动态获取虚拟目录","categories":["java"],"tags":["EL表达式"]},{"title":"SpringSecurity-Web 权限","url":"/posts/21484/","content":"> 总结了关于SpringSecurity的Web权限控制方面的知识点\n<!--more-->\n# 设置登录的用户名和密码\n## 通过配置文件\n```yml\nspring:\n  security:\n    user:\n      name: Wente\n      password: wente695\n```\n\n## 自定义编写实现类\n> 从数据库中获取账户和密码，验证的时候是通过用户名获取到数据库的数据\n```java\n@Configuration\npublic class SecuriryConfig extends WebSecurityConfigurerAdapter {\n    @Resource\n    private UserDetailsService userDetailsService;\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailsService).passwordEncoder(password());\n    }\n    @Bean\n    PasswordEncoder password(){return new BCryptPasswordEncoder();}\n}\n```\n**Service端**\n```java\n  @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        List<GrantedAuthority> auths = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\");\n        return new User(\"mary\",new BCryptPasswordEncoder().encode(\"123\"),auths);\n    }\n```\n# 基于角色或者权限进行访问控制\n## hasAuthority 方法\n> 在配置类设置当前访问地址有哪些权限\n> 配置类中设置权限\n```java\n   .antMatchers(\"/test/index\").hasAnyAuthority(\"admins\")// 当前登录用户只有具有admins权限的才能访问这个路径\n```\n> 服务端配置权限\n```java\n  List<GrantedAuthority> auths = AuthorityUtils.commaSeparatedStringToAuthorityList(\"admins\");\n```\n## hasAnyAuthority方法\n```java\n   .antMatchers(\"/test/index\").hasAnyAuthority(\"admins,mannager\")// 当前登录用户只有具有admins,或者mannager的都可以\n```\n## hasRole方法\n> 但是在服务类里面添加角色权限的时候，必须要加一个ROLE_前缀\n>hasanyRole方法在配置类中多个角色用逗号隔开\n```java\n .antMatchers(\"/test/index\").hasRole(\"sale\") // 设置什么角色可以访问\n```\n>- - -\n```java\n  List<GrantedAuthority> auths = AuthorityUtils.commaSeparatedStringToAuthorityList(\"admins,ROLE_sale\");\n```\n>- - -\n\n# 基于注解配置SpringSecurity\n## 设置权限\n> 开启注解配置Security方式\n```java\n// prePostEnabled是表示支持事后验证的方式\n@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)\n```\n>接口类\n```java\n//@Secured({\"ROLE_sale\",\"ROLE_mannager\"})\n@PreAuthorize(\"hasAnyAuthority('admins')\")\n//@PostAuthorize(\"hasAnyAuthority('admins')\") // 在方法执行之后再做权限验证\n    public String update(){\n        return \"hello updata\";\n    }\n```\n## 过滤注解\n```java\n@PostFilter // 方法对返回数据进行过滤\n@PreFillter // 对传入方法的数据进行过滤\n```\n> 参数使用\n```java\n// 表示只返回的数据对象中的username是admin的对象\n@PostFilter(\"filterObject.username == 'admin'\")\n// 表示只传入的数据对象中的username属性是admin的对象\n@PreFilter(\"filterObject.username == 'admin'\")\n```\n# 用户注销\n> href的/logout是自带的，不需要自己去编写\n> 登出后再去访问需要登录的方法的请求就会被拦截，自动跳到登陆页面去\n ```xml\n  <a href=\"/logout\">退出</a>\n ```\n\n# 一定时间内自动登录\n","categories":["SpringSecurity"],"tags":[]},{"title":"boot_Security.md","url":"/posts/29525/","content":"> 主要是针对于SpringSecurity进行总结,主要采用的是SpringBoot + SpringSecurity\n<!--more-->\n# 核心要点\n>* 引入依赖之后访问方法都要先登录，登录用户名默认是user，密码在控制台\n\n# 依赖引入\n```xml\n   <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n```\n# 两个重要接口：\n##  UserDetailsServic 接口: 查询数据库用户名和密码的过程\n* 创建类继承UsernamePasswordAuthenticationFilter\n* 创建类实现UserDetailsService,编写查询数据过程，返回User对象，这个User对象是安全框架提供对象。\n\n## PasswordEncoder 接口：数据加密接口，用于返回User对象里面密码加密\n\n# 配置类\n\n\n","categories":["SpringSecurity"],"tags":["SpringSecurity"]},{"title":"Transaction","url":"/posts/43132/","content":"> 该文主要介绍了关于SpringBoot的事务管理的相关知识点\n<!--more-->\n# 核心\n>* Spring并不直接管理事务，而是通过各种事务管理器来调用特定平台的事务实现\n>* spring统一管理事务，把不同的数据库访问技术的事务处理统一起来\n>* 已经commit的事务是不能rollback的\n\n\n# 常用的事务管理器\n>* DataSourceTransactionManager：用于JDBC的持久化支持，也可用于IBATIS\n>* HibernateTransactionManager：用于Hibernate3的持久化支持\n>* JpaTransactionManager：用于Java持久化API的持久化支持\n>* JtaTransactionManager：主要用于分布式事务的支持\n\n# 事务的传播行为ProPagation\n>**事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式**  \n>优秀博文:http://t.csdn.cn/TgggY  \n> **重点：**\n>* PROPAGATION_REQUIRED : 表示当前方法必须运行在事务中，若当前存在事务，则在原有事务中运行，否则创建一个新的事务。\n>- - -\n>* PROPAGATION_REQUIRES_NEW :  新建事务，如果当前存在事务，把当前事务挂起。\n>- - -\n>* PROPAGATION_SUPPORTS : 如果当前有事务，则使用事务，如果当前没有事务，就以非事务方式执行\n>- - -\n>* Propagation.NOT_SUPPORTED :  以非事务方式执行操作，如果当前存在事务，就把当前事务挂起\n>- - -\n>- - -\n> **次要:**\n>* PROPAGATION_MANDATORY ：表示该方法必须在事务中运行，若当前事务不存在则抛异常。举例来说，一个service方法调用了两个dao方法，那么在执行其中的一个dao方法时，都要求已经启动了事务，否则需要抛异常。\n>- - -\n>* PROPAGATION_NESTED :表示若当前已存在一个事务，那么该方法将在嵌套事务中运行。嵌套事务可以独立于当前事务进行提交或回滚，若当前事务不存在，则该传播行为与PROPAGATION_REQUIRED一样。举例来说，一个service方法中调用了某dao方法，并且根据该dao方法执行的成功或失败区分了两套处理逻辑，这时候若dao执行失败，它只要保证不对数据库数据有任何影响（通过rollback）就可以了，不需要回滚整个service方法，故这个dao方法需要在嵌套事务中运行。\n>- - -\n>* PROPAGATION_NEVER : 表示当前方法不应该运行在事务中，若当前已经有一个事务在运行，则抛异常。这种适用于在某些dao操作中，它要求之前的事务已经结束，而它本身的操作结果不会受到其他dao操作结果的影响（比如被其他操作所rollback）。\n>- - -\n>* PROPAGATION_NOT_SUPPORTED : 表示当前方法不应该运行在事务中，若当前已经有一个事务在运行，则将其挂起。\n\n# 事务并发可能导致的错误\n>* 脏读：某事务读取了其他事务未提交的数据后，其他事务又将其数据回滚，导致该事务使用了无效的数据。\n>- - -\n>* 不可重复读：某事务执行两次相同的查询操作，但是由于在这两次操作中间存在其他事务更新了数据，从而导致两次查询的结果不一致。\n>- - -\n>* 幻读 ：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 删除或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候真实的数据集已经发生了变化，但是A却查询不出来这种变化，因此产生了幻读。\n>- - -\n\n# Spring提供的事务隔离isolation \n>若通过相关互斥机制保证事务的绝对隔离，则会很大程度影响并发的性能，最差情况就相当于事务是串行地执行。为了尽可能避免这些问题、权衡性能以及提高事务隔离的灵活性，Spring定义了五种隔离级别，以允许应用程序自己决定所能接受的、被其他事务所影响的程度。\n>- - -\n>* ISOLATION_DEFAULT : 使用底层数据库默认的隔离级别。\n>- - -\n>* ISOLATION_READ_UNCOMMITTED : 允许读取未提交的数据，这可能导致脏读、不可重复读和幻读。\n>- - -\n>* ISOLATION_READ_COMMITTED ：允许读取已提交的数据，这可以避免脏读，但是还是可能导致不可重复读和幻读。\n>- - -\n>* ISOLATION_REPEATABLE_READ : 对同一字段的多次读取结果是一致的，除非由本事务自己更新，这可以避免不可重复读和脏读，但是还是可能导致幻读。\n>- - -\n>* ISOLATION_SERIALIZABLE：完全按照ACID所要求的，可以避免脏读、不可重复读和幻读。注意：这种事务隔离级别的效率最差，因为它经常需要将事务相关的表进行加锁，锁粒度大。\n>- - -\n>![事务](http://xtzl.wentexl.cn/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E8%A7%84%E5%88%99.png)\n\n\n","categories":["SpringBoot"],"tags":["Transaction"]},{"title":"SpringAop","url":"/posts/21566/","content":">介绍了关于SpringBoot的相关知识点\n<!--more-->\n\n","categories":["SpringBoot"],"tags":["SpringAop"]},{"title":"Seata","url":"/posts/63021/","content":"> 介绍了分布式中关于Seata的知识\n<!--more-->\n# Seata重点\n>* 必须先启动Nacos后启动Seata\n\n\n# Seata介绍\n>* 1 + 3 的组件模型\n>* 分布式事务处理过程的-ID+三组件模型\n>* Transaction ID XID : 全局唯一的事务ID\n\n# Seata术语(三组件)\n## TC (Transaction Coordinator) - 事务协调者\n>维护全局和分支事务的状态，驱动全局事务提交或回滚。\n\n## TM (Transaction Manager) - 事务管理器\n>定义全局事务的范围：开始全局事务、提交或回滚全局事务。\n\n## RM (Resource Manager) - 资源管理器\n>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回\n滚。\n\n![seata](http://xtzl.wentexl.cn/Seata.png)\n>- - -\n\n# BASE理论 \n>BASE理论是对CAP的一种解决思路，包含三个思想：\n>- - -\n>* Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。\n>* Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。\n>* Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。\n>- - -\n>而分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论：\n>- - -\n>* AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。  \n>* CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态\n\n# 分布式事务解决方案\n>Seata提供了四种不同的分布式事务解决方案：\n>- - -\n>* XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入\n>* TCC模式：最终一致的分阶段事务模式，有业务侵入\n>* AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式\n>* SAGA模式：长事务模式，有业务侵入  \n\n**对比**\n![compare](http://xtzl.wentexl.cn/%E5%AF%B9%E6%AF%94.png)","categories":["distributed"],"tags":["Seata"]},{"title":"Cloud-Alibaba-Nacos","url":"/posts/33695/","content":">总结了关于SpringCloud-Alibaba-Nacos的相关知识\n<!--more-->\n# Nacos\n>* Nacos 就是注册中心 + 配置中心的组合\n>* 等价于 Nacos = Eureka + Config + Bus\n>* AP架构和CP架构都支持，可切换（C: 一致性 A：可用性  P:分区容错性）\n>* startup.cmd -m standalone  单机启动命令\n\n# 依赖引入\n> 父工程pom：\n```xml\n     <!--spring cloud alibaba 2.1.0.RELEASE-->\n            <dependency>\n                <groupId>com.alibaba.cloud</groupId>\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n                <version>2.1.0.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n\n```\n> 子工程pom：\n```xml\n        <!--SpringCloud ailibaba nacos -->\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n```\n\n# Nacos注册中心\n## 服务端Yml配置\n```yml\nserver:\n  port: 9002\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #配置Nacos地址\n        # 换成nginx的1111端口，做集群\n        #server-addr: 192.168.111.144:1111\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n\n```\n## 客户端Yml配置\n```yml\nserver:\n  port: 83\n\n\nspring:\n  application:\n    name: nacos-order-consumer\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n\n\nservice-url:\n  nacos-user-service: http://nacos-payment-provider\n```\n\n## 客户端Controller层\n> 由于在配置yml的时候，已经在service-url.nacos-user-service中配置过了，所以直接可用@Value注解进行引入\n```java\n  @Value(\"${service-url.nacos-user-service}\")\n    private String serverURL;\n```\n# Nacos 配置中心\n## 核心\n>* Nacos的Config配置自带动态刷新\n>* DataId必须按官方给定的格式命名\n## 新增依赖\n```xml\n     <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n        </dependency>\n\n```\n## yml配置\n>**bootstrap的优先级是高于application的**\n\n> bootstrap.yml\n```yml\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacos-config-client\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #服务注册中心地址\n      config:\n        server-addr: localhost:8848 #配置中心地址\n        file-extension: yaml #指定yaml格式的配置\n```\n>application.yml\n```yml\nspring:\n  profiles:\n    active: dev\n```\n## 在Nacos端的配置文件名格式如下(设置DataId):\n>${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}  \n> 例如: nacos-config-client-dev.yaml\n\n## 分组管理\n![分组](http://xtzl.wentexl.cn/%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86.png)\n>* yml中设置分组,意为选择DEV环境下的配置生效\n```yml\nconfig:\n    group: DEV_GROUP\n```\n>* 不同的组别可以存在DataId相同的配置\n## 命名空间NameSpace\n>* yml文件配置命名空间\n```yml\nconfig:\n    namespace: f2009b56-a85a-487a-afeb-0927aa03a199\n```\n# 切换Nacos的数据库\n>*  Nacos自带一个derby数据库，但是要统一使用mysql数据库\n>*  sql执行脚本在nacos的安装路径中conf目录下\n>* sql执行之后，需要修改conf下application.properties,(mysql8)修改如下\n```txt\nspring.datasource.platform=mysql\ndb.num=1\ndb.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC\ndb.user.0=root\ndb.password.0=root\n```\n","categories":["Alibaba-Nacos"],"tags":["Nacos"]},{"title":"Cloud-Alibaba-Sentinel","url":"/posts/60668/","content":"> 总结了Sentinel的有关知识\n<!--more-->\n# 重点\n>* 实例重启后如果进入sentinel的web界面，则必须先调用一个任意的方法才能被检测到\n>* fallback管的是运行异常，blockHandler管的是配置违规\n>* 当fallback和blockHandler同时起效的时，优先起效的是blockHandler方法\n>* 自带负载均衡\n\n\n# 依赖引入\n```xml\n    <!--SpringCloud ailibaba nacos -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n    </dependency>\n    <!--SpringCloud ailibaba sentinel-datasource-nacos 后续sentinel做持久化用到-->\n    <dependency>\n        <groupId>com.alibaba.csp</groupId>\n        <artifactId>sentinel-datasource-nacos</artifactId>\n    </dependency>\n    <!--SpringCloud ailibaba sentinel -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\n    </dependency>\n```\n# 服务端 yml 配置\n```yml\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibaba-sentinel-service\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n    sentinel:\n      transport:\n        # 8080会监控8401查看是否健康\n        dashboard: localhost:8080 #配置Sentinel dashboard地址\n        # 默认是8719端口号,如果被占用了会自动+1\n        # 指定应用与Sentinel控制台交互的端口，应用本地会起一个该端口占用的HttpServer\n        port: 8719\n\n\n      datasource:\n        ds1:\n          nacos:\n            server-addr: localhost:8848\n            dataId: ${spring.application.name}\n            groupId: DEFAULT_GROUP\n            data-type: json\n            rule-type: flow\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n\n```\n# 流控规则\n>* QPS: 每秒的请求数，一般指每秒查询率\n>* 单机阈值: 请求数的多少\n## PostMan测试\n![postman](http://xtzl.wentexl.cn/PostMan.png)\n\n## 流控效果\n### 预热\n>* ColdFactor冷加载因子默认是3\n>* 请求QPS从 threshold/3 开始，经预热时长之后，QPS才会逐渐达到指定QPS值\n>* 预热主要是为了保护系统\n### 快速失败\n>* 只要不满足流控规则，直接让该请求失败\n### 排队等等\n>* 只要每个请求的等待时间不超过设定的超时时间，则每个请求都排队等待响应\n>* 而处理的速度，根据流控规则的单机阈值来决定\n>* 其中超时时间的单位是ms\n>* 如果请求超时，则报错\n\n## 流控模式\n### 关联\n![connect](http://xtzl.wentexl.cn/%E5%85%B3%E8%81%94.png)\n### 直接\n>* 仅仅针对于一个方法而言\n\n# 降级与熔断策略\n>* 官网讲解\n![熔断](http://xtzl.wentexl.cn/%E5%AE%98%E7%BD%91%E7%86%94%E6%96%AD.png)\n\n## RT:慢调用比例\n>* 注意：Sentinel默认RT最大时间为4900毫秒，可通过-Dcsp.sentinel.statistic.max.rt=xxx修改  \n>* 慢调用比例 = 慢调用请求数/请求总数\n>* 在单位统计时长内，如果慢调用比例大于阈值，且请求数大于最小请求数值，则触发熔断\n>* 经过一个熔断时长后，进入探测恢复状态（HALF-OPEN）阶段，即接下来的一个请求响应时间小于rt(200ms),则熔断结束，否则会再次被熔断。\n>* 慢调用不是异常，如果异常的话是不会进行服务降级而是直接报错\n![慢比例](http://xtzl.wentexl.cn/%E6%85%A2%E6%AF%94%E4%BE%8B1.png)\n\n>- - -\n\n## 异常比例\n>* 当单位统计时长内，请求数目大于设置的最小请求数目（5），并且异常的比例大于阈值（0.07），则接下来的熔断时长（3s，时间窗口的值）内请求会自动被熔断。  \n>* 经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]。\n>![异常](http://xtzl.wentexl.cn/%E5%BC%82%E5%B8%B8%E6%AF%94%E4%BE%8B1.8.4.png)\n\n>- - -\n\n## 异常数\n>* 异常数一般都是按分钟统计的\n>* 单位统计时长内，异常数达到设定的异常数则进入服务熔断，调用服务降级的函数\n>* 服务熔断之后，经过一个熔断时长之后，才会进入探测恢复状态\n>![异常数](http://xtzl.wentexl.cn/%E5%BC%82%E5%B8%B8%E6%95%B01.8.4.png)\n\n\n# 热点监控\n>* 在web界面自定义热点规则，当请求违背了热点规则之后，则执行blocakHandler所指的的方法\n>* @SentinelResource 的value属性只要保持唯一性就好，一般与GetMapping的value保持一致\n>* 运行异常不属于热点监控的范围，热点监控只管是否违背热点规则，运行异常也就不会走blockHandler这个方法\n## Controller层\n```java\n    @GetMapping(\"/testHotKey\")\n    @SentinelResource(value = \"testHotKey\", blockHandler = \"deal_testHotKey\")\n    public String testHotKey(@RequestParam(value = \"p1\", required = false) String p1,\n                             @RequestParam(value = \"p2\", required = false) String p2) {\n        int age = 10 / 0;\n        return \"------testHotKey\";\n    }\n    // 兜底的方法\n    public String deal_testHotKey(String p1, String p2, BlockException exception) {\n        //sentinel系统默认的提示：Blocked by Sentinel (flow limiting)\n        return \"------deal_testHotKey,o(╥﹏╥)o\";\n    }\n```\n## Web界面配置\n> * 该图表示监控携带第0个参数的请求，窗口时长内的请求数不能超过1次，资源名为@SentinelResource的Value值\n>* 参数例外项：当指定参数为一特定值的时候，阈值有所不同\n![热点规则](http://xtzl.wentexl.cn/%E5%8F%82%E6%95%B0%E4%BE%8B%E5%A4%96.png)\n\n\n\n# Sentinel 自定义限流处理逻辑\n>* 违反我们自己配置的流控规则才需要blockHandler\n>* 在配置流控规则的时候，资源标识最好只使用@SentinelResource注解的Value属性作为唯一标识\n## @SentinelResource\n>- - -\n>* (value = \"byResource\",blockHandler = \"handleException\")\n>* value是唯一标识，blockHandler是指定处理方法(兜底方法)的方法名\n>- - -\n>* (value = \"customerBlockHandler\",   \nblockHandlerClass = CustomerBlockHandler.class, blockHandler = \"handlerException2\")\n>* blockHandlerClass指定处理类，blockHandler指定类中的哪个方法\n>* 注意在写Handler类的方法的时候，所有方法都必须是static的，且handler类无须加入容器\n>- - -\n >* 其中属性exceptionsToIgnore = {IllegalArgumentException.class}，表示忽略IllegalArgumentException这个异常属性，但是这个忽略异常属性，仅仅指的是在Java层面，也就是fallback方法不响应该异常，但是Sentinel仍然会检测到该异常\n\n # Sentinele同样支持Open-feign\n >修改yml支持Open-feign\n ```yml\n # 激活Sentinel对Feign的支持\nfeign:\n  sentinel:\n    enabled: true\n ```\n >- - -\n ```java\n@FeignClient(value = \"nacos-payment-provider\", fallback = PaymentFallbackService.class)\n ```\n > 其中，service层分为接口+实现类，上面的注解标注在接口，fallback指向实现类\n\n# Sentinel持久化\n## 依赖引入\n```xml\n        <dependency>\n            <groupId>com.alibaba.csp</groupId>\n            <artifactId>sentinel-datasource-nacos</artifactId>\n        </dependency>\n```\n## YML配置\n> 将Sentinel配置进Nacos中\n```yml\nspring:\n  cloud:\n     sentinel: \n        datasource:\n          ds1:\n            nacos:\n              server-addr: localhost:8848\n              dataId: ${spring.application.name}\n              groupId: DEFAULT_GROUP\n              data-type: json\n              rule-type: flow\n```\n\n> 需要手动写进Nacos\n>* 在Nacos中需要新建一个配置文件s\n>* 配置文件名DataId就是Sentinel的实例服务名\n>* 配置文件的内容是Json格式\n```json\n[\n    {\n        \"resource\": \"/rateLimit/byUrl\",\n        \"limitApp\": \"default\",\n        \"grade\": 1,\n        \"count\": 1,\n        \"strategy\": 0,\n        \"controlBehavior\": 0,\n        \"clusterMode\": false\n    }\n]\n```\n**解释如下:**\n![json](http://xtzl.wentexl.cn/json.png)","categories":["Service_degradation"],"tags":["Sentinel"]},{"title":"MQ","url":"/posts/44276/","content":"> 总结了关于消息中间件MQ 的知识点\n<!--more-->\n# 核心:四大天王\n>* RabbitMQ\n>* RocketMQ\n>* ActiveMQ\n>* Kafka\n\n# 引入依赖\n```xml\n        <!--添加消息总线RabbitMQ支持来实现广播-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n        </dependency>\n```\n# client和Config端都需要添加yml的MQ的相关支持\n```yml\n#rabbitmq相关配置\nrabbitmq:\n  host: localhost\n  port: 5672\n  username: guest\n  password: guest\n\n```\n# 只需要发送一次，则client端处处生效\n> **中心Config端 多增加如下MQ配置，include改为:bus-refresh**\n```yml\n##rabbitmq相关配置,暴露bus刷新配置的端点\nmanagement:\n  endpoints: #暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: 'bus-refresh'\n\n```\n\n# 运维发送全体通知和精确通知\n> * 全体通知：  \n> localhost:3344/actuator/bus-refresh  \n> 其中，3344指的是中心Config端的端口号\n>- - -\n>* 精确通知：  \n>localhost:3344/actuator/bus-refresh/config-client:3366  \n>其中，config-client指的是config的服务名称，3366是实例的端口号\n> - - -\n\n> 以上是利用RabbitMQ来实现动态刷新Config的优化\n>- - -\n# SpringCloud Stream\n> **重点**  \n>* 凡是涉及到监控、刷新的，必须要引入actuator这个依赖\n>* 消费端不同的组可以存在重复消费\n>* 消费端同一个组不能存在重复消费\n>* 不做处理的默认每个接收的实例都是一个组\n>* 消费端group属性十分重要，因为这个属性既可以解决重复消费，又可以解决消息持久化\n>- - -\n> **核心设计思想**  \n>*  SpringCloud Stream是一个构建消息驱动微服务的框架，应用程序通过inputs或者 outputs来与SpringCloud Stream中的binder进行交互，我们可以通过配置来binding ，而 SpringCloud Stream 的binder负责与中间件交互\n>*  SpringCloud Stream由一个中间件中立的核组成，应用通过SpringCloud Stream插入的input(相当于消费者consumer，它是从队列中接收消息的)和output(相当于生产者producer，它是发送消息到队列中的)通道与外界交流\n>*  Binder是SpringCloud Stream的一个抽象概念，是应用与消息中间件之间的粘合剂，目前SpringCloud Stream实现了Kafka和RabbitMQ的binder通过binder，可以很方便的连接中间件，可以动态的改变消息的destinations（对应于 Kafka的topic，RabbitMQ的exchanges），这些都可以通过外部配置项来做到，甚至可以任意的改变中间件的类型但是不需要修改一行代码\n\n## 架构图1\n![alt](http://xtzl.wentexl.cn/%E7%BC%96%E7%A0%81API.png)\n## 架构图2\n![alt](http://xtzl.wentexl.cn/SCS%E6%9E%B6%E6%9E%84%E5%9B%BE2.png)\n\n## Stream的yml文件配置\n> **消息生产者(生产端)：**\n```yml\nserver:\n  port: 8801\n\nspring:\n  application:\n    name: cloud-stream-provider\n  cloud:\n    stream:\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\n        defaultRabbit: # 表示定义的名称，用于于binding整合\n          type: rabbit # 消息组件类型\n          environment: # 设置rabbitmq的相关的环境配置\n            spring:\n              rabbitmq:\n                host: localhost\n                port: 5672\n                username: guest\n                password: guest\n      bindings: # 服务的整合处理\n        output: # 这个名字是一个通道的名称\n          destination: studyExchange # 表示要使用的Exchange名称定义\n          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”\n          default-binder: defaultRabbit  # 设置要绑定的消息服务的具体设置\n\neureka:\n  client: # 客户端进行Eureka注册的配置\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: send-8802.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为IP地址\n\n```\n>- - -\n> **消息接收者(消费端)**\n```yml\nserver:\n  port: 8803\n\nspring:\n  application:\n    name: cloud-stream-consumer\n  cloud:\n    stream:\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\n        defaultRabbit: # 表示定义的名称，用于于binding整合\n          type: rabbit # 消息组件类型\n          environment: # 设置rabbitmq的相关的环境配置\n            spring:\n              rabbitmq:\n                host: localhost\n                port: 5672\n                username: guest\n                password: guest\n      bindings: # 服务的整合处理\n        input: # 这个名字是一个通道的名称\n          destination: studyExchange # 表示要使用的Exchange名称定义\n          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”\n          default-binder: defaultRabbit # 设置要绑定的消息服务的具体设置\n          group: atguiguA\n\neureka:\n  client: # 客户端进行Eureka注册的配置\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: receive-8803.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为IP地址\n\n```\n\n## 业务层配置\n> **消息生产者(生产端)：**  \n> 仅仅是发送消息到消息队列而已\n> 其中关键注解是： @EnableBinding(Source.class)\n```java\n@RestController\npublic class SendMessageController\n{\n    @Resource\n    private IMessageProvider messageProvider;\n\n    @GetMapping(value = \"/sendMessage\")\n    public String sendMessage()\n    {\n        return messageProvider.send();\n    }\n\n}\n------------------------下面是Service层-------------------------------\n@EnableBinding(Source.class) //定义消息的推送管道\npublic class MessageProviderImpl implements IMessageProvider\n{\n    @Resource\n    private MessageChannel output; // 消息发送管道\n\n    @Override\n    public String send()\n    {\n        String serial = UUID.randomUUID().toString();\n        output.send(MessageBuilder.withPayload(serial).build());\n        System.out.println(\"*****serial: \"+serial);\n        return null;\n    }\n}\n```\n\n> **消息接收者(消费端)：**  \n> 从消息队列中取得信息\n> 其中关键注解是: @EnableBinding(Sink.class)\n```java\n@Component\n@EnableBinding(Sink.class)\npublic class ReceiveMessageListener {\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @StreamListener(Sink.INPUT)\n    public void input(Message<String> message) {\n        System.out.println(\"port:\" + serverPort + \"\\t接受：\" + message.getPayload());\n    }\n\n}\n```\n# 消息持久化\n> 消息持久化主要是依靠yml配置中binder下的input下的group属性，当停机之后如果消息队列中有消息在流通，配置了group属性的实例，重启之后仍然能够收到消息，如果没配置的话，将会错过消息","categories":["Service_MQ"],"tags":["MQ","SpringCloud-Stream"]},{"title":"Cloud_Config","url":"/posts/8012/","content":"> 主要总结和介绍了SpringCloud的常用配置\n<!--more-->\n> 要测试的话，也要在Windows的host文件做修改：127.0.0.1 config-3344.com\n> 测试链接：http://config-3344.com:3344/main/config-dev.yml\n# 主启动类注解引入\n```java\n@EnableConfigServer\n```\n# 依赖引入\n```xml\n   <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-config-server</artifactId>\n        </dependency>\n```\n# 中心Config的yml 配置\n```yml\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://gitee.com/mx0425/springcloud-config.git #GitHub上面的git仓库名字\n          ####搜索目录\n          search-paths:\n            - springcloud-config\n      ####读取分支\n      label: master\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n\n```\n# Client端Config的yml配置\n```yml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: main #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址k\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n```\n# Client端手动版动态刷新\n>**Controller层**\n```java\n类名上添加注解\n@RefreshScope\n```\n```yml\n# 暴露监控端点: 实现动态刷新用的\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n\n```\n>* **localhost:3355/actuator/refresh** \n>* 此时需要发一个如上的固定的post请求来刷新，这种方式只能针对单个的端口，下例就是3355这个端口进行刷新。\n>- - -\n>* 这样显然有**弊端**：假如有多个微服务客户端3355/3366/3377。。。。每一个都要手动去刷新岂不是很麻烦？？  \n>- - -\n>**优化**: 通过广播，一次通知，处处生效  \n>**广播设计思想**: 广播通知的是中心config  \n\n> 具体优化思想，见博文 Cloud_MQ\n\n\n","categories":["Serice_Config"],"tags":["SpringCloudConfig"]},{"title":"GateWay","url":"/posts/4296/","content":">对服务网关GateWay的知识总结\n<!--more-->\n# 核心与注意点\n>* GateWay作为网关也需要注册进注册中心\n>* 路由、断言、过滤器\n>* 网关不能部署在Tomcat、Jetty等Servlet容器里，只能打成jar包执行\n>* ​依赖于netty和WebFlux \n>* GateWay不能加Web的起步依赖的jar包\n\n# 架构图\n![alt](http://xtzl.wentexl.cn/%E6%9E%B6%E6%9E%84%E5%9B%BE.png)\n# 依赖导入\n```xml\n      <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-gateway</artifactId>\n        </dependency>\n```\n# 第一种配置方法：yml配置\n```yml\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n       #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名\n        - id: payment_routh\n          #uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/get/**         # 断言，路径相匹配的进行路由\n         #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n        - id: payment_routh2\n         # uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/lb/**         # 必须是真正提供服务的方法 \n         #- After=2020-05-13T21:55:10.016+08:00[Asia/Shanghai]\n         # -Before\n         # -Between=2020-05-13T21:55:10.016+08:00[Asia/Shanghai],2021-05-13T21:55:10.016+08:00[Asia/Shanghai]\n         #- Cookie=username,milo\n         #- Header=X-Request-Id, \\d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client: #服务提供者provider注册进eureka服务列表内\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultZone: http://eureka7001.com:7001/eureka\n\n```\n\n# 第二种配置方法：Config配置\n> 当访问/guonei的时候，自动转发到http://news.baidu.com/guonei\n```java\n   @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)\n    {\n        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();\n        routes.route(\"path_route_atguigu\",\n                r -> r.path(\"/guonei\")\n                        .uri(\"http://news.baidu.com/guonei\")).build();\n        return routes.build();\n    }\n\n```\n# yml配置的时候，断言选项\n![断言](http://xtzl.wentexl.cn/GateWay%E6%96%AD%E8%A8%80.png)\n\n# curl开发\n>*  判断是否携带名为X-Request-Id的请求头，且其值必须是一个大于0的整数  \n>* -Header=X-Request-Id, \\d+   \n>* curl http://localhost:9527/payment/lb -H \"X-Request-Id:123\"\n>- - -\n>* 判断请求是否携带cookie名为username，值为milo\n>*  -Cookie = username,milo\n>* curl http://localhost:9527/payment/lb --cookie \"username=123\"\n\n# 自定义过滤器\n> 主要是要实现GlobalFilter,Ordered这两个接口\n```java\n@Component\n@Slf4j\npublic class MyLogGateWayFilter implements GlobalFilter,Ordered\n{\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain)\n    {\n        log.info(\"***********come in MyLogGateWayFilter:  \"+new Date());\n        String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\");\n        if(uname == null)\n        {\n            log.info(\"*******用户名为null，非法用户，o(╥﹏╥)o\");\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\n            return exchange.getResponse().setComplete();\n        }\n        return chain.filter(exchange);\n    }\n    @Override\n    public int getOrder()\n    {\n        return 0;\n    }\n}\n```","categories":["Service_Gateway"],"tags":["GateWay"]},{"title":"JavaUtils","url":"/posts/13372/","content":">主要介绍了Java的各种工具类\n<!--more-->\n# IdUtil\n>* 主要介绍了各种id生成策略\n>* 生成的Id是用不重复的 \n>* String serialNumber = IdUtil.simpleUUID();\n\n# TimeUnit\n>* TimeUnit.DAYS //天  \n>* TimeUnit.HOURS //小时  \n>* TimeUnit.MINUTES //分钟  \n>* TimeUnit.SECONDS //秒  \n>* TimeUnit.MILLISECONDS //毫秒  \n>* TimeUnit.NANOSECONDS //毫微秒  \n>* TimeUnit.MICROSECONDS //微秒  \n>- - -\n>**转换：**\n>* public long toMillis(long d)    //转化成毫秒  \n>* public long toSeconds(long d)  //转化成秒  \n>* public long toMinutes(long d)  //转化成分钟  \n>* public long toHours(long d)    //转化成小时  \n>* public long toDays(long d)     //转化天   \n>- - -\n>**延时：** \n>* TimeUnit.SECONDS.sleep( 5 );\n>* TimeUnit.HOURS.sleep(1);\n\n# ZoneDateTime\n>* ZoneDateTime.now();可以获得当前时间串，在gateway中可以配置使用","categories":["Utils"],"tags":["JavaUtils"]},{"title":"Cloud_Hystrix","url":"/posts/64571/","content":">Hystrix属于服务降级部分，这里将会详细介绍关于Hystrix的相关知识\n<!--more-->\n# Hystrix介绍\n>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等。  \n>Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。  \n>- - -\n>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控(类似熔断保险丝)，向调用方返回—个符合预期的、可处理的备选响应(FallBack)。  \n>而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n\n# Hystrix核心\n> * 服务降级\n> * 服务熔断\n> * 接近实时的监控\n\n# 依赖导入\n```xml\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n        </dependency>\n```\n>- - -\n# 服务降级----------------\n# 服务提供端8001设置fallbcakMethod兜底\n>- - -\n>主启动类添加注解，开启断路器功能\n```java\n@EnableCircuitBreaker\n```\n>- - -\n> 解释：  \n>* 业务层添加。如果paymentInfo_TimeOut()在规定的3s内执行失败，则立即访问   paymentInfo_TimeOutHandler()方法作为fallbackMethod方法  \n> * 只要是当前服务不可用了，马上做服务降级\n> * 如果是在服务端配置的服务降级，不能通过80端口回调，只能自测\n```java\n    @HystrixCommand(fallbackMethod = \"paymentInfo_TimeOutHandler\",\n    commandProperties = {\n        @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"3000\")})\n    public String paymentInfo_TimeOut(Integer id)\n    {\n        try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }\n        return \"线程池:  \"+Thread.currentThread().getName()+\" id:  \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\"+\"  耗时(秒): 5\";\n    }\n\n    public String paymentInfo_TimeOutHandler(Integer id)\n    {\n        return \"线程池:  \"+Thread.currentThread().getName()+\"  8001系统繁忙或者运行报错，请稍后再试,id:  \"+id+\"\\t\"+\"o(╥﹏╥)o\";\n    }\n\n```\n\n# 客户端80设置fallbackMethod\n>主启动类添加注解  \n> 其中@EnableHystrix中也包含了@EnableCircuitBreaker\n```java\n@EnableHystrix\n```\n>- - -\n>客户端yml中的配置  \n\n```yml\nfeign:\n  hystrix:\n  #如果处理自身的容错就开启。开启方式与生产端不一样。\n    enabled: true \n```\n>通用fallback方法 :  \n\n> 若单个方法有具体指明fallback方法，则使用其具体的方法\n```java\n// hystrix 全局fallback方法标注在Controller的类头\n@DefaultProperties(defaultFallback = \"payment_Global_FallbackMethod\")\npublic class OrderFeignController{}\n```\n\n# 客户端80解决代码冗余和膨胀\n> 这样写的话，就不需要在Controller层进行指定了\n> 这样写的优先级仍然大于DefaultProperties的优先级\n```java\n// 在service层的注解添加fallback\n@FeignClient(value = \"cloud-provider-hystrix-payment\",fallback = PaymentFallbackServiceImpl.class)\n```\n```java\n// 书写service层的实现类\n@Component\npublic class PaymentFallbackServiceImpl implements PaymentFeignService {}\n```\n>- - -\n# 服务熔断-----------------------------------\n>## 核心\n> * 服务降级--熔断--慢慢恢复调用电路  \n>- - -\n\n\n> # 服务端\n> ## Controller层\n```java\n  //====服务熔断\n    @GetMapping(\"/payment/circuit/{id}\")\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id)\n    {\n        String result = paymentService.paymentCircuitBreaker(id);\n        log.info(\"****result: \"+result);\n        return result;\n    }\n```\n>## Serice层\n\n```java\n //=====服务熔断\n    @HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\",commandProperties = {\n        // 是否开启断路器v\n        @HystrixProperty(name = \"circuitBreaker.enabled\",value = \"true\"),\n        // 请求次数\n        @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),\n         // 时间窗口期，在这个时间以内，请求次数达到多少后跳闸\n        @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),\n        // 失败率达到多少后跳闸\n        @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\",value = \"60\"),\n    })\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id)\n    {\n        if(id < 0)\n        {\n            throw new RuntimeException(\"******id 不能负数\");\n        }\n        // 使用工具包生成流水号\n        String serialNumber = IdUtil.simpleUUID();\n\n        return Thread.currentThread().getName()+\"\\t\"+\"调用成功，流水号: \" + serialNumber;\n    }\n    public String paymentCircuitBreaker_fallback(@PathVariable(\"id\") Integer id)\n    {\n        return \"id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: \" +id;\n    }\n\n```\n\n# Hystrix断路器总结\n## 熔断需要依靠断路器\n![断路器](http://xtzl.wentexl.cn/%E6%96%AD%E8%B7%AF%E5%99%A8.png)\n\n## 断路器开启或关闭的条件\n>* 当满足一定的阀值的时候(默认10秒内超过20个请求次数)\n>* 当失败率达到一定的时候( 默认10秒内超过50%的请求失败)\n>* 到达以上阀值，断路器将会开启\n>* 当开启的时候，所有请求都不会进行转发\n>* 一段时间之后(默认是5秒)，这个时候断路器是半开状态，会让其中-一个请求进行转发。\n>* 如果成功，断路器会关闭，若失败，继续开启。\n\n# HystrixDashboard\n## 监控图详解\n![监控图](http://xtzl.wentexl.cn/%E7%9B%91%E6%8E%A7%E5%9B%BE.png)\n## 监控数据详解\n![监控数据](http://xtzl.wentexl.cn/%E7%9B%91%E6%8E%A7%E5%9B%BE%E6%95%B0%E6%8D%AE.png)","categories":["Service_degradation"],"tags":["Hystrix"]},{"title":"Cloud_OpenFeign","url":"/posts/40393/","content":">主要记录了关于OpenFeign的知识\n<!--more-->\n\n# 核心\n>* 微服务接口 + @FeignClient\n>* Feign自带负载均衡配置项，默认支持Ribbon\n>* OpenFeign默认等待1秒钟，之后将会报超时错误\n>* 面向接口编程\n>* 主要就是在80端口多了一层Service\n>* 在Service层这里直接使用注解而不使用RestTemplate\n>* 更加方便和简洁\n>* @FeignClient()接口类中，使用@RequestParam时必须指定value\n>* Feign和热部署有可能会冲突，且在使用的时候，要注意接口层的参数是否有在请求体内的，如果没表明是否在请求体，会导致调用失败，如果在请求体，就要更换httpclient的依赖，否则可能会出现Get请求被自动转成Post请求的情况\n\n\n# 依赖引入\n```xml\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-openfeign</artifactId>\n        </dependency>\n```\n# 主启动类\n```java\n@EnableFeignClients\n```\n# 80端微服务接口\n**Serice端**\n```java\n@Component\n@FeignClient(value = \"cloud-payment-service\")\npublic interface PaymentFeignService\n{\n    // 这里面的GetMapping是指的是服务实例中的方法的路径，并且会自动将获取到的路径变量加到路径中去\n    @GetMapping(value = \"/payment/get/{id}\")\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id);\n}\n```\n**Controller端**\n```java\npublic class OrderFeignController\n{\n    @Resource\n    private PaymentFeignService paymentFeignService;\n    @GetMapping(value = \"/consumer/payment/get/{id}\")\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id)\n    {\n        return paymentFeignService.getPaymentById(id);\n    }\n\n}\n```\n\n# 设置超时时间\n```yml\n#设置feign客户端超时时间(OpenFeign默认支持ribbon)\nribbon:\n  #指的是建立连接所用的时间，适用于网络状况正常的情况下, 两端连接所用的时间\n  ReadTimeout: 5000\n  #指的是建立连接后从服务器读取到可用资源所用的时间\n  ConnectTimeout: 5000\n```\n# 设置OpenFeign的日志\n## 自定义Config类，加入Bean设置日志级别\n```java\n@Configuration\npublic class FeignConfig\n{\n    @Bean\n    Logger.Level feignLoggerLevel()\n    {\n        return Logger.Level.FULL;\n    }\n}\n```\n## 在yml配置中设置日志的监控接口\n```yml\nlogging:\n  level:\n    # feign日志以 debug 级别监控 com.atguigu.springcloud.service.PaymentFeignService 接口，debug级别会直接在控制台console中打印出来\n    xtzl.ljw.service.PaymentFeignService: debug\n```\n","categories":["Service_invoke"],"tags":["OpenFeign"]},{"title":"Ribbon","url":"/posts/49475/","content":"> 整理了关于Ribbon的相关知识\n<!--more-->\n# 核心\n>* 主要核心就是负载均衡\n\n# 依赖引入\n```xml\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n      <version>2.2.1.RELEASE</version>\n      <scope>compile</scope>\n    </dependency>\n```\n# Ribbon的核心组件IRule七种负载均衡的选择方式\n>- - -\n>(出厂默认)RoundRobinRule： 轮询，轮流访问不同的实例\n>- - -\n>RandomRule : 随机，随机访问不同的实例\n>- - -\n>RetryRule:  \n先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内进行重试，获取可用的服务。\n>- - -\n>WeightedResponseTimeRule:  \n对RoundRobinRule的扩展，响应速度越快的实例选择权重就越大，越容易被选择。\n>- - -\n>BestAvailableRule:  \n会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务。\n>- - - \n>AvailabilityFilteringRule:  \n先过滤掉故障实例，再选择并发较小的实例。\n>- - -\n>ZoneAvoidanceRule:  \n>默认规则，复合判断server所在区域的性能和server的可用性选择服务器。\n>- - -\n# Ribbon修改负载均衡的方式\n> **一定不能在主配置类可以扫到的包下，必须新建一个主配置类扫不到的包**\n> 注意点：  \n> * 注解里的服务名要小写\n> * 配置类名不能是MyRule，否则报错\n```java\n// IRule配置类添加\n@Configuration\npublic class MySelfRule {\n    @Bean\n    public IRule myrule(){\n        // 修改为随机方式\n        return new RandomRule(); \n    }\n}\n\n//80端口主运行类注解添加\n//其中name表示的是微服务名称\n@RibbonClient(name = \"cloud-payment-service\",configuration = MySelfRule.class)\n```\n# Ribbon的轮询算法\n> rest接口的第几次请求数 % 服务器集群实例数量 = 实际调用的服务器(实例)的下标\n```java\n// 获取指定服务的所有实例集合\n List<ServiceInstance> instances = discoveryClient.getInstances(\"consul-provider-payment\");\n 例如：\n instances[0]=127.0.0.1:8001\n instances[1]=127.0.0.1:8002\n\n```\n\n\n\n","categories":["Service_invoke"],"tags":["Ribbon"]},{"title":"Cloud_Sleuth","url":"/posts/15024/","content":"> 分布式请求链路跟踪  :   \n> 总结了Springcloud-Sleuth的相关知识\n<!--more-->\n# zipkin  \n>* 安装使用jar包，然后直接敲 java -jar xxx.jar 这个命令就好\n>* 图形化界面端口号9411  \n\n**链路图:**\n![链路图](http://xtzl.wentexl.cn/Sleuth%E5%9B%BE.png)\n>* span 表示链路来源：通俗来说 span 就是一次请求信息\n>* Trance 类似于树结构的Span集合，表示一条调用链路，存在唯一标识\n\n**依赖引入**\n```xml\n     <!--包含了sleuth+zipkin-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zipkin</artifactId>\n        </dependency>\n```\n**yml配置**\n> yml解释：\n>* base-url: 监控的数据需要发到9411上去  \n>* 采样率一般0.5就够了，表示只需要一半的数据就好\n```yml\nspring:\n    zipkin:\n        base-url: http://localhost:9411\n    sleuth:\n        sampler:\n        #采样率值介于0到1之间，1则表示全部采集\n        probability: 1\n```\n\n","categories":["Service_Sleuth"],"tags":["Sleuth"]},{"title":"Consul","url":"/posts/29713/","content":">总结了关于Consul的相关知识点\n<!--more-->\n# 小知识\n>* 启动consul可以配置环境变量\n>* consul agent -dev 命令来启动consul\n>* Consul的首页： http://localhost:8500\n\n# 依赖导入\n```xml\n   <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n        </dependency>\n```\n# application.yml 配置\n```yml\n###consul服务端口号\nserver:\n  port: 8006\n\nspring:\n  application:\n    name: consul-provider-payment\n  ####consul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n\n```\n# 主启动类\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\n```\n\n","categories":["Service_Registry"],"tags":["Consul"]},{"title":"GitWords","url":"/posts/17418/","content":">记录了git的常用命令\n<!--more-->\n# Git颜色\n>* 红褐色：创建之后没有add，没提交，不在版本控制范围之内，这时候文件是红褐色的，需要先add文件；\n>* 绿色：add之后是文件绿色的，没有提交（commit）;\n>* 蓝色：原本拉取过来之后就有一个文件，改动过后没有提交（commit）是蓝色的，提交之后，变成正常颜色。\n# Git常用操作命令\n>* git ls-files 查看暂存区文件\n>- - -\n>* git init 初始化仓库\n>- - -\n>* git add . 添加所有文件进暂存区\n>- - -\n>* git commit 提交到本地仓库\n>- - -\n>* git push 推送到远程仓库\n>- - -\n>* git pull 从远程仓库拉取最新代码\n>- - -\n>* git checkout -b master 新建一个master分支\n>- - -\n>* git branch -al 查看所有分支\n>- - -\n>* git checkout 本地分支名 切换到其他的本地分支\n>- - -\n>* git remote add origin git@github.com:xxxx/xx.git //origin是自定义的远程库的名字，这是给本地仓库添加远程仓库\n>- - -\n>* git remote rm origin 与远程仓库解绑\n>- - -\n>* git remote -v 查看远程仓库的相关信息\n>- --\n>* git push -u origin master  //把当前分支master推送到远程；远程库是空的，所以第一次push加上-u参数；不仅推送了且两个master分支相关联，后续push命令简化git push origin master\n>- - -\n>* git clone git@github.com:lengnuann/L.git xtzl/ljw/ 克隆指令将远程仓库的代码克隆到本地的xtzk/ljw这个文件夹之下\n>- - -\n>* git log 查看日志\n>- - -\n>* git branch --set-upstream-to origin/main master 关联分支，将远程仓库的main分支和master相关联，如果执行失败，先去IDEA的Git下的Pull中获取分支，多刷新一下\n>- - -\n>* git stash 暂存工作区的内容\n>- - -\n>* git stash pop 恢复暂存的工作区内容\n>- - -\n>* git stash list 查询工作区所有stash的列表\n>- - -\n>* git stash apply 例如：git stash apply stash@{2} 表示指定stash@{2}这个暂存版本，如果不指定，则git stash pop默认恢复最新的一次stash\n>- - -\n>* git stash clear 清空stash\n>- - -\n>* git branch --set-upstream-to=gitee/master master :关联远程分支与本地分支，第二个master指的是第本地分支，gitee/master，指的是gitee设置远程仓库名，中的远程分支master\n>- - -\n>* git reset --hard 6b2b7aa ：强制回退到某个版本，将不会保存原来的代码（慎用！！！）\n>- - -\n>* git branch  --track  experimental  origin/experimental ：同样是追踪分支\n\n\n","categories":["command"],"tags":["git"]},{"title":"LinuxWords","url":"/posts/17418/","content":">总结了一些关于linux的操作命令\n<!--more-->\n\n># SCP命令\n>## 将本地linux服务器的文件拷贝到远程的linux服务器上\n```linux\nscp  /root/file1.txt  username@202.202.146.245:/home/S12004060119/\n```\n>## 将远程linux的文件拷贝到自己的linux本地服务器\n```linux\nscp  username@202.202.146.245:/home/S12004060119/file.txt /root/sh/\n```\n>## 把本地Windows系统的文件夹传到远程linux服务器上\n```linux\nscp -P 22 -r E:\\weixin\\ S12004060119@202.202.146.245:/home/S12004060119/\n```\n># 快捷键\n>Ctrl+l  ：清屏  \nCtrl+o ：执行当前命令，并选择上一条命令  \nCtrl+s ：阻止屏幕输出  \nCtrl+q ：允许屏幕输出  \nCtrl+c ：终止命令  \nCtrl+z ：挂起命令  \nCtrl+d ：输入结束，即EOF的意思，或者注销linux系统\n\n\n# 基本命令\n>* pwd命令  \n>查看当前用户所在的路径\n>* passwd命令  \n>格式： passwd 用户名\n>给用户指定密码\n>* init 命令  \n>Int 3：字符界面\n>Int 5：图形界面\n>* set nu 命令  \n>set nu表示设置行号\n>set nonu表示取消行号\n>* cat命令  复制文件  \n>Cat file1.txt>>file2.txt\n>* cp复制  \n>cp file1.txt /*/*/*\n>* mv命令  \n>mv a b 实现重命名  \n>mv 文件名 移动目的地后的文件名  \n>mv 文件名 修改后的文件名\n","categories":["command"],"tags":["linux"]},{"title":"IDEA_Hotkeys","url":"/posts/10025/","content":"> IDEA的使用快捷键\n<!--more-->\n>**IDEA使用的快捷键**   \n\n>ctrl + D：复制上一行  \n>- - -\n>Ctrl+D: 同时也可以表示结束输入  \n>- - -\n>Shift + alt +↑（↓） ：上下移动某一行  \n>- - -\n>ctrl+/ ：注释  \n>- - -\n>ctrl+r : 查找和替换  \n>- - -\n>ctrl+alt+t: 抓异常快捷键  \n>- - -\n>shift连按两次：查询  \n>- - -\n>ctrl+alt+b：通过接口查看其实现类 \n>- - - \n>alt+insert+fn : 生成getter和setter方法  \n>- - -\n>ctrl+f: 搜索查看  \n>- - -\n>ctrl+a：一键全选  \n>- - -\n>shift+home:选中单行  \n>- - -\n>Ctrl+i:  选择实现方法  \n>- - -\n>Ctrl+Q: 上下文信息，看需要什么参数  \n>- - -\n>shift+tab:取消缩进\n>- - -\n>Ctrl+alt+B: 显示实现类\n>- - -\n>Ctrl+shift+n : 查找类或者文件 \n>- - -\n>Ctrl + O : 快速重写\n>- - -\n>- - -\n>**调试**\n>* F8单步调试。不进入函数内部\n>- - -\n>* F7 单步调试 进入函数肉部\n>- - -\n>* Shift+F7 选择要进入的函数\n>- - -\n>* Shift+F8 跳出函数\n>- - -\n>* Alt+F9 运行到断点\n>- - -\n>* Alt+F8 执行表达式查看结果\n>- - -\n>* F9继续执行，进入下一个断点或执行完程序\n>- - -\n>* Ctr|+F8 设置/取消当前行断点\n>- - -\n>* Ctrl+Shift+F8 查看断点\n>- - -","categories":["IDEA"],"tags":["Hotkeys"]},{"title":"Eureka","url":"/posts/57702/","content":">关于EureKa的知识笔记：Eureka的服务注册与发现\n<!--more-->\n# 小知识\n> * Eureka不用自己注册自己\n> * 注意启动顺序，服务端必须先启动才能检索到客户端\n> * 集群配置：互相注册，相互守望\n> * 配置host之后记得在cmd使用ipconfig /flushdns刷新一下\n> * 大坑！！！:配置集群之后，直接点击链接是访问不了的！！多了一层路径！必须要手动输入地址!\n> * defaultZone如果有多个url，不同的url通过逗号隔开\n\n># 依赖引入\n>## 服务注册端 server\n```xml\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n        </dependency>\n```\n>## 客户端 client\n```xml\n         <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n```\n\n># 单机版在Application.yml中配置\n>## 单机版在server端中的yml配置\n```yml\neureka:\n instance:\n   hostname: localhost  #eureka服务端的实例名字\n client:\n   register-with-eureka: false    #表示不向注册中心注册自己\n   fetch-registry: false   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\n   service-url:\n     #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n     defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\n```\n>## 单机版在client端的yml配置\n```yml\neureka:\n  client:\n    #表明自己需要注册进Eureka中\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有信息，默认为true。\n    #单节点无所谓，集群的话必须设置为true才能配合ribbon使用负载均衡\n    fetch-registry: true\n    service-url:\n      #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n      #单机指向自己\n      defaultZone: http://localhost:7001/eureka\n\n```\n\n\n> # 集群版在Application.xml中的配置\n> ## 在Client端的yml配置\n>- - -\n> 最主要的在于defalutZone的变化  \n> eureka7001.com是host文件配置的主机名\n> \n```yml\neureka:\n  client:\n    register-with-eureka: true\n    fetch-registry: true\n    service-url:\n    #集群指向所以注册中心的eureka\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n```\n>## 在Server端的yml配置\n```yml\neureka:\n  instance:\n    hostname: eureka7002.com  #eureka服务端的实例名字\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n    service-url:\n    #集群指向其他eureka\n      defaultZone: http://eureka7001.com:7001/eureka\n```\n\n># 在主运行类中的注解标识\n>## Server端使用的主键\n```java\n@EnableEurekaServer\n```\n>## Client端使用的注解\n```java\n@EnableEurekaClient\n```\n\n># 服务发现\n> 将服务信息放到到注册中心去  \n> 通过服务发现来活动该服务的信息\n```java\n    // Controller 添加\n    @Resource\n    private DiscoveryClient discoveryClient;\n    \n    // 主运行类添加\n    @EnableDiscoveryClient\n```\n\n# Instance配置\n```yml\n  instance:\n    # 微服务下实例名称修改\n    instance-id: payment8002\n    # 显示IP地址\n    prefer-ip-address: true\n```\n># Eureka的自我保护机制\n>自我保护机制:默认情况下EurekaClient定时向EurekaServer端发送心跳包  \n如果Eureka在server端在一定时间内(默认90秒)没有收到EurekaClient发送心跳包 ,便会直接从服务注册列表中剔除该服务  \n>但是在短时间( 90秒中)内丢失了大量的服务实例心跳,\n这时候EurekaServer会开启自我保护机制,不会剔除该服务(该现象可能出现在网络不通的情况使得 EurekaClient为出现宕机  \n>此时如果换做别的注册中心如果一定时间内没有收到心跳会将剔除该服务,这样就出现了严重失误,因为客户端还能正常发送心跳只是网络延迟问题，而保护机制是为了解决此问题而产生的)\n\n># 关闭Eureka的自动保护机制\n>server端\n```yml\n## Server端的yml中设置关闭自我保护机制，保证不可用服务被及时踢除\neureka:\n  server:\n     enable-self-preservation: false\n     eviction-interval-timer-in-ms: 2000\n```\n>client端设置心跳响应时间\n```yml\neureka:\n  instance:\n#    Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\n   lease-renewal-interval-in-seconds: 1\n#    Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\n   lease-expiration-duration-in-seconds: 2\n```\n","categories":["Service_Registry"],"tags":["Eureka"]},{"title":"Cloud-summary","url":"/posts/42402/","content":">介绍和总结整个SpringCloud的理论体系\n# SpringCloud架构图\n![SpringCloud架构图](http://xtzl.wentexl.cn/SpringCloud%E6%9E%B6%E6%9E%84%E5%9B%BE.png)\n\n<!--more-->\n# 注册中心的异同点\n>## **CAP**\n>- - -\n>**解释**：  \n>C :(强一致性):   对某个指定的客户端来说，读操作保证能够返回最新的写操作结果。  \n>A :(可用性):     非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应)  \n>P :(分区容错性): 当出现网络分区后，系统能够继续“履行职责”。\n>- - -\n>* 分布式系统理论上不可能选择CA架构，只能选择CP或者AP 架构。\n>* CAP理论关注粒度是数据，而不是整个系统的设计策略\n>* AP(Eureka) ; CP(Consul) ; HA(高可用，也是Eureka)  \n>![CAP](http://xtzl.wentexl.cn/SpringCloud/CAP.png)\n\n\n# SpringCloud总图\n![总图](http://xtzl.wentexl.cn/SpringCloud.png)\n\n\n","categories":["SpringCould"],"tags":[]},{"title":"dependencies","url":"/posts/18669/","content":"> 该博文主要记录了在Cloud微服务开发中常用的依赖\n\n# 父工程\n```xml\n<!-- 统一管理jar包版本 -->\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n        <junit.version>4.12</junit.version>\n        <log4j.version>1.2.17</log4j.version>\n        <lombok.version>1.16.18</lombok.version>\n        <mysql.version>5.1.47</mysql.version>\n        <druid.version>1.1.16</druid.version>\n        <mybatis.spring.boot.version>1.3.0</mybatis.spring.boot.version>\n    </properties>\n\n    <!-- 1、只是声明依赖，并不实际引入，子项目按需声明使用的依赖 -->\n    <!-- 2、子项目可以继承父项目的 version 和 scope -->\n    <!-- 3、子项目若指定了 version 和 scope，以子项目为准 -->\n    <dependencyManagement>\n        <dependencies>\n            <!--spring boot 2.2.2-->\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-dependencies</artifactId>\n                <version>2.2.2.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <!--spring cloud Hoxton.SR1-->\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Hoxton.SR1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <!--spring cloud alibaba 2.1.0.RELEASE-->\n            <dependency>\n                <groupId>com.alibaba.cloud</groupId>\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n                <version>2.1.0.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n\n<!-- 以上依赖不能出现在子工程 -->\n\n\n            <dependency>\n                <groupId>mysql</groupId>\n                <artifactId>mysql-connector-java</artifactId>\n                <version>${mysql.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.alibaba</groupId>\n                <artifactId>druid</artifactId>\n                <version>${druid.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>org.mybatis.spring.boot</groupId>\n                <artifactId>mybatis-spring-boot-starter</artifactId>\n                <version>${mybatis.spring.boot.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>junit</groupId>\n                <artifactId>junit</artifactId>\n                <version>${junit.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>log4j</groupId>\n                <artifactId>log4j</artifactId>\n                <version>${log4j.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>org.projectlombok</groupId>\n                <artifactId>lombok</artifactId>\n                <version>${lombok.version}</version>\n                <optional>true</optional>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n\n# 子工程\n```xml\n\n    <dependencies>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/com.alibaba/druid -->\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid-spring-boot-starter</artifactId>\n            <version>1.2.8</version>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-jdbc</artifactId>\n        </dependency>\n           <!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n     </dependencies>\n```\n# 通用工程依赖\n```xml\n <dependencies>\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all -->\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-all</artifactId>\n            <version>5.1.0</version>\n        </dependency>\n</dependencies>\n\n```","categories":["dependencies"],"tags":["dependencies"]},{"title":"Configuration_header","url":"/posts/65104/","content":">在Web开发中，该博文对常用配置类的配置头进行了总结\n<!--more-->\n# Web开发常用配置头的总结\n\n>## Mabatis的 Mapper.xml 配置头\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"xtzl.ljw.Dao.PaymentMapper\">\n</mapper>\n``` \n \n>## Bean.xml 配置头\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n</beans>\n\n```","categories":["Configuration"],"tags":["Configuration_header"]},{"title":"Cpp_accumulate","url":"/posts/31024/","content":">总结了Mabtis的一些小细节的知识\n<!--more-->\n\n# Mabatis&&Plus 小知识总结\n\n## type-aliases-package\n### type-aliases-package作用\n>在Mybatis的mapper.xml文件中resultType的type或者paramterType会返回自定义entity  \n此时可以用全类名名来指定这些实体。\n### type-aliases-package配置\n```yml\nmybatis:\n    type-aliases-package=xtzl.ljw.entities\n```\n\n## 指定Mapper路径\n```yml\nmybatis:\n    mapper-locations: classpath:mapper/*.xml\n```\n## useGeneratedKeys\n>在使用useGeneratedKeys=\"true\"后返回值是1，期待返回实体主键\n>insert方法返回值依然是修改行数  \n需要从传入的实体中取对应属性值。  \n比如user表对应User类，主键是id\n那么int i =insertUser（user）;  \n方法执行后 i 还是1\n但是user.getId();得到的值就是主键了\n>- - -\n>一般来说需要和 keyProperty=\"id\" 联用，意为指定主键\n","categories":["Mabtis"],"tags":["accumulate"]},{"title":"JavaNorms","url":"/posts/17711/","content":"> 在学习过程中，对一些常见的开发格式和开发规范，以及一些规范类进行了整理和总结\n<!--more-->\n\n# 规范类:\n## POJO 类\n```markdown\n\"Plain Ordinary Java Object\"，简单普通的java对象。主要用来指代那些没有遵循特定的java对象模型，约定或者框架的对象。\n\nPOJO的内在含义是指那些:\n有一些private的参数作为对象的属性，然后针对每一个参数定义get和set方法访问的接口。\n没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。\n```\n\n## JavaBean\n```markdown\nJavaBean 是一种JAVA语言写成的可重用组件。JavaBean符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。\n它的方法命名，构造及行为必须符合特定的约定:\n    · 所有属性为private。\n    · 这个类必须有一个公共的缺省构造函数。即是提供无参数的构造器。\n    · 这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范。\n    · 这个类应是可序列化的。实现serializable接口。\n\n因为这些要求主要是靠约定而不是靠实现接口，所以许多开发者把JavaBean看作遵从特定命名约定的POJO\n```\n# Rest风格详情介绍\n>* GET （常用于查询）\n>- - -\n>* POST（常用于保存）\n>- - -\n>* PUT（常用于更新修改）\n>- - -\n>* DELETE（常用于删除）\n\n## 传统风格: RequestMapping\n><![传统风格](http://xtzl.wentexl.cn/CT.png)  \n## Restful风格: 增删改查\n![Rest](http://xtzl.wentexl.cn/Rest%E9%A3%8E%E6%A0%BC.png)\n## 两种模式的区别：\n>**风格与规则的区别：**  \n>Restful风格要简洁了很多，并且把行为都隐藏了  \n风格是一种约定俗成的方式，这种约定并不是一定要遵守的，可以不去使用这种约定，即也可以使用传统风格。而规范呢是一种大家必须遵守的规则，你如果不按照这个规范来书写代码，那么就不被允许运行。  所以被叫做REST风格，而不是叫做REST规范。  \n\n\n","categories":["Java"],"tags":["JavaNorms"]},{"title":"S_Annotation","url":"/posts/54839/","content":"> 注解的使用\n<!--more-->\n\n# 常用注解的解释与使用\n\n## 与 SQL 有关的注解\n### @Param\n首先明确这个注解是为SQL语句中参数赋值而服务的。    \n\n @Param的作用就是给参数命名，比如在mapper里面某方法A（int id）  \n 当添加注解后A（@Param(\"userId\") int id）  \n 也就是说外部想要取出传入的id值，只需要取它的参数名userId就可以了。  \n 将参数值传如SQL语句中，通过#{userId}进行取值给SQL的参数赋值\n\n```SQL\nmapper:\npublic User selectUser(@Param(\"userName\") String name,@Param(\"password\") String pwd);\n\nxml:\n<select id=\"selectUser\" resultMap=\"User\">  \n   select * from user  where user_name = #{userName} and user_password=#{password}  \n</select>\n可发现，userName为映射名，相当于起的是个别名\n\n注意点：  \n·当使用了@Param注解来声明参数的时候，SQL语句取值使用#{}，${}取值都可以。\n·当不使用@Param注解声明参数的时候，必须使用的是#{}来取参数。使用${}方式取值会报错。\n·不使用 @Param注解时，参数只能有一个，并且是Javabean。在SQL语句里可以引用JavaBean的性，而且只能引用JavaBean的属性。\n\n\n实际上：\n即便是不使用这个注解，也可以直接通过#{}去访问NewUser的成员变量，也是可以的，但是也只能有一个参数，这个参数就只能是NewUser这个JavaBean对象\n    <insert id=\"insertN\" parameterType=\"xtzl.boot.bean.NewUser\">\n        insert into user (username,password,sex,status) values (#{username},#{password},#{sex},#{status})\n    </insert>\n\n```\n### TableField\n>@TableField(exist = false) 注解加载bean属性上，表示当前属性不是数据库的字段，但在项目中必须使用，这样在新增等使用bean的时候，mybatis-plus就会忽略这个，不会报错。\n```java\n    // 插入\n    @TableField(fill = FieldFill.INSERT)\n    private LocalDateTime createTime;\n    // 插入或更新的时候填充字段\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private LocalDateTime updateTime;   \n\nDEFAULT ：默认不处理\nINSERT ： 插入操作时进行填充字段\nUPDATE ：更新操作时填充字段\nINSERT_UPDATE ：插入和更新操作时填充字段\n\n\n```\n## @EnableWebSecurity\n>**EnableWebSecurity注解有两个作用**\n>* 1: 加载了WebSecurityConfiguration配置类, 配置安全认证策略。\n>* 2: 加载了AuthenticationConfiguration, 配置了认证信息。\n\n","categories":["Annotation"],"tags":["Annotation"]},{"title":"Maven_Write","url":"/posts/35182/","content":"\n> 关于Maven的一些小知识点\n<!--more-->\n\n# 直接手动从中央仓库下载依赖\n>## 地址：https://www.mvnrepository.com/\n>## 下载格式\n```markdown\n    mvn dependency:get -DremoteRepositories=https://mvnrepository.com/artifact/org.projectlombok/lombok -DgroupId=org.projectlombok -DartifactId=lombok -Dversion=1.18.12\n\n特别注意： 等号后面一定不能留空格，否则会出现找不到坐标的错误\n\n```\n# 坐标\n>注：groupId 在新建项目的时候可以自行指定，以便于在项目中新建通用模块之后导入其他模块\n> - - - \n> groupId和artifactId是maven管理项目包时用作区分的字段，就像是地图上的坐标。  \nartifactId：artifactId一般是项目名或者模块名。  \ngroupId：groupId分为几个字段，例如cn.com.fullstack，前面的com叫【域】，后面的是你自己起的域名。\n>- - -\n>groupId一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。  \n域又分为org、com、cn等等许多，其中org为非营利组织，com为商业组织。  \n举个apache公司的tomcat项目例子：这个项目的groupId是org.apache，它的域是org（因为tomcat是非营利项目），公司名称是apache，artigactId是tomcat。","categories":["maven"],"tags":["maven"]},{"title":"Cloud-Base","url":"/posts/52648/","content":"\n> SpringCould的学习随堂笔记\n\n<!--more-->\n\n# SpringCould 随堂笔记\n\n>## 父工程框架  \n  \n> ### 父工程统一管理Jar包\n```xml\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>12</maven.compiler.source>\n    <maven.compiler.target>12</maven.compiler.target>\n    <junit.version>4.12</junit.version>\n    <lombok.version>1.18.10</lombok.version>\n    <log4j.version>1.2.17</log4j.version>\n    <mysql.version>8.0.21</mysql.version>\n    <druid.version>1.0.9</druid.version>\n    <mybatis.spring.boot.version>2.2.2</mybatis.spring.boot.version>\n  </properties>\n```\n>### 必要依赖\n```xml\n    <dependencies>\n      <!--spring boot 2.2.2-->\n      <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-dependencies</artifactId>\n        <version>2.2.2.RELEASE</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      <!--spring cloud Hoxton.SR1-->\n      <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-dependencies</artifactId>\n        <version>Hoxton.SR1</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      <!--spring cloud alibaba 2.1.0.RELEASE-->\n      <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n        <version>2.1.0.RELEASE</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n\n```\n\n\n>## 子工程application配置文件\n### 数据源配置\n```yml\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: org.gjt.mm.mysql.Driver\n    url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&characterEncoding=utf-8&useSSL=false\n    username: root\n    password: root\n\n```\n### 唯一标识\n```yml\nspring:\n  application:\n    name: cloud-payment-service\n```\n## Devtools 开启热部署\n> 注：电脑不太行不建议开启，太锤子卡了\n>1. 导入jar包\n>2. 引spring-boot-maven-plugin插件\n>3. 在IDEA的Compile中调设置.\n>4. 重启IDEA\n\n\n## RestTemplate\n> 可用 订单80端口去调用8001端口的服务进行操作\n```java\n  @Bean\n    public RestTemplate getRestTemplate(){\n        return new RestTemplate();\n    }\n```\n> ### 两种方式：\n```java\n  // 第一种是写死的，第二种是URL为集群的服务名\n  // 微服务可能有多个端口\n   // public static final String PAYMENT_URL=\"http://localhost:8001\";\n    public static final String PAYMENT_URL=\"http://CLOUD-PAYMENT-SERVICE\";\n    @Resource\n    private RestTemplate restTemplate;\n\n    // GET请求实际上调用了POST请求\n    @GetMapping(\"/consumer/payment/create\")\n    public CommonResult<Payment> create(Payment payment){\n        return restTemplate.postForObject(PAYMENT_URL+\"/payment/create\",payment,CommonResult.class);\n    }\n\n    @GetMapping(\"/consumer/payment/get/{id}\")\n    public CommonResult<Payment> getPayment(@PathVariable(\"id\") Long id){\n        System.out.println(id);\n        log.info(String.valueOf(id));\n        return restTemplate.getForObject(PAYMENT_URL+\"/payment/get/\"+id,CommonResult.class);\n    }\n\n坑： 此处我使用@Pathgram 无法获取到路径变量\n```\n**细节**  \n>在微服务的Controller中，涉及到POST请求，一定不要忘记加@RequstBody这个注解，当80端口的请求到微服务端口的方法时\n```java\n    @PostMapping(\"/payment/create\")\n    public CommonResult create(@RequestBody Payment payment){\n    }\n```\n# 负载均衡\n> 微服务没被写死端口号的时候\n> 在配置类里面必须加 @LoadBalanced 才行\n> @LoadBalanced赋予RestTemplate负载均衡的能力:轮班值日\n```java\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate(){\n        return new RestTemplate();\n    }\n```\n>**RestTemplate返回对象选择**\n![RestTemplate返回](http://xtzl.wentexl.cn/restTemplate%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1.png)\n\n","categories":["SpringCould"],"tags":["SpringCould"]},{"title":"CppFunctions","url":"/posts/12049/","content":"> 总结了C++常用函数\n\n<!-- more-->\n\n># C++ 函数总结\n\n>## 判断大小写\n```Cpp\n//用来判断一个字符是否为字母，如果是字符则返回非零，否则返回零。\n 1.isalpha()\n\n//用来判断一个字符是否为数字或者字母，也就是说判断一个字符是否属于a~z||A~Z||0~9。是返回非零，不是返回0。\n2.isalnum()\n\n//用来判断一个字符是否为小写字母，也就是是否属于a~z。是返回非零，不是返回0。\n3.islower()\n\n//用来判断一个字符是否为大写字母。是返回非零，不是返回0。\n4.isupper()\n\n//a为字符时，如果a是小写字母则将其转换为大写字母，否则不变。a为数字则将其按ASCLL码转换为对应字符。（其实即使a是字符，输入之后还是会将其转换为int类型）\n5. char c = toupper(a)\n\n//a为字符时，如果a是大写字母则将其转换为小写字母，否则不变。a为数字则将其按ASCLL码转换为对应字符。\n6.char c=tolower(a)\n\n//用来判断一个字符是否为数字，如果是数字则返回非零，否则返回零。\n7.isdigit()\n\n//将数字转换为字符串，这里注意如果是浮点型数转字符，会将精度范围内小数点后的数全部显示出来\n8.to_string()\n//数字转字符串：例如：\nfloat b = 2.;\ns = to_string(b);\ncout << s<<\" \"<<s.size();\n输出为：2.000000 8\n```\n> ## 字符串的复制和拼接\n  ```Cpp\n  strcpy函数进行字符串的复制\n  //将 first_name 复制给 full_name\n  strcpy(full_name, first_name);   \n\n------------------------------------------------------------------------\n\n  strcat()函数进行字符串的拼接\n  //将 last_name 拼接在 full_name 之后\n  strcat(full_name, last_name);   \n\n  // 字符与字符串之间可以用 + 来连接\n  string s; char ch;\n  s = s + ch;\n  ```\n\n## 字符串与整数的转换\n```Cpp\n// nums为字符串，stoi函数存在于头文件<string>中\nint k = stoi(nums);\n\n// num为整数，to_string函数也在string中\nstring s=to_string(num)\n```\n\n## 字符与整数的互换\n```Cpp\n// 字符转整数，直接强转\nchar c='8' ;\nint a ;\na =(int) (c - '0') ;\n\n// 整数转字符\nint b;\nchar c;\nc = b + '0'\n\n```\n\n# algorithm 函数中的reverse\n```Cpp\nreverse无返回值\n\nstr.begin()是指向str的第一个元素\nstr.end()是指向最后一个元素的后一个位置\n\n1.reverse(str.begin(),str.end()) 反转整个字符串\n \t \n2.reverse(vector.begin(),vector.end()) 反转向量\n \n3.reverse(a,a+strlen(a)) 反转数组\n```","categories":["Cpp"],"tags":["functions"]},{"title":"CppHeadFiles","url":"/posts/56443/","content":"> 介绍与总结了C++的常用头文件\n\n<!-- more -->\n# C++头文件总结\n## 多函数头文件\n```markdown\n1.include<iostream> 输入输出流，得调用这个头文件才能使用cin,cout\n\n2.#include<iomanip> 可以调用一些函数，如fixed()<<setprecision()等\n\n3.#include<cmath> 用于调用一些数学函数\n\n4.#include<string> 调用这个头文件才可以调用字符串类型的变量\n\n5.#include<algorithm> 用于调用各种函数，如sort()\n\n```\n\n## 数据结构头文件\n```markdown\n#include<list> : 列表 \n\n#include<map> ： map集合\n\n#include<queue> : 队列\n\n#include<vector> : 不定长数组\n\n#include<stack> : 栈\n\n```\n\n","categories":["Cpp"],"tags":[]},{"title":"CppLei","url":"/posts/20863/","content":">介绍了C++中常用的类型、关键字\n<!-- more -->\n\n# C++常用类型及其关键字整理\n>* 在C++中，指针和数组都是采用的引用传递，普通结构体，类，和其他基础类型都是采用的值传递\n>* 只有加了&才能让其他类型的数据使用引用传递\n>* 如果是指针传递，指针变量本身没加&就仍然是值传递，但是指针指向的地址上的改变是形参和实参一致的\n>## Bool 类型\n```cpp\nbool 变量是 值保存  真或者假这个值 （TRUE 或者 FAUSE），1表示真，0 表示假。在Ｃ语言中所有的非零值都为真所以给bool变量赋值，赋值为0则为0。赋值为非0 则为1。\n```\n>## Cout 关键字\n```cpp\nCout<<“sadasd”<< endl\n```\n>## Cin： 输入\n```cpp\nCin >> n;\n\nCin.getline(arrchar,20);\n\n注：getline()函数中的arrchar是表示的字符数组，20表示的是最多输入19个字符，或者遇到回车结束\n```\n>## const 类型\n```Cpp\nconst int max =500;\nconst static int arr[] = {1,2,3,4}\t\n注：const关键字主要是用来声明常量的，定义之后不能改变了\n```\n>## string 关键字\n```Cpp\nstring s1=”asd”;\n\nstring s2=”asdasd”;\n\nString s= s1+s2; // 字符串的拼接\n\n类比java的input.nextline（获取输入的整个一行）\ngetline(cin,s);// 获取输入的整个一行并赋值给字符串变量s\n\ns.length() // 获取字符串的长度，会包括空格\n\nS.substr(start,counts); // 从下标为start开始取，一共取counts个字符\n\nS.substr(start); // 从下标为start开始取，取遍整个字符串后面的所有字符\n```\n>## 结构体\n```Cpp\n    struct stu{\n        string name;\n        int age;\n    }\n\n    void main(){\n        stu a[10];\n    }\n\n    注:结构体可以直接用名字进行引用\n```\n>## &的引用\n```markdown\n    可在自定义的函数的参数前加一个&，main函数直接传参数，便可在地址上修改参数的值\n```\n>## Pair类型\n```cpp\n    定义和初始化：\n    pair<int,int> data;\n\n    pair<int,int> p2(p1); // 用已经有的pair对象p1来初始化p2\n    \n    pair<int,double> p3(1,1.2); \n\n    pair<int,int> p4 ;  //没有写初始化值，自动初始化为(0,0)\n\n注：每个pair可以存储两个值，这两个值可以是不同的数据类型，存储的值可以是基本数据类型，也可以是自己定义的数据类型\n```\n\n>## 可变数组 Vectory\n```cpp\n   vector <int> arr; \n\tarr.resize(10); // 给该数组分配十个空间\n\tarr[0] = 1;\n\tarr.push_back(20); // 将20放到数组的最后\n\tvector <int> arr2 (10,3); // 给开辟10个空间，给每个空间都初始化为3\n\t// 使用arr[0]=1,这样的方式赋值的时候，一定是已经给数组分配过空间了的，否则编译失败\n\t// 但是使用pushback的话，可以先不分配空间\n\n\t// 迭代器自动遍历整个数组\n\t// arr.end()的位置是在数组的最后一个元素的下一个位置\n\tfor (auto p = arr2.begin(); p != arr2.end(); p++) {\n\t\tcout << *p << \" \";\n\t\tcout << *p << endl;\n\t}\n\n```\n\n>## set集合 ： 存储不含重复元素的集合\n```cpp\n\n    set<int> sarr; \n\tsarr.insert(1); // 给集合添加元素 1\n\tsarr.insert(2); // 给集合添加元素 2\n\tsarr.insert(3); // 给集合添加元素 3\n\n\tsarr.find(3); // 返回值是指针，在集合中寻找有没有3\n\n\tif (sarr.find(1)==sarr.end()) { // 指针指向最后一个元素的下一个位置\n\t\t// 查找失败，集合中没有\n\t\tcout << \"集合中没有这个元素\" << endl ;\n\t}\n\telse {\n\t\t// 找到了\n\t\tcout << *sarr.find(1) << endl;\n\t}\n\tsarr.erase(2);// 从集合中删除 2 这个元素\n\n```\n\n>## map集合 ： 存储键值对的集合\n```cpp\n    map<string,int> mymap;\n\t//添加元素\n\tmymap[\"xt\"] = 3; \n\tmymap[\"zl\"] = 4;\n\tmymap.insert({ \"xxx\",4 });\n\tfor (auto p = mymap.begin(); p != mymap.end(); p++) {\n\t\t// first 表示的是键，second 表示的是值\n\t\t// p代指map集合中的一个元素，实际上是个指针，指向结构体\n\t\tcout << p->first << \" : \" << p->second << endl;\n\t}\n\n```\n\n>## 栈 stack ：先入后出\n```cpp\n    stack<int> sta;\n\tsta.push(1);\n\tsta.push(2);\n\n\t// 打印栈顶元素\n\tcout << sta.top() << endl;\n\tsta.pop(); // 出栈且无返回值\n\tsta.size(); // 获取栈的长度\n```\n>## 队列：先入后出\n```cpp\n    queue<int>qu;\n\t// 入队\n\tqu.push(1);\n\tqu.push(2);\n\tqu.push(3);\n\t// 出队\n\tqu.pop();\n\t// 获取队首\n\tqu.front();\n\t// 获取队尾\n\tqu.back();\n\t// 长度\n\tqu.size();\n    // 入队            \n    pos.emplace(x);\n```\n>## bitset数组\n```cpp\n定义：类似一个字符数组，直接输出的话，是一个二进制数，如果按照数组输出的话，和直接输出相反\n\nbitset<5> b;\t\t // 表示5个二进制位，初始化为0 ： 00000\n\tbitset<5> b(3);\t    // 1是无符号数，输出b为 ：00011 , 此时括号里的数就是二进制数所表示的十进制数\n\tbitset<5> b(\"111\"); //111是字符串，表示在b的低3位是1 : 00111\n\tstring s; int pos, n;\n\tbitset<5>b(s, pos, n);// 类似于上面那个，但是这个是截取部分s然后作为参数，从下标为pos开始，读取n个字符\n    \n    // 下面的是返回为bool类型的函数 ： \n\tb.any(); // 是否有 1\n\tb.none(); //是否不存在1\n\tb.count();//1的个数\n\tb.size();//b中的元素个数\n\tb.test(3);//下标为3的元素是不是 1 \n    \n    // 操作函数\n\tb.flip(); // 所有位取反\n\tb.flip(i); // 第i为取反\n\tb.reset(); // 所有位归零\n\tb.reset(i);// 第i位归零\n\t\n\tunsigned long long1=b.to_ulong();// 转换成unsignedlong的类型\n```\n\n>## sort排序\n```cpp\n    vector<int> arr3(10); // 先分配十个空间\n\n\t// 默认为升序\n\tsort(arr3.begin(), arr3.end()); // 从begin到end这部分进行排序，左开右闭[ )，因为end所在的位置是没有数据的\n\t\n\tvector<int> arr4(10);\n\tsort(arr4.begin(), arr4.end(), cmp); // begin的是x，end的是y\n\n// cmp自定义排序\n// 返回1就顺序不变，如果返回0就会自动交换位置，实际上就是利用了快速排序的原理\n    bool cmp(int x, int y) { \n\t    return x > y; //降序\n    }\n\n// swap交换\n    swap(a[1],a[2]); // 表示把a数组中的下标为1和2的元素位置进行交换\n\n```\n","categories":["Cpp"],"tags":["grammer","cpp"]},{"title":"Markdown 教程","url":"/posts/33206/","content":"\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n> Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\n> Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\n> Markdown 编写的文档后缀为 `.md`, `.markdown`。\n\n<!-- more -->\n末尾连续两次空格是换行\n\n# 标题\n👆 看起来就像上面这个。Markdown 标题有两种格式。\n\n## 使用 `=` 和 `-` 标记一级和二级标题\n`=` 和 `-` 标记语法格式如下：\n```markdown\n我展示的是一级标题\n=================\n\n我展示的是二级标题\n-----------------\n```\n\n## 使用 `#` 号标记\n使用 `#` 号可表示 1-6 级标题，一级标题对应一个 `#` 号，二级标题对应两个 `#` 号，以此类推。\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n# 段落样式\nMarkdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。\n当然也可以在段落后面使用一个空行来表示重新开始一个段落。\n\n## 字体\nMarkdown 可以使用以下几种字体：\n> *斜体文本*\n> **粗体文本**\n> ***粗斜体文本***\n```markdown\n*斜体文本*\n_斜体文本_\n\n**粗体文本**\n__粗体文本__\n\n***粗斜体文本***\n___粗斜体文本___\n```\n\n## 分隔线\n可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。\n也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n> - - -\n> 我\n> - - -\n> 裂\n> - - -\n> 开\n> - - -\n> 了\n>\n> - - -\n```markdown\n***\n* * *\n*****\n- - -\n----------\n```\n\n## 删除线\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 `~~` 即可，实例如下：\n> RUNOOB.COM\n> GOOGLE.COM\n> ~~BAIDU.COM~~\n```markdown\nRUNOOB.COM\nGOOGLE.COM\n~~BAIDU.COM~~\n```\n\n## 下划线\n下划线可以通过 HTML 的 `<u>` 标签来实现：\n> <u>带下划线文本</u>\n```html\n<u>带下划线文本</u>\n```\n\n## 脚注\n脚注是对文本的补充说明。Markdown 脚注的格式如下:\n```markdown\n[^要注明的文本]\n```\n以下实例演示了脚注的用法：\n> 阿米娅[^阿米娅]\n```markdown\n创建脚注格式类似这样 [^阿米娅]\n[^阿米娅]: 博士，您还有很多事情需要处理。现在还不能休息哦。\n```\n\n# Markdown 列表\nMarkdown 支持有序列表和无序列表。\n无序列表使用星号(`*`)、加号(`+`)或是减号(`-`)作为列表标记：\n> * 第一项\n> * 第二项\n> * 第三项\n```markdown\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n```\n有序列表使用数字并加上 `.` 号来表示，如：\n> 1. 第一项\n> 2. 第二项\n> 3. 第三项\n```markdown\n1. 第一项\n2. 第二项\n3. 第三项\n```\n\n## 列表嵌套\n列表嵌套只需在子列表中的选项添加四个空格即可：\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n\n\n```markdown\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n```\n\n# Markdown 区块\nMarkdown 区块引用是在段落开头使用 `>` 符号 ，然后后面紧跟一个空格符号：\n> 这是一个区块\n```markdown\n> 这是一个区块\n```\n另外区块是可以嵌套的，一个 `>` 符号是最外层，两个 `>` 符号是第一层嵌套，以此类推：\n> 最外层\n> > 第一层嵌套\n> >\n> > > 第二层嵌套\n```markdown\n> 最外层\n> > 第一层嵌套\n> > > 第二层嵌套\n```\n\n## 区块中使用列表\n区块中使用列表实例如下：\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n```markdown\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n```\n\n## 列表中使用区块\n如果要在列表项目内放进区块，那么就需要在 `>` 前添加四个空格的缩进。\n区块中使用列表实例如下：\n* 第一项\n  > 菜鸟教程\n  > 学的不仅是技术更是梦想\n* 第二项\n```markdown\n* 第一项\n    > 菜鸟教程\n    > 学的不仅是技术更是梦想\n* 第二项\n```\n\n# Markdown 代码\n如果是段落上的一个函数或片段的代码可以用反引号把它包起来（\\`），例如：\n`printf()` 函数\n```markdown\n`printf()` 函数\n```\n## 代码区块\n代码区块使用 4 个空格或者一个制表符（Tab 键）。\n也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：\n实例如下：\n```javascript\n$(document).ready(function () {\n    alert('RUNOOB');\n});\n```\n\n# Markdown 链接\n链接使用方法如下：\n> [链接名称](#链接地址)\n> 或者直接使用链接地址\n> <https://github.com/Yue-plus>\n```markdown\n[链接名称](链接地址)\n<https://github.com/Yue-plus>\n```\n\n## 高级链接\n可以通过变量来设置一个链接，变量赋值在文档末尾进行：\n> 这个链接用 `1` 作为网址变量 [Google][1]\n> 这个链接用 `mysite` 作为网址变量 [Yue_plus][mysite]\n```markdown\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 mysite 作为网址变量 [Yue_plus][mysite]\n然后在文档的结尾为变量赋值（网址）\n\n  [1]: http://www.google.com/\n  [mysite]: https://github.com/Yue-plus\n```\n\n# Markdown 图片\nMarkdown 图片语法格式如下：\n```markdown\n![alt 属性文本](图片地址)\n![alt 属性文本](图片地址 \"可选标题\")\n```\n开头一个感叹号 !\n接着一个方括号，里面放上图片的替代文字\n接着一个英文括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 'title' 属性的文字。\n> ![罗德岛集结](https://ak.hypergryph.com/upload/images/20190228/118078295785f64dac736c6ade50bb76.jpg \"罗德岛集结\")\n```markdown\n![罗德岛集结](https://ak.hypergryph.com/upload/images/20190228/118078295785f64dac736c6ade50bb76.jpg \"罗德岛集结\")\n```\n当然，你也可以像网址那样对图片网址使用变量:\n```markdown\n这个链接用 `2` 作为网址变量 [凯尔希][2].\n然后在文档的结尾为变量赋值（网址）\n\n[2]: https://ak.hypergryph.com/upload/images/20190228/143666074a406ecaa6cd4271dc7c5127.jpg\n```\nMarkdown 还没有办法指定图片的高度与宽度，如果需要的话，也可以使用普通的 `<img>` 标签。\n> <img src=\"https://ak.hypergryph.com/assets/index/images/ak/common/story/item_infected.png\" width=\"200px\">\n```html\n<img src=\"https://ak.hypergryph.com/assets/index/images/ak/common/story/item_infected.png\" width=\"200px\">\n```\n\n# Markdown 表格\nMarkdown 制作表格使用 `|` 来分隔不同的单元格，使用 `-` 来分隔表头和其他行。\n语法格式如下：\n\n| 表头   | 表头   |\n| ------ | ------ |\n| 单元格 | 单元格 |\n| 单元格 | 单元格 |\n\n```markdown\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n```\n\n可以设置表格的对齐方式：\n\n`-:` 设置内容和标题栏居右对齐。\n`:-` 设置内容和标题栏居左对齐。\n`:-:` 设置内容和标题栏居中对齐。\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n# Markdown 高级技巧\n##支持的 HTML 元素\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n目前支持的 HTML 元素有：`<kbd>` `<b>` `<i>` `<em>` `<sup>` `<sub>` `<br>`等，如：\n> 使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n```markdown\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n```\n\n## 转义\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\n> \\*\\* 正常显示星号 \\*\\*\n```markdown\n**文本加粗** \n\\*\\* 正常显示星号 \\*\\*\n```\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n```markdown\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n```\n\n## 数学公式\n当需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n\n> 参考 [使用 `hexo-filter-mathjax` 过滤器来显示数学公式](https://github.com/Yue-plus/hexo-theme-arknights#数学公式)\n\n> 可以在行内包含数学公式： $i\\hbar\\frac{\\partial}{\\partial t}\\psi=-\\frac{\\hbar^2}{2m}\\nabla^2\\psi+V\\psi$ 注意单 `$` 内部不能有空格！\n> $$\n> \\begin{eqnarray\\*}\n> \\nabla\\cdot\\vec{E}&=&\\frac{\\rho}{\\epsilon_0}\\\\\\\\\n> \\nabla\\cdot\\vec{B}&=&0\\\\\\\\\n> \\nabla\\times\\vec{E}&=&-\\frac{\\partial B}{\\partial t}\\\\\\\\\n> \\nabla\\times\\vec{B}&=&\\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t}\\right)\\\\\\\\\n> \\end{eqnarray\\*}\n> $$\n\n```markdown\n可以在行内包含数学公式： $i\\hbar\\frac{\\partial}{\\partial t}\\psi=-\\frac{\\hbar^2}{2m}\\nabla^2\\psi+V\\psi$ 注意单 `$` 内部不能有空格！\n$$\n\\begin{eqnarray\\*}\n\\nabla\\cdot\\vec{E}&=&\\frac{\\rho}{\\epsilon_0}\\\\\\\\\n\\nabla\\cdot\\vec{B}&=&0\\\\\\\\\n\\nabla\\times\\vec{E}&=&-\\frac{\\partial B}{\\partial t}\\\\\\\\\n\\nabla\\times\\vec{B}&=&\\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t}\\right)\\\\\\\\\n\\end{eqnarray\\*}\n$$\n```\n\n[^阿米娅]: 博士，您还有很多事情需要处理。现在还不能休息哦。\n\n[1]: http://www.google.com/\n[mysite]: https://github.com/Yue-plus","categories":[],"tags":["Markdown"]}]