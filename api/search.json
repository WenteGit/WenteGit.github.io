[{"title":"TechStack-Hikari","url":"/posts/36787/","content":"> 总结了关于Hikari数据库连接池的相关信息与内容\n<!-- more -->\n# 引入依赖\n```xml\n        <dependency>\n            <groupId>com.zaxxer</groupId>\n            <artifactId>HikariCP</artifactId>\n        </dependency>\n```\n\n# dataSource\n```yml\n  datasource:\n    type: com.zaxxer.hikari.HikariDataSource\n```\n# 基本配置及其解释\n```yml\nhikari:\n    # 控制HikariCP尝试在池中维护的最小空闲连接数\n    minimum-idle: 5\n    # 控制允许连接在池中保持空闲状态的最长时间,这里是10min\n    idle-timeout: 600000\n    # 控制允许池达到的最大大小,同时最多允许十个连接\n    maximum-pool-size: 10\n    # 自动提交行为\n    auto-commit: true\n    # 表示连接池的用户定义名称\n    pool-name: MyHikariCP\n    # 控制池中连接的最大生存期\n    max-lifetime: 1800000\n    # 控制客户端等待来自池的连接的最大毫秒数\n    connection-timeout: 30000\n    # 测试数据库连接的语句\n    connection-test-query: SELECT 1\n```\n\n# 配置详解\n## autoCommit\n        此属性控制从池返回的连接的默认自动提交行为。它是一个布尔值。 默认值：true\n\n## connectionTimeout\n        此属性控制客户端（即您）等待来自池的连接的最大毫秒数。如果超过此时间而没有可用的连接，则会抛出SQLException。可接受的最低连接超时为250 ms。 默认值：30000（30秒）\n\n## idleTimeout\n        此属性控制允许连接在池中保持空闲状态的最长时间。 仅当minimumIdle定义为小于maximumPoolSize时，此设置才适用。连接池达到连接后， 空闲连接将不会退出minimumIdle。连接是否以空闲状态退役，最大变化为+30秒，平均变化为+15秒。在此超时之前，连接永远不会因为闲置而退役。值必须比maxLifetime小。值为0表示永远不会从池中删除空闲连接。最小允许值为10000ms（10秒）。 默认值：600000（10分钟）\n\n## maxLifetime\n        此属性控制池中连接的最大生存期。使用中的连接永远不会停止使用，只有在关闭连接后才将其删除。在逐个连接的基础上，应用较小的负衰减以避免池中的质量消灭。 我们强烈建议设置此值，它应该比任何数据库或基础结构施加的连接时间限制短几秒钟。 值0表示没有最大寿命（无限寿命），当然要遵守该idleTimeout设置。最小允许值为30000ms（30秒）。 默认值：1800000（30分钟）\n\n## connectionTestQuery\n        如果您的驱动程序支持JDBC4，我们强烈建议不要设置此属性。这是针对不支持JDBC4的“旧版”驱动程序的Connection.isValid() API。这是将在从池中为您提供连接之前执行的查询，以验证与数据库的连接仍然有效。同样，尝试运行不带该属性的池，如果驱动程序不兼容JDBC4，HikariCP将记录错误。 默认值：无\n\n## minimumIdle\n        此属性控制HikariCP尝试在池中维护的最小空闲连接数。如果空闲连接下降到该值以下，并且池中的总连接数少于maximumPoolSize，则HikariCP将尽最大努力快速而有效地添加其他连接。但是，为了获得最佳性能和对峰值需求的响应能力，我们建议不要设置此值，而应让HikariCP充当固定大小的连接池。 默认值：与maximumPoolSize相同\n\n## maximumPoolSize\n        此属性控制允许池达到的最大大小，包括空闲和使用中的连接。基本上，此值将确定到数据库后端的最大实际连接数。合理的值最好由您的执行环境确定。当池达到此大小并且没有空闲连接可用时，对getConnection（）的调用将connectionTimeout在超时之前最多阻塞毫秒。请阅读有关池大小的信息。 默认值：10\n\n## metricRegistry\n        此属性仅可通过编程配置或IoC容器使用。此属性允许您指定池将用于记录各种指标的Codahale / Dropwizard 的实例MetricRegistry。有关 详细信息，请参见Metrics Wiki页面。 默认值：无\n\n## healthCheckRegistry\n        此属性仅可通过编程配置或IoC容器使用。此属性允许您指定池将用于报告当前健康信息的Codahale / Dropwizard 的实例HealthCheckRegistry。有关 详细信息，请参见运行状况检查 Wiki页面。 默认值：无\n\n## poolName\n        该属性表示连接池的用户定义名称，主要出现在日志记录和JMX管理控制台中，以识别池和池配置。 默认值：自动生成","categories":["TechStack"],"tags":["Hikari"]},{"title":"official_document","url":"/posts/9625/","content":"> 介绍了关于技术栈中的相关技术的官方文档链接\n<!--more-->\n# SpringBoot\n```html\n<a> https://spring.io/projects/spring-boot#learn </a>\n```\n# SpringSecurity\n```html\n<a>https://spring.io/projects/spring-security</a>\n```\n# SpringCloud\n```html\n<a>https://spring.io/projects/spring-cloud</a>\n```\n# SpringData\n```html\n<a>https://spring.io/projects/spring-data</a>\n```\n\n","categories":["document"],"tags":["document"]},{"title":"JavaJDBC","url":"/posts/19301/","content":">总结了关于SpringJDBC 连接SqlServer和Mysql\n<!--more-->\n\n# 连接SqlServer\n> 仅仅支持 JDK8,11,17,18\n## 导入依赖\n```xml\n  <dependencies>\n<!--  junit版本至少在4.12及其以上-->\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.12</version>\n      <scope>test</scope>\n    </dependency>\n<!--    引入Spring-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n      <version>5.3.18</version>\n    </dependency>\n<!--    使用xml配置来设置JDBC的参数-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-jdbc</artifactId>\n      <version>5.3.18</version>\n    </dependency>\n<!--  模拟Spring环境的测试jar包-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-test</artifactId>\n      <version>5.2.5.RELEASE</version>\n    </dependency>\n<!-- SQLServer的连接jar包-->\n    <dependency>\n      <groupId>com.microsoft.sqlserver</groupId>\n      <artifactId>mssql-jdbc</artifactId>\n      <version>7.4.1.jre8</version>\n    </dependency>\n<!--  使用C3P0连接池-->\n    <dependency>\n      <groupId>c3p0</groupId>\n      <artifactId>c3p0</artifactId>\n      <version>0.9.1.2</version>\n    </dependency>\n  </dependencies>\n```\n## 配置applicationContext.xml\n```xml\n<!--    1，配置数据源-->\n    <bean id=\"datasource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n<!--        驱动类名，照着写-->\n        <property name=\"driverClass\" value=\"com.microsoft.sqlserver.jdbc.SQLServerDriver\"/>\n<!--        URL地址，根据自己的URL来，端口都是3306,主要可能就改个数据库名-->\n        <property name=\"jdbcUrl\" value=\"jdbc:sqlserver://localhost:1433;DatabaseName=trding\"/>\n<!--        登录sqlserver数据库的用户名和密码-->\n        <property name=\"user\" value=\"sa\"/>\n        <property name=\"password\" value=\"rootxtzl\"/>\n    </bean>\n\n\n<!--    2，配置JDBC模板-->\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n<!--        将我们自己的数据源配置进这个JDBC模板-->\n        <property name=\"dataSource\" ref=\"datasource\"/>\n    </bean>\n\n\n\n<!--    3,注入JDBC到具体的Dao类-->\n    <bean id=\"userDao\" class=\"second.hand.transactions.dao.userDao\">\n<!--        将自己配置的jdbcTempla注入进具体的Dao类-->\n        <property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"/>\n    </bean>\n```\n\n\n# 连接MySQL\n\n## 引入依赖\n```xml\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.12</version>\n      <scope>test</scope>\n    </dependency>\n<!--    引入Spring-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n      <version>5.3.18</version>\n    </dependency>\n<!--    使用xml配置来设置JDBC的参数-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-jdbc</artifactId>\n      <version>5.3.18</version>\n    </dependency>\n<!--  模拟Spring环境的测试jar包-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-test</artifactId>\n      <version>5.2.5.RELEASE</version>\n    </dependency>\n\n<!--    使用 MySQL 8.X 的连接包-->\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>8.0.21</version>\n    </dependency>\n\n<!--    MySQL5.X 的驱动包-->\n<!--    <dependency>-->\n<!--      <groupId>mysql</groupId>-->\n<!--      <artifactId>mysql-connector-java</artifactId>-->\n<!--      <version>5.1.49</version>-->\n<!--    </dependency>-->\n\n    <!--  使用C3P0连接池-->\n    <dependency>\n      <groupId>c3p0</groupId>\n      <artifactId>c3p0</artifactId>\n      <version>0.9.1.2</version>\n    </dependency>\n  </dependencies>\n\n```\n\n## 配置数据源等实例(application.xml)\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n<!--    1，配置数据源-->\n    <bean id=\"datasource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n<!--        驱动类名，照着写-->\n        <property name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"/>\n<!--        URL地址，根据自己的URL来，端口都是3306,主要可能就改个数据库名-->\n        <property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/triding?serverTimezone=UTC\"/>\n<!--        登录sqlserver数据库的用户名和密码-->\n        <property name=\"user\" value=\"root\"/>\n        <property name=\"password\" value=\"root\"/>\n    </bean>\n\n\n<!--    2，配置JDBC模板-->\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n<!--        将我们自己的数据源配置进这个JDBC模板-->\n        <property name=\"dataSource\" ref=\"datasource\"/>\n    </bean>\n\n\n<!--    3,注入JDBC到具体的Dao类-->\n    <bean id=\"userDao\" class=\"second.hand.transactions.dao.userDao\">\n<!--        将自己配置的jdbcTempla注入进具体的Dao类-->\n        <property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"/>\n    </bean>\n</beans>\n```\n\n\n# 实体类User\n```java\npackage second.hand.transactions.entities;\n\nimport java.io.Serializable;\n\n/**\n * @author Wente\n * @date 2022/11/30\n * 普通用户类\n **/\npublic class User implements Serializable {\n    private Long userId;\n    private Long carId;\n    private String userName;\n    private String userPwd;\n    private String userNickname;\n    private String userBirth;\n    private String userPsig;\n    private String userQq;\n    private String userTele;\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"userId=\" + userId +\n                \", carId=\" + carId +\n                \", userName='\" + userName + '\\'' +\n                \", userPwd='\" + userPwd + '\\'' +\n                \", userNickname='\" + userNickname + '\\'' +\n                \", userBirth='\" + userBirth + '\\'' +\n                \", userPsig='\" + userPsig + '\\'' +\n                \", userQq='\" + userQq + '\\'' +\n                \", userTele='\" + userTele + '\\'' +\n                '}';\n    }\n\n    public Long getUserId() {\n        return userId;\n    }\n\n    public void setUserId(Long userId) {\n        this.userId = userId;\n    }\n\n    public Long getCarId() {\n        return carId;\n    }\n\n    public void setCarId(Long carId) {\n        this.carId = carId;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public String getUserPwd() {\n        return userPwd;\n    }\n\n    public void setUserPwd(String userPwd) {\n        this.userPwd = userPwd;\n    }\n\n    public String getUserNickname() {\n        return userNickname;\n    }\n\n    public void setUserNickname(String userNickname) {\n        this.userNickname = userNickname;\n    }\n\n    public String getUserBirth() {\n        return userBirth;\n    }\n\n    public void setUserBirth(String userBirth) {\n        this.userBirth = userBirth;\n    }\n\n    public String getUserPsig() {\n        return userPsig;\n    }\n\n    public void setUserPsig(String userPsig) {\n        this.userPsig = userPsig;\n    }\n\n    public String getUserQq() {\n        return userQq;\n    }\n\n    public void setUserQq(String userQq) {\n        this.userQq = userQq;\n    }\n\n    public String getUserTele() {\n        return userTele;\n    }\n\n    public void setUserTele(String userTele) {\n        this.userTele = userTele;\n    }\n}\n```\n\n# userDao(与数据库交互用的模板类)\n```java\npublic class userDao {\n\n    private JdbcTemplate jdbcTemplate;\n\n    public JdbcTemplate getJdbcTemplate() {\n        return jdbcTemplate;\n    }\n\n    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    /**\n     * 向数据库中添加数据\n     */\n    public void addUserCommon(){\n        String sql = \"insert into user_common(user_id,user_name,user_pwd,user_nickname,user_birth,user_psig,user_qq,user_tele)values(42000,'wente','wenteroot','文特','2001/12/05','个性签名','393815277','18423225933')\";\n        // 返回updateResult表示受影响的行数\n        int updateResult = jdbcTemplate.update(sql);\n        System.out.println(updateResult);\n    }\n}\n```\n# 测试类\n```java\n//注解是用来配置Spring的测试环境\n@ContextConfiguration(\"classpath:applicationContext.xml\")\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class TestUser {\n    @Test\n    public void test1(){\n        // 获取userDao的实例\n        ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        userDao userDao = (userDao) ctx.getBean(\"userDao\");\n        // 执行添加用户方法,该方法是我们自定义的\n        userDao.addUserCommon();\n    }\n}\n```","categories":["JavaStudy"],"tags":["SpringJDBC"]},{"title":"ssm_beanXml","url":"/posts/12964/","content":"> 总结了在SSM中对bean的配置\n<!--more-->\n# 属性是存储类对象\n```xml\n        <bean id=\"userDao\" class=\"User.UserDaoimpl\">\n            <!-- 属性是List类型 -->\n            <property name=\"strList\">\n                <list>\n                    <value>aaa</value>\n                    <value>bbb</value>\n                    <value>ccc</value>\n                </list>\n            </property>\n\n            <!-- 属性是Map类型 -->\n        <property name=\"userMap\">\n            <map>\n                <entry key=\"u1\" value-ref=\"user1\"></entry>\n                <entry key=\"u2\" value-ref=\"user2\"></entry>\n            </map>\n        </property>\n\n             <!-- 属性是Properties类型 -->\n        <property name=\"properties\">\n            <props>\n                <prop key=\"p1\">ppp1</prop>\n                <prop key=\"p2\">ppp2</prop>\n                <prop key=\"p3\">ppp3</prop>\n            </props>\n        </property>\n        </bean>\n```\n\n# 实体类属性注入\n```xml\n    <bean id=\"user1\" class=\"User.User\">\n        <property name=\"name\" value=\"tom\"/>\n        <property name=\"age\" value=\"beijing\"/>\n    </bean>\n\n```\n\n# 对象的构造方法的参数注入\n```xml\n    <!-- 将已有的id为userDao的bean注入到构造方法中参数为userDao的对象中 -->\n    <bean id=\"userService\" class=\"Service.UserServiceimpl\">\n        <constructor-arg name=\"userDao\" ref=\"userDao\"></constructor-arg>\n    </bean>\n```\n# 导入其他XML文件\n```xml\n<import resource=\"applicationContext-user.xml\"/>\n```\n","categories":["SSM"],"tags":["beanXml"]},{"title":"boot-Themleaf","url":"/posts/3251/","content":"> 总结了关于模板引擎themleaf的相关知识\n<!--more-->\n# 引入名称空间\n```txt\n<html xmlns:th=\"http://www.thymeleaf.org\">    \n```\n# 属性介绍\n* th:text：设置当前元素的文本内容，相同功能的还有th:utext，两者的区别在于前者不会转义html标签，后者会。优先级不高：order=7\n\n* th:value：设置当前元素的value值，类似修改指定属性的还有th:src，th:href。优先级不高：order=6\n\n* th:each：遍历循环元素，和th:text或th:value一起使用。注意该属性修饰的标签位置，详细往后看。优先级很高：order=2\n\n* th:if：条件判断，类似的还有th:unless，th:switch，th:case。优先级较高：order=3\n\n* th:insert：代码块引入，类似的还有th:replace，th:include，三者的区别较大，若使用不恰当会破坏html结构，常用于公共代码块提取的场景。优先级最高：order=1\n\n* th:fragment：定义代码块，方便被th:insert引用。优先级最低：order=8\n\n* th:object：声明变量，一般和*{}一起配合使用，达到偷懒的效果。优先级一般：order=4\n\n* th:attr：修改任意属性，实际开发中用的较少，因为有丰富的其他th属性帮忙，类似的还有th:attrappend，th:attrprepend。优先级一般：order=5\n# 表达式 \n* ${...}    变量表达式\n* *{...}    选择变量表达式\n* #{...}    消息表达式\n* @{...}    连接网址表达式\n* ~{...}    片段表达式\n* [[...]]   内联表达式(转义后输出)\n* [(...)]   内联表达式(直接输出原文)\n\n\n","categories":["SpringBoot"],"tags":["themleaf"]},{"title":"boot_yml","url":"/posts/54094/","content":">总结了关于yml配置的格式\n<!--more-->\n```yml\n\nperson:\n#  单引号会将转义字符作为字符串输出，双引号不会改变转义字符原先的意思，这里也就是换行符，执行换行操作\n  username: 'zhangsan \\n'\n  birth: 2001/12/05\n  age: 20\n  boos: true\n#  interests: [篮球，足球]\n  interests:\n    - 篮球\n    - 足球\n    - 18\n  animal: [阿猫，阿狗]\n#  score: {english: 80,math: 90}\n  score:\n    - english: 80\n    - math: 90\n\n#一个-代表集合的一个元素，注意-后面要加一个空格\n  allPets:\n    - sick:\n      - {name: 阿猫,weight: 20.0}\n      - {name: 阿狗,weight: 30.5}\n      - name: 小猫\n        weight: 35.0\n    - health:\n      - {name: 智力,weight: 50}\n      - {name: 力,weight: 15}\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/wedo\n    username: root\n    password: root\n    driver-class-name: com.mysql.jdbc.Driver\n  jdbc:\n    template:\n#      查询超时属性:ms是单位\n      query-timeout: 3000\n  redis:\n    url: redis://xtzl:Ljw060119@r-bp1a7csap888l0glj2pd.redis.rds.aliyuncs.com:6379\n    jedis:\n      pool:\n        max-active: 10\n        min-idle: 5\n\n#    lettuce:\n#      pool:\n#        最大活动数\n#        max-active: 10\n#          最小空闲数\n#        min-idle: 5\n\n\n\n#      配置mybatis的规则\nmybatis:\n#  config-location: classpath:mybatis/Mybatis-config.xml\n  mapper-locations: classpath:mapper/*.xml\n  configuration:\n#    开启驼峰配置，解决数据库的命名规则和服务器的\n    map-underscore-to-camel-case: true\nserver:\n  port: 8001\n\n```\n","categories":["SpringBoot"],"tags":["yml"]},{"title":"TechStack_ElasticSearch","url":"/posts/29919/","content":"> 总结了关于ElasticSearch的相关知识\n<!--more--> \n# 信息查看\n<img src = \"http://xtzl.wentexl.cn/ElasticSearch/%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B.png\">\n\n# 请求体参数\n```json\n{\n    // 多条件查询\n    \"query\":{\n        // 条件\n        \"bool\":{\n            // must是与操作，should是或操作\n             \"must\":[\n                // 种类为小米文档数据\n                {\n                    // match的底层采用倒排索引\n                    // match_phrase会采用完全匹配\n                    \"match\":{\n                    \"category\":\"小米\"\n                        }\n                },\n                // 价格为3999的数据\n                {\n                    \"match\":{\n                        \"price\" : \"3999\"\n                    }\n                }\n            ]   \n            ,\n            \"filter\" :{\n                // 指定范围\n                \"range\":{\n                    // 指定字段\n                    \"price\" :{\n                            // 大于5000\n                        \"gt\" : \"5000\"\n                    }\n                }\n            }\n        }\n    },\n    // 数组起始位置\n    \"from\" : 1,\n    // 查询的条数\n    \"size\" : 2,\n    // 选择字段 : 只查title\n    \"_source\" : [\"title\"],\n    // 排序\n    \"sort\" :{\n            //根据price字段进行排序 \n        \"price\" : {\n            // 降序排序\n            \"order\" : \"desc\"\n        }\n    },\n    // 对查询出的结果进行高亮显示\n    \"highlight\":{\n        // 指定范围\n        \"fields\":{\n            \"category\":\"小米\"\n        }\n    },\n    // 聚合操作\n    \"aggs\" : {\n        // 随意起一个组名\n        \"price_group\" : {\n            // 分组查询\n            \"terms\":{\n                // 按字段分组\n                \"field\" : \"price\"\n            },\n            // 求平均值\n            \"avg\":{\n                // 求price的平均值\n                \"field\" : \"price\"\n            }\n        }\n    },\n    // 不看原始数据\n    \"size\" : 0,\n\n    // 映射关系\n    \"properties\":{\n        // 支持自动倒排索引查询\n        \"name\":{\n            \"type\" : \"text\",\n            \"index\" : true\n        },\n        // 不支持倒排索引查询\n        \"sex\" :{\n            \"type\" : \"keyword\",\n            \"index\" : true\n        },\n        \"tel\":{\n            \"type\" : \"keyword\",\n            \"index\" : false\n        }\n    }\n}\n```\n\n# 通过Kibana来设置ES\n```json\nPUT novel_engine\n{\n    //设置title字段为completion类型，好让Suggetsion可以使用\n  \"mappings\":{\n      \"properties\": {\n        \"title\": {\n          \"type\": \"completion\",\n          \"analyzer\": \"ik_max_word\"\n        }\n      }\n  },\n  // 设置默认分词器为ik分词器\n  \"settings\": {\n      \"analysis\": {\n        \"analyzer\": {\n          \"default\":{\n            \"type\":\"ik_max_word\"\n          }\n        }\n      }\n    }\n}\n```","categories":["TechStack"],"tags":["ElasticSearch"]},{"title":"algorithm","url":"/posts/54840/","content":">总结了关于算法的一些函数\n<!--more-->\n# Functions\n## 长整数加法器 (Java)\n```java\n    // 长整数加法器\n    private static String addLongInteger(String str, int num){\n            int ci = 0;\n        StringBuffer sb = new StringBuffer();\n        for(int i = str.length() -1 ; i>=0 ;i--){\n            // 数字的ASCALL与真值相差48\n            int tempnum = (str.charAt(i) - 48) + ci +num;\n            ci = 0;\n            num = 0;\n            if (tempnum >= 10){\n                ci = tempnum/10;\n                tempnum = tempnum %10;\n            }\n            sb.append(String.valueOf(tempnum));\n        }\n    return sb.reverse().toString();\n    }\n```\n","categories":["algorithm"],"tags":["algorithm"]},{"title":"sql-DCL","url":"/posts/37793/","content":"> 描述了关于sql对数据的控制语言\n<!--more-->\n\n# 导入外部文件到表中的命令\n```sql\n-- sqlserver\n-- 列的分隔符为|，行的分隔符为\\n\nbulk insert tea_stu_msg from 'D:\\AAA\\txt\\teastuID.txt' \nwith(fieldterminator='|',rowterminator='\\n')\n\n-- mysql\n-- 批量导入：将csv文件直接导入到数据库中\n    LOAD DATA INFILE \"D:\\stu.csv\"\n    INTO TABLE stu_code CHARACTER SET utf8\n    LINES TERMINATED BY \"\\n\";\n\n```","categories":["SQLS"],"tags":["sqls"]},{"title":"importantFunctions","url":"/posts/30183/","content":">对一些值得积累的函数进行了积累\n<!--more-->\n# 长整数加法器 Java\n```java\n    // 长整数加法器\n    private static String addLongInteger(String str, int num){\n            int ci = 0;\n        StringBuffer sb = new StringBuffer();\n        for(int i = str.length() -1 ; i>=0 ;i--){\n            int tempnum = (str.charAt(i) - 48) + ci +num;\n            ci = 0;\n            num = 0;\n            if (tempnum >= 10){\n                tempnum = tempnum %10;\n                ci ++;\n            }\n            sb.append(String.valueOf(tempnum));\n        }\n    return sb.reverse().toString();\n    }\n```\n","categories":["Functions"],"tags":["Functions"]},{"title":"JavaIO","url":"/posts/20622/","content":"> 总结了关于JavaIO的知识点\n<!--more-->\n\n# Java Input\n```java\n    String inputpath=\"D:\\\\AAA\\\\txt\\\\code.txt\";\n    File file = new File(inputpath);\n    FileReader fileReader = new FileReader(file);\n    // 使用BufferReader读取\n    BufferedReader bufferedReader = new BufferedReader(fileReader);\n    String line = null;\n    // 按行读取\n    while ((line = bufferedReader.readLine()) !=null){\n        System.out.println(line);\n    }\n    // 读取第一个字符，并且返回其Ascall码值\n    int read = bufferedReader.read(); \n```\n\n# Java Output\n```java\n    public static void main(String[] args) throws IOException {\n        String hello = \"time23\";\n        String outputStreamFilePath=\"D:\\\\AAA\\\\txt\\\\demo.txt\";\n        File file=new File(outputStreamFilePath);\n\n        FileWriter fileWriter = new FileWriter(outputStreamFilePath, true);\n        fileWriter.write(hello);\n        fileWriter.close();\n        //以FileWriter作为参数，不换行写入\n        BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\n        bufferedWriter.write(hello);\n        //以FilterWriter为参数，换行与不换行写入\n        PrintWriter printWriter = new PrintWriter(fileWriter);\n        printWriter.println(hello);\n        printWriter.print(hello);\n        printWriter.close();\n    }\n\n```\n# JavaIO的集中输入输出流的比较\n>* FileReader和Filewriter可以作为Buffer类的参数\n>* BufferedReader和BufferedWriter在内存中会自带一个8kb的字节缓冲区\n>* Buffer同样可以传入File类\n>* PrintWriter的print、println方法可以接受任意类型的参数，而BufferedWriter的write方法只能接受字符、字符数组和字符串\n>* PrintWriter不但能接收字符流，也能接收字节流。\n","categories":["JavaStudy"],"tags":["IO"]},{"title":"C-Process-API","url":"/posts/5/","content":">总结了关于C语言对进程控制的一些语句\n<!--more-->\n# 进程标识\n* getpid函数：获取调用该函数进程的进程ID。    \n* getppid函数：获取调用该函数进程的父进程ID。  \n* getuid函数：获取调用该函数进程的实际用户ID，一般在没有调用setuid函数（此\n 数不讲）进行修改进程对应的程序文件所属用户的情况下，该用户ID就等于当初运行\n 该程序时的用户ID。  \n* geteuid函数：获取调用该函数进程的有效用户ID，一般在没有调用seteuid函数进行修\n 改前，该用户ID就等于当初的运行该程序时的有效用户ID。  \n* getgid函数：获取调用该函数进程的实际组ID，一般在没有调用setgid函数进行修改\n 前，该用户组ID就等于当初运行该程序时的组ID。  \n* getegid函数：获取调用该函数进程的有效组ID，一般在没有调用setegid函数进行修改 前，该用户ID就等于当初运行该程序时的有效组ID。\n```c\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdio.h>\nint main(void)\n{\n        //执行当前函数的进程ID\n        printf(\"pid  = %d\\n\", getpid());\n        //调用该函数的父进程ID\n        printf(\"ppid = %d\\n\\n\", getppid());\n\n        //调用该函数的实际用户ID\n        printf(\"uid  = %d\\n\", getuid());\n        //调用该函数的有效用户ID\n        printf(\"euid = %d\\n\\n\", geteuid());\n\n        // 调用该函数的实际组ID\n        printf(\"gid  = %d\\n\", getgid());\n        // 调用该函数的有效组ID\n        printf(\"egid = %d\\n\", getegid());\n\n        return 0;\n}\n\n```","categories":["C"],"tags":["Process"]},{"title":"C_open_write","url":"/posts/22783/","content":"> 总结了关于C语言的IO\n<!--more-->\n\n```c\n#include<stdlib.h>\n#include<string.h>\n#include<stdio.h>\nint main(int argc, char* argv[]){\n  char rootline[1024] = \"/root/os_process_shell/code/\";\n  FILE *file;\n  FILE *wfile;\n  char words[1024][1024];\n  int i = 0;\nif(argc >= 1){\n        strcat(rootline,argv[1]);\n        // open file\n        file = fopen(rootline,\"r\");\n        // 逐行读取\n        while(!feof(file)){\n        fgets(words[i],1000,file);\n        i++;\n        }\n}\n// write in txt file    \n  wfile = fopen(\"./word.txt\",\"w\");\n  int j = 0;\n  // 逐行写入\n  while(i>=0){\n        fwrite(words[j],sizeof(words[j]),1,wfile);\n        i--;\n        j++;\n}\n  return 0;\n}\n```\n<img src = \"http://xtzl.wentexl.cn/c_open_write.png\">","categories":["C"],"tags":["C"]},{"title":"sql-Grant","url":"/posts/20431/","content":">总结了关于权限管理的sql语句\n<!--more-->\n# 授予权限\n```sql\n-- 授予wente所有权限\ngrant all privileges on goods to wente\n\n-- 授予dbuser2 查询和修改Goods表的权限\n-- with grant option 表示是否可以把该权限授予其他用户\ngrant select,update on Goods to dbuser2 with grant option\n\n-- 授予dbuser2创建表和视图的权限\ngrant create table,create view to dbuser2\n```\n\n# 禁止权限\n```sql\n-- 禁止guest用户对Goods表进行crud的操作\ndeny select,insert,update, delete on Goods to guest\n```\n\n# 撤销权限\n```sql\n-- 撤销dbuser2对Goods表的查询和更新的权限\nrevoke select,update on Goods from dbuser2\n```\n# 查询权限信息\n```sql\n-- 查看用户名为dbuser2所拥有的权限\nExecute sp_helprotect @username = 'dbuser2'\n\n-- 查询获得某个权限的用户信息\nExecute sp_helprotect @name = 'create view'\n```\n","categories":["SQLS"],"tags":["sqls"]},{"title":"Caffeine","url":"/posts/46615/","content":"> 本文主要介绍了关于Caffeine的用法，仅限于如何使用Caffeine\n<!--more-->\n# Caffeine简介\n>Caffeine是一种在本地进行本地缓存的缓存库，可以使用它来搭建本地缓存  \n>可使用它构建本地缓存+Redis的多级缓存机制  \n>Caffeine提供了四种缓存添加策略：\n>* 手动加载\n>* 自动加载\n>* 手动异步加载\n>* 自动异步加载\n\n \n\n # 手动加载\n ```java\n  @Test\n    public void test1(){\n        Cache<String, String> cache = Caffeine.newBuilder()\n                //设置数据过期时间\n                .expireAfterWrite(10, TimeUnit.MINUTES)\n                //设置数据的最大长度\n                .maximumSize(10_000)\n                .build();\n\n        String key = \"key1\";\n\n        // 根据key查找一个缓存元素， 没有查找到的时候返回null\n                String value = cache.getIfPresent(key);\n        // 根据key查找缓存，如果缓存存在，则返回对应缓存值，如果缓存不存在则生成缓存元素,如果无法生成则返回nul\n                String value2 = cache.get(key, this::createValueByKey);\n\n        // 添加一个缓存元素\n                cache.put(\"key2\",\"xtzl\");\n                String value_key2 = cache.getIfPresent(\"key2\");\n                Assertions.assertEquals(\"xtzl\",value_key2);\n\n        // 移除一个缓存元素\n                cache.invalidate(\"key2\");\n                value_key2 = cache.getIfPresent(\"key2\");\n                Assertions.assertNull(value_key2);\n    }\n\n    // 没查到缓存之后生成缓存元素的方法,生成并自动加入到Cache中\n    private String createValueByKey(String key){\n        return key+\"_value\";\n    }\n ```\n\n # 自动加载\n ```java\n     @Test\n    public void test(){\n        LoadingCache<String, String> cache = Caffeine.newBuilder()\n                .maximumSize(10_000)\n                .expireAfterWrite(10, TimeUnit.MINUTES)\n                .build(this::createExpensiveGraph);\n        // 往缓存中存入数据\n            cache.put(\"key2\",\"value2\");\n        // 查找缓存，若存在则返回对应缓存值，如果缓存不存在则调用指定方法生成指定缓存值,  如果无法生成则返回null\n            String val_key1 = cache.get(\"key1\");\n            String val_key2 = cache.get(\"key2\");\n        // 批量查找缓存，如果缓存不存在则生成缓存元素\n            //模拟加入多个缓存元素\n            List<String> cacheKeyList= new ArrayList<String>();\n            for (int i = 1; i <= 5; i++) {\n                cache.put(\"k\" + i,\"v\" + i);\n                cacheKeyList.add(\"k\"+i);\n            }\n            Map<String, String> cacheAll = cache.getAll(cacheKeyList);\n\n            // 验证是否正常生成\n            Assertions.assertEquals(\"key1_cache_value\", val_key1);\n            Assertions.assertEquals(\"value2\",val_key2);\n            for (int i = 1; i <= 5; i++) {\n                Assertions.assertEquals(\"v\"+i,cacheAll.get(\"k\"+i));\n            }\n    }\n\n    private String createExpensiveGraph(String key){\n        return key+\"_cache_value\";\n    }\n \n ```\n\n # 手动加载与自动加载的区别\n >* 手动加载在Caffeine.newBuilder()中未指定创建缓存值的方法\n >* 手动加载将 getIfPresent() 和 get()方法区分开\n >* 手动加载在get()方法需要指定创建缓存值的方法    \n\n >总结：\n 个人感觉还是自动加载方便。因为在build我们的Cache的时候就已经指定了创建缓存值的方法\n\n# 手动异步加载\n```java\npublic class TestManualAsynchronous {\n    @Test\n    public void test() throws ExecutionException, InterruptedException {\n        AsyncCache<String, String> cache = Caffeine.newBuilder()\n                .expireAfterWrite(10, TimeUnit.MINUTES)\n                .maximumSize(10_000)\n                .buildAsync();\n\n            String key = \"key1\";\n        // 查找一个缓存元素， 没有查找到的时候返回null\n            CompletableFuture<String> key_value = cache.getIfPresent(key);\n        // 查找缓存元素，如果不存在，则异步生成对应key的缓存值\n            CompletableFuture<String> key_get_value = cache.get(key, this::createExpensiveGraph);\n        // 添加或者更新一个缓存元素\n            cache.put(key, key_get_value);\n        // 移除一个缓存元素\n        CompletableFuture<String> key3_value = cache.get(\"key3\", this::createExpensiveGraph);\n        cache.put(\"key3\",key3_value);\n        // 也要先转成同步的之后才移除\n        cache.synchronous().invalidate(\"key3\"); \n        CompletableFuture<String> key3_del = cache.getIfPresent(\"key3\");\n        // 验证\n        Assertions.assertNull(key_value);\n        // join()或者get()方法是得到字符串类型的值\n        Assertions.assertEquals(\"key1_value\",key_get_value.join()); \n        Assertions.assertNull(key3_del);\n    }\n    // 根据key创建对应的缓存元素，并自动加入到缓存Cache中\n    private String createExpensiveGraph(String key){\n        return key+\"_value\";\n    }\n}\n```\n# 自动异步加载\n```java\n    @Test\n    public void test() throws ExecutionException, InterruptedException {\n        AsyncLoadingCache<String, String> cache = Caffeine.newBuilder()\n                .maximumSize(10_000)\n                .expireAfterWrite(10, TimeUnit.MINUTES)\n                // 你可以选择: 去异步的封装一段同步操作来生成缓存元素\n                .buildAsync(this::createExpensiveGraph);\n            /** 也可以选择: 构建一个异步缓存元素操作并返回一个future\n                .buildAsync((key, executor) -> createExpensiveGraphAsync(key, executor));\n            */\n        String key = \"key1\";\n        // 查找缓存元素，如果其不存在，将会异步进行生成\n        CompletableFuture<String> key1_value = cache.get(key);\n\n        // 批量查找缓存元素，如果其不存在，将会异步进行生成\n        String [] keys = {\"k1\",\"k2\",\"k3\"};\n        List<String> keysList = Arrays.asList(keys);\n        CompletableFuture<Map<String, String>> keys_values_map = cache.getAll(keysList);\n        // 将CompletableFuture类型获取到其中的Map\n        Map<String, String> map = keys_values_map.get();\n        // 将Map中的元素提取成Set集合，元素为Entry类型，并使用Set集合的迭代器迭代遍历\n        Set<Map.Entry<String, String>> entries = map.entrySet();\n        Iterator<Map.Entry<String, String>> iterator = entries.iterator();\n        while (iterator.hasNext()){\n            Map.Entry<String, String> next = iterator.next();\n            System.out.println(next.getKey());\n            System.out.println(next.getValue());\n        }\n    }\n    private String createExpensiveGraph(String key){\n        return key+\"_value\";\n    }\n```\n# 同步和异步的差别\n>* 移除缓存元素，同步直接调用invalidate()就可移除，异步需要先使用synchronous()转成同步之后才能调用invalidate()移除元素\n>* get() 和 getIfPresent()方法在同步中直接返回的是缓存值，在异步方法中返回的是CompletableFuture类型的数据，CompletableFuture类型的数据需要执行join()或者get()方法才能获取到真正的缓存值\n\n\n# CacheLoader\n> CacheLoader共可实现6个方法\n>* load\n>* loadall\n>* asyncload\n>* asyncloadall\n>* reload\n>* asyncReload\n```java\n LoadingCache<String, Object> cache = Caffeine.newBuilder()\n        .maximumSize(10_000)\n        .expireAfterWrite(10, TimeUnit.MINUTES)\n        .build(new CacheLoader<String, Object>() {\n            @Override\n            // 调用get方法，若在缓存未命中，则生成一个缓存值\n            public @Nullable Object load(@NonNull String s) throws Exception {\n                return s + \"_value\";\n            }\n        });\n```","categories":["TechStack"],"tags":["Cache"]},{"title":"sql_TSQL","url":"/posts/4967/","content":">Transction-Sql的积累，主要是与事务，流程相关的东西\n<!--more-->\n```sql\n-- 游标的使用场景:\n-- 数据表有几千万数据，需要就其中约百万数据进行更新，不能锁表。因此采用游标进行更新\n\n-- 1.游标查询\n-- 建立scroll滚动游标\n-- 定义游标,scroll是参数，cursor是固定的定义格式\ndeclare cur scroll cursor for\n\tselect * from goods join category on goods.categoryno = category.categoryno where category.categoryname = '洗发水'\n-- 打开游标\nopen cur\n-- 游标指向上面查询出来的表的第一条数据\nfetch first from cur \n-- 指向最后一条\nfetch last from cur\n-- 从上往下数，第十条数据（绝对的）\nfetch absolute 10 from cur\n-- 从当前游标所在的位置往后数的第五个数据 （相对于当前游标所在位置，是相对的）\nfetch relative 5 from cur\n-- 固定格式，关闭游标\nclose cur\ndeallocate cur\n\n\n-- 2.游标更新\ndeclare @Id char(6); -- 声明临时变量\n-- 声明更新游标\ndeclare cur_up scroll cursor for \n\t(select goodsno from goods join category on goods.categoryno = category.categoryno where category.categoryname = '咖啡') for update of saleprice;\nopen cur_up;\nfetch next from cur_up\ninto @Id;\nwhile @@FETCH_STATUS = 0\nbegin\n\tupdate goods set saleprice = saleprice *0.9 where goods.goodsno = @Id\n\t-- 切换\n\tfetch next from cur_up\n\tinto @Id\nend;\nclose cur_up\ndeallocate cur_up\n\n\n-- 触发器的使用场景：当需要删除与多表之间相连的数据，但又不想使用级联的时候\n-- 由系统调用，我们也需要表明调用的实际和规则\n\n-- 3.触发器实现商品的购买\ncreate trigger sale_trigger\non\tsalebill\nafter insert as\ndeclare @changenum int\ndeclare @change_goodsno char(6)\n\nselect @changenum = number from inserted \nselect @change_goodsno = goodsno from inserted\nbegin\n\tupdate goods set number = (number - @changenum) where goods.goodsno = @change_goodsno\nend\n\n-- 激活对应表中某个触发器,如果要激活所有的，就把触发器名改为all\nalter table salebill enable trigger sale_trigger\n\n-- 实行购买操作，向saleprice表中增加购买记录\ninsert into salebill values('gn001','s01','2022-10-25 17:18:00',2);\n\nselect * from salebill join  goods on salebill.goodsno = goods.goodsno\nselect * from goods\n\n\n-- 4.触发器实现删除类别信息的时候同时删除商品表中对应类别编号设置为其他类别\ncreate trigger category_trigger \non category \nafter delete as\ndeclare @del_categoryno char(6)\nselect @del_categoryno = categoryno from deleted\n\nbegin\n\tupdate goods set categoryno = 'cn006' where goods.categoryno = @del_categoryno\nend\n\nalter table category enable trigger category_trigger\n\n-- 执行删除类别信息的操作\ndelete from category where category.categoryno = 'cn005'\n\nselect * from category\nselect * from goods\n\n-- 5.创建触发器：实现在供应商表Supplier中删除供货商时，同时删除该供货商所供应的商品信息及商品的销售记录。\ncreate trigger supplier_trigger\non supplier \ninstead of delete as\ndeclare @sup_no char(6)\n\n-- 值\nselect @sup_no = supplierno from deleted\nbegin\n\tdelete from salebill where salebill.goodsno in \n\t(select goodsno from goods where goods.supplierno = @sup_no)\n\n\tdelete from goods where goods.supplierno = @sup_no\n\tdelete from supplier where supplier.supplierno = 'sup002'\nend\n\nalter table supplier enable trigger supplier_trigger\n\nselect * from supplier join goods on goods.supplierno = supplier.supplierno join salebill on salebill.goodsno = goods.goodsno\nselect * from salebill\n\n-- 6.创建触发器：向销售表SaleBill中插入一条记录时，这个触发器将更新商品表Goods。要求：Goods表中数量为原有数量减去销售数量\n--\t  如果库存数量小于10，则提示“该商品数量小于10，低于安全库存量，请及时进货”；如果原有数量不足，则提示“数量不足！”\n\ncreate trigger saleprint_goods\non salebill\nafter insert as \ndeclare @sale_goodsno char(6)\ndeclare @change_number int\ndeclare @now_number int\ndeclare @end_number int \n\nselect @sale_goodsno = goodsno,@change_number = number from inserted\nselect @now_number = number from goods where goodsno = @sale_goodsno\nset @end_number = @now_number - @change_number\n\nbegin\n\tif(@end_number < 10 and @end_number>=0 )\n\t\tprint('该商品数量小于10，低于安全库存量，请及时进货')\n\telse if( @end_number < 0)\n\t\tprint('数量不足')\n\telse\n\t\tupdate goods set number = @end_number where goods.goodsno = @sale_goodsno\nend\n-- 激活触发器\nalter table salebill enable trigger saleprint_goods\n-- 执行插入命令\ninsert into salebill values('gn005','s05','2022-10-26 11:16:00',1)\ninsert into salebill values('gn005','s05','2022-10-26 11:16:00',4)\ninsert into salebill values('gn007','s05','2022-10-26 11:16:00',2)\n\nselect * from salebill join goods on goods.goodsno = salebill.goodsno\n\n```","categories":["SQLS"],"tags":["sqls"]},{"title":"sql_View","url":"/posts/46353/","content":">主要讲的是视图创建的东西\n<!--more-->\n\n```sql\nuse supermarket_Insert\n-- 1.\ncreate view V_MIS as select * from student where major = 'MIS'\n\nselect * from V_MIS\n\n--2.\ncreate view V_SSG as \nselect student.sno,student.sname,goods.goodsname,goods.saleprice,salebill.number \nfrom student \njoin salebill \non student.sno = salebill.sno \njoin goods on \ngoods.goodsno = salebill.goodsno\n\n\n-- 3.\ncreate view V_AGE as \nselect *,\n\t(2020 - student.birthyear) as age\nfrom\n\tstudent\n\nselect * from V_AGE\n\n-- 4.\ncreate view V_COM as\nselect\n\tstudent.college,\n\tcount(*) counts_num,\n\tAVG(2020-student.birthyear) avg_age\nfrom \n\tstudent\ngroup by\n\tstudent.college\n\nselect * from V_COM\n\n-- 5.\ncreate view V_S_CONSUME as\nselect\n\tstudent.sno,\n\tSUM(goods.saleprice * salebill.number) cost_all,\n\tcount(distinct goods.categoryno) goods_category_counts\nfrom\n\tstudent\njoin\n\tsalebill\non\n\tstudent.sno = salebill.sno\njoin\n\tgoods\non\n\tgoods.goodsno = salebill.goodsno\ngroup by\n\tstudent.sno\n\nselect * from V_S_CONSUME\n\n\n--6 .\ncreate view V_GOOODS as \nselect\n\tgoods.categoryno,\n\tcount(*) goods_num,\n\tAVG(goods.saleprice) avg_price,\n\tmin(goods.number) min_number\nfrom\n\tgoods\ngroup by\n\tgoods.categoryno\n\t\nselect * from V_GOOODS\n\n-- 7.\ncreate view V_SU_GOOD as\nselect\n\tgoods.supplierno,\n\tsum(goods.number) goods_counts_rest_sum,\n\tAVG(goods.inprice) goods_inprice_avg,\n\tsum(case when salebill.goodsno is null then goods.number else goods.number+salebill.number end) goods_counts_all_sum\nfrom\n\tgoods\nleft join\n\tsalebill\non\n\tgoods.goodsno = salebill.goodsno\ngroup by\n\tgoods.supplierno\n\nselect * from V_SU_GOOD\n\n-- 8.\nselect \n\t*\nfrom\n\tV_COM\nwhere\n\tavg_age > 19\n\n-- 9.\nselect * from\n\tV_S_CONSUME\nwhere\n\tcost_all > 20\n\n-- 10.\nselect\n\tsupplier.suppliername,\n\tsupplier.number,\n\tsupplier.address\nfrom\n\tV_SU_GOOD\njoin\n\tsupplier\non\n\tsupplier.supplierno = V_SU_GOOD.supplierno\nwhere\n\tgoods_counts_rest_sum < 50\n\n-- 11.\ninsert into V_MIS values('s09','宋江','2000','男','CS','MIS','wx009')\n\nselect * from V_MIS\n\n-- 12.\ninsert into V_MIS values('s10','周瑜','1999','男','CS','IT','wx010')\nselect * from V_MIS\nselect * from student\n\n-- 13.\nupdate V_MIS set sname = '李欢欢' where sno = 's01'\n\n-- 14.\nupdate V_MIS set sname = '徐慧慧' where sno = 's02'\nselect * from V_MIS\n\n-- 15.\nupdate V_SSG set saleprice = 10 where sname = '力神咖啡'\nselect * from V_SSG\n\n-- 16.\ndelete from V_MIS where sno = 's09'\nselect * from V_MIS\n\n-- 17.\ndelete from V_MIS where sno = 's10'\nselect * from V_MIS\nselect * from student\n\n```","categories":["SQLS"],"tags":["sqls"]},{"title":"sql_DQL","url":"/posts/19382/","content":">关于数据查询语言的修改\n<!--more-->\n```sql\nuse supermarket;\n\n\n--1 \nselect * from goods\n\n--2 条件查询\nselect\n\t* \nfrom\n\tgoods\nwhere\n\tgoods.categoryno = 'cn002'\n\n--3 条件查询\nselect\n\t*\nfrom\n\tgoods\nwhere\n\tgoods.categoryno = 'cn001'\n\tor\n\tgoods.categoryno = 'cn002'\n\n\n--4 条件查询\nselect\n\t*\nfrom\n\tgoods\nwhere\n\tgoods.inprice > 20\nand\n\tgoods.categoryno = 'cn005'\n\n\n--5 内连接查询\nselect\n\tgoods.goodsno,\n\ts.supplierno,\n\tgoods.goodsname,\n\tgoods.number\nfrom\n\tgoods\njoin\n\tsupplier s\non\n\tgoods.supplierno = s.supplierno\nwhere\n\tgoods.number < 10\n\n\n--6 左外连接查询\nselect\n\tstu.sno\nfrom\n\tstudent stu\nleft join\n\tsalebill\non\n\tsalebill.sno = stu.sno\nwhere\n\tsalebill.goodsno is not null\n\n--7 条件查询\nselect\n\tstu.sno,\n\tstu.sname,\n\t(2022-stu.birthyear) age\nfrom\n\tstudent stu\nwhere\n\tstu.major = 'IT'\n\n--8 条件查询\nselect\n\tstu.sno,\n\tstu.sname,\n\tstu.college,\n\tstu.major,\n\t(2022- stu.birthyear) age\nfrom\n\tstudent stu\nwhere\n\t(2022- stu.birthyear) >= 22\nand\n\t(2022- stu.birthyear) <= 24\n\n--9 模糊查询\nselect\n\tstu.sno,\n\tstu.sname,\n\tstu.college\nfrom\n\tstudent stu\nwhere\n\tstu.sname like '张%'\n\n--10 排序查询\nselect\n\t*\nfrom\n\tgoods\nwhere\n\tgoods.number > 20\norder by \n\tgoods.number DESC\n\n\n--11 条件查询，排序查询\nselect\n\tgoods.goodsno,\n\tgoods.goodsname,\n\tgoods.categoryno,\n\tgoods.number\nfrom\n\tgoods\nwhere\n\tgoods.number <= 10\norder by\n\tgoods.categoryno ASC,\n\tgoods.number DESC\n\n\n\n\n--12.top的使用,解决了并列问题\nselect\n\ttop 3 *\nfrom\n\tgoods\nwhere\n\tgoods.number in (\n\t\tselect\n\t\t\ttop 3 number\n\t\tfrom\n\t\t\tgoods\n\t)\norder by goods.number DESC\n\n\n--13. 子查询\nselect\n\tgoods.goodsno,\n\tgoods.goodsname,\n\tgoods.number\nfrom\n\tgoods\njoin\n\tcategory\non\n\tgoods.categoryno = category.categoryno\nwhere\n\tcategory.categoryno = 'cn001'\nand\n\tgoods.number = (select max(number) from goods)\n\n--14.条件查询\nselect\n\tcount(*) countStu\nfrom\n\tstudent\nwhere\n\tstudent.major = 'MIS'\n\t\n\n\n--15. 分组查询\nselect\n\tstudent.college,\n\tcount(*) countAge\nfrom\n\tstudent\nwhere\n\t(2022 - student.birthyear) >= 20\ngroup by\n\tcollege\n\n--16.内连接查询\nselect\n\tgoods.goodsno,\n\tgoods.goodsname,\n\tsum(salebill.number) salecounts\nfrom\n\tsalebill\njoin \n\tgoods\non\n\tgoods.goodsno = salebill.goodsno\nwhere\n\tsalebill.happentime > CONVERT(date,'2018-01-01 00:00:00')\nand\n\tsalebill.happentime < CONVERT(date,'2019-01-01 00:00:00')\ngroup by\n\tgoods.goodsno,\n\tgoods.goodsname\n\n\n--17. having子句\nselect\n\tcollege,\n\tCOUNT(*) counts\nfrom\n\tstudent \ngroup by\n\tcollege\nhaving\n\tcount(*) > 3\n\n\n--18.派生表查询\nselect\n\tstu.sno,\n\tstu.sname,\n\tsalenum.countsnum\nfrom\n\tstudent stu,\n\t(\n\t\tselect\n\t\t\tsum(salebill.number) countsnum\n\t\tfrom\n\t\t\tsalebill\n\t\tjoin\n\t\t\tstudent\n\t\ton student.sno = salebill.sno\n\t\twhere\n\t\t\tsalebill.happentime > CONVERT(date,'2019-01-01 00:00:00')\n\t\tand\n\t\t\tsalebill.happentime < CONVERT(date,'2020-01-01 00:00:00')\n\t\tgroup by\n\t\t\tstudent.sno\n\t) salenum\nwhere\n\tsalenum.countsnum > 5\n\n-- 19.内连接查询\nselect\n\tAVG(goods.saleprice) avg_sale_price\nfrom\n\tgoods\njoin\n\tcategory\non\n\tgoods.categoryno = category.categoryno\nwhere\n\tcategory.categoryname = '咖啡'\n\n--20.相关子查询\nselect\n\tsno,\n\tsname,\n\tcollege\nfrom\n\tstudent stu\nwhere\n\tstu.college = (\n\t\tselect\n\t\t\tcollege\n\t\tfrom\n\t\t\tstudent\n\t\twhere\n\t\t\tstudent.sname = '张小红'\n\t)\n\n\n-- 21.内连接查询\nselect\t\n\tg.goodsno,\n\tg.goodsname,\n\tstu.sno,\n\tstu.sname,\n\ts.happentime,\n\ts.number\nfrom\n\tgoods g\njoin\n\tsalebill s\non\n\tg.goodsno = s.goodsno\njoin \n\tstudent stu\non\n\tstu.sno = s.sno \norder by\n\ts.happentime DESC\n\n-- 22. 内连接查询\nselect\n\tstu.sno,\n\tstu.sname,\n\tstu.college\nfrom\n\tstudent stu\njoin\n\tsalebill\non\n\tsalebill.sno = stu.sno\n\n\n--23. 内连接查询\nselect\n\tstu.sno,\n\tstu.sname,\n\tstu.college\nfrom\n\tstudent stu\njoin\n\tsalebill\non\n\tstu.sno = salebill.sno\njoin\n\tgoods\non\n\tgoods.goodsno = salebill.goodsno\njoin\n\tcategory\non\n\tgoods.categoryno = category.categoryno\nwhere\n\tcategory.categoryname = '咖啡'\n\n\n-- 24.连接查询\nselect\n\tg.goodsno,\n\tgoodsname,\n\tc.categoryname,\n\tg.saleprice,\n\tg.number\nfrom\n\tgoods g\njoin \n\tcategory c\non\n\tg.categoryno = c.categoryno\nleft join\n\tsalebill s\non\n\tg.goodsno = s.goodsno\nwhere\n\ts.happentime is null\n\n\n--24.子查询\nselect\n\tg.goodsno,\n\tgoodsname,\n\tc.categoryname,\n\tg.saleprice,\n\tg.number\nfrom \n\tgoods g,\n\tcategory c\nwhere\n\tg.categoryno = c.categoryno\nand\n\tg.goodsno not in(\n\t\tselect\n\t\t\tgoodsno\n\t\tfrom\n\t\t\tsalebill\n\t)\n\n\t\n-- 25.同26题\nselect\n\tstudent.sno,\n\tsname,\n\tcollege\nfrom\n\tstudent\njoin \n\tsalebill\non\n\tstudent.sno = salebill.sno\nwhere\n\tsalebill.goodsno = 'gn001'\n\n-- 26.用内连接查询实现\nselect\n\tstudent.sno,\n\tsname,\n\tcollege\nfrom\n\tstudent\njoin \n\tsalebill\non\n\tstudent.sno = salebill.sno\nwhere\n\tsalebill.goodsno = 'gn001'\n\n\n-- 27.用子查询实现\nselect \n\tsno,\n\tsname,\n\tcollege\nfrom \n\tstudent\nwhere\n\tsno in (\n\t\tselect\n\t\t\tsno\n\t\tfrom\n\t\t\tstudent\t\n\t\twhere\n\t\t\tbirthyear in (\n\t\t\t\t\tselect\t\n\t\t\t\t\t\tmin(birthyear)\n\t\t\t\t\tfrom\n\t\t\t\t\t\tstudent\n\t\t\t\t\tgroup by\n\t\t\t\t\t\tcollege\n\t\t\t)\n\n\t)\n\n-- 27.用派生表实现\nselect \n\tsno,\n\tsname,\n\tstuM.college\nfrom \n\tstudent stuM,\n\t(select \n\t\tmin(stuN.birthyear) as birthyear,\n\t\tstuN.college\n\t from\n\t\tstudent stuN\n\t group by\n\t\tcollege\t\n\t\t) as stuP\nwhere\n\tstuM.birthyear = stuP.birthyear\nand \n\tstuM.college = stuP.college\n\n\n--28.用内连接查询\nselect\n\tg.goodsno,\n\tg.goodsname\n\t-- SUM(s.number) as counts\nfrom\n\tgoods g\njoin\n\tsalebill s\non\n\tg.goodsno = s.goodsno\ngroup by \n\tg.goodsno,\n\tg.goodsname\n\n-- 28.派生表查询\nselect\n\tg.goodsno,\n\tgoodsname,\n\tgs.counts_num\nfrom\n\tgoods g,\n\t(\n\tselect \n\t\tsum(number) as counts_num,\n\t\tgoodsno\n\t from\n\t\tsalebill\n\tgroup by \n\t\tsalebill.goodsno\n\t) gs\nwhere\n\tg.goodsno = gs.goodsno;\n\n--29. 派生表查询\nselect\n\tstu.sno,\n\tsname,\n\tcollege\nfrom\n\tstudent stu,\n\t(\n\tselect\n\t\tsno,\n\t\tsum(number) buy_counts\n\tfrom\n\t\tsalebill\n\twhere\n\t\thappentime < convert( date,'2020-01-01 00:00:00')\n\tand\n\t\thappentime > CONVERT(date,'2019-01-01 00:00:00')\n\tgroup by\n\t\tsno\n\t)sum_number\nwhere\n\tstu.sno = sum_number.sno\n\n\n--30.派生表\nselect\n\tsup.supplierno,\n\tsup.suppliername,\n\tsup.address\nfrom\n\tsupplier sup,\n\t(\n\tselect\n\t\tsupplierno,\n\t\tsum(number) sum_number\n\tfrom\n\t\tgoods\n\tgroup by\n\t\tsupplierno\n\t) sumgoods\nwhere\n\tsumgoods.sum_number > 50\nand \n\tsup.supplierno = sumgoods.supplierno\norder by \n\tsumgoods.sum_number DESC\n\n\n\n\n\t-- 导入新的sql\n\t-- 选做1\nselect\n\ttop 1 st.college,\n\tmax(c_sum) max_sum\nfrom\n\t(\n\tselect\n\t\tstu.college college,\n\t\tsum(salebill.number) c_sum\n\tfrom\n\t\tstudent stu\n\tjoin \n\t\tsalebill\n\ton stu.sno = salebill.sno\n\tgroup by \n\t\tstu.college\n\t) cs,\n\t\tstudent st\nwhere\n\tst.college = cs.college\ngroup by\n\tst.college\norder by\n\tmax_sum DESC\n```","categories":["SQLS"],"tags":["sqls"]},{"title":"sql_DML","url":"/posts/35774/","content":">关于数据操纵语言的积累\n<!--more-->\n```sql\nuse supermarket_Insert;\n\n-- 向goods表中添加数据\ninsert into goods values('GN0001','Sup001','CN001','优乐美奶茶',2.5,3.5,100,'2019-12-20')\ninsert into goods values('GN0002','Sup002','CN001','雀巢咖啡',4,5.8,50,'2017-06-08')\ninsert into goods values('GN0005','Sup003','CN002','飘柔洗发水',15,19.8,65,'2019-05-29')\ninsert into goods values('GN0007','Sup005','CN005','小绵羊被套',120,150,28,'2019-11-22')\n\n-- 向supplier表中添加数据\ninsert into supplier values('sup001','卡夫食品','广东佛山','12348768900')\ninsert into supplier values('sup002','久润食品','广东东莞','13248768901')\ninsert into supplier values('sup003','飞鹤食品','重庆解放碑','12648768901')\ninsert into supplier values('sup004','南山日化','重庆南坪','11648768903')\ninsert into supplier values('sup005','缙云日化','重庆北培','19648768903')\n\n-- 向Category表中添加数据\ninsert into category values('CN001','咖啡','速溶咖啡，袋装咖啡，咖啡粉')\ninsert into category values('CN002','洗发水','袋装，瓶装洗发水')\ninsert into category values('CN005','床上用品','被套，枕套,床单')\n\n-- 向student表中添加数据\ninsert into student values('S01','李明','1999','男','CS','IT','wx001')\ninsert into student values('S02','徐好','1998','女','CS','MIS','wx002')\ninsert into student values('S03','伍民','1996','男','CS','MIS','wx003')\ninsert into student values('S04','闵红','1997','女','ACC','AC','wx004')\ninsert into student values('S05','张小红','1997','女','ACC','AC','wx005')\n\n-- SaleBill表中添加数据\ninsert into salebill values('GN0001','S01','2020-06-09','3')\ninsert into salebill values('GN0001','S02','2020-05-03','1')\ninsert into salebill values('GN0001','S03','2020-04-07','1')\ninsert into salebill values('GN0002','S02','2020-05-08','2')\ninsert into salebill values('GN0002','S05','2020-06-26','2')\ninsert into salebill values('GN0005','S05','2020-06-01','1')\n\n\n-- mysql的多表联合修改\nUPDATE `daily_heath` d JOIN `stu_tea` s ON d.hea_id = s.hea_id SET d.peo_id = s.peo_id;\n\n-- 2.\nupdate goods set goodsname = '雀巢咖啡条a装' where goodsname = '雀巢咖啡'\n\n-- 3.\nupdate goods set saleprice = saleprice*1.05\n\n-- 4.\nupdate category set categoryno = 'CN004' where categoryno = 'CN005'\n\n-- 5.\nupdate goods set saleprice = saleprice*0.8 \nwhere goods.goodsno in\n(\tselect\n\t\tgoodsno\n\tfrom\n\t\tsalebill\n\twhere\n\t\tsalebill.number < 3\n\tand\n\t\tsalebill.happentime < '2021-01-01'\n\tand \n\t\tsalebill.happentime > '2020-01-01'\n)\n-- 6.\nupdate goods set number = 0 where supplierno = \n( select\n\tsupplierno\n  from\n\tsupplier\n  where\n\tsupplier.suppliername = '久润食品'\n)\n\n--7. \ndelete from salebill where salebill.number < 3 and salebill.goodsno = (\n\tselect\n\t\tgoodsno\n\tfrom\n\t\tgoods\n\twhere\n\t\tgoods.goodsname = '优乐美奶茶'\n)\n\n-- 8.\ndelete from goods where producttime < '2018-01-01' \nalter table salebill add constraint PK_sale_goods foreign key(goodsno) references goods(goodsno) on delete cascade\n\n-- 9.\ndelete from salebill where goodsno in (\n\tselect\n\t\tgoodsno\n\tfrom\n\t\tgoods\n\tjoin\n\t\tsupplier\n\ton\n\t\tgoods.supplierno = supplier.supplierno\n\twhere\n\t\tsupplier.suppliername = '卡夫食品')\n\n-- 10.\ndelete from salebill where salebill.sno in (\n\tselect\n\t\tsno\n\tfrom student\n\twhere\n\t\tstudent.college = 'ACC'\n)\n\n-- 11.\ndelete from salebill\ndelete from goods\n\n--12.\ndelete from student where student.birthyear < 1997\n\nupdate goods set categoryno = 'CN001' where goodsno = 'GN0002'\n\n\nselect * from salebill\nselect * from student\nselect * from goods\nselect * from category\nselect * from supplier\n\n\n```","categories":["SQLS"],"tags":["sqls"]},{"title":"sql_DDL","url":"/posts/56248/","content":">关键数据定义语言的sql语句\n<!--more-->\n```sql\ncreate database sqlserverdatabase;\nuse sqlserverdatabase;\n\n\n-- 货品表\n\ncreate table Goods(\n\tGoodsNo varchar(15) primary key,\n\tSupplierNO char(6),\n\tCategoryNO varchar(15),\n\tGoodsName varchar(10),\n\t-- 六位数，保留一位小数\n\tInPrice\tdecimal(6,1),\n\tSalePrice decimal(6,1),\n\tNumber int,\n\tProductTime date\n);\n\n\ninsert into Goods values('GNOO1','Sup001','CN001','优乐美奶茶',2.5,3.5,100,'20191220')\ninsert into Goods values('GNOO2','Sup002','CN001','雀巢咖啡',4,5.8,50,'20170608')\ninsert into Goods values('GNOO5','Sup003','CN002','飘柔洗发水',15,19.8,65,'20190529')\ninsert into Goods values('GNOO7','Sup005','CN005','小绵羊被套',120,150,28,'20191122')\n\n-- 增加保质期属性列\nalter table Goods add QGperiod int;\n-- 修改Goods表“进价”属性列为精确数值型，总共七位，保留一位小数。\nalter table Goods alter column InPrice decimal(7,1)\n-- CategoryNO为外码，对Category表的主键\nalter table Goods add constraint outsidecode foreign key(CategoryNO) references Category(CategoryNO);\n\n-- 删除外键\nalter table Gooos drop foreign key outsidecode\n\nselect * from Goods;\nDELETE FROM Goods;\n\n-- 学生表\n/*==============================================================*/\n/* Table: Student                                               */\n/*==============================================================*/\ncreate table Student (\n   SNO                  varchar(15)                  not null,\n   SName                varchar(10)          null,\n   BirthYear            int                  null,\n   Gender               char(1)              null,\n   College              varchar(10)          null,\n   Major                varchar(10)          null,\n   WeiXin               varchar(20)          not null,\n   -- 添加主键约束\n   constraint PK_STUDENT primary key (SNO)\n);\n-- 添加WeiXin唯一值约束\nalter table Student add constraint WeixinUnique unique(WeiXin);\n-- 添加check约束\nalter table Student add constraint mycheckN check(Gender = '男' or Gender = '女')\n-- 删除student表中的出生年份这一列\nalter table Student drop column BirthYear;\n-- 删除表student的唯一值约束\nalter table Student drop WeixinUnique;\n\n\nselect * from Student;\n\n\n\n-- 销售表\ndrop table SaleBill;\n/*==============================================================*/\n/* Table: SaleBill                                              */\n/*==============================================================*/\ncreate table SaleBill (\n   GoodsNO              varchar(15)              not null,\n   SNO                  varchar(15)                  not null,\n   HappenTime           date                 null,\n   Number               int                  null,\n   constraint PK_SALEBILL primary key (GoodsNO,SNO)\n)\n-- 在表SaleBill上增加数量大于0的约束。\nalter table SaleBill add constraint numlimit check(Number > 0);\n-- 将表SaleBill上数量的约束修改为0~100。\nalter table SaleBill add constraint changedlimit check(Number >=0 and Number <=100)\n\n\n\n\n-- 商品种类表\n/*==============================================================*/\n/* Table: CategoryNO                                            */\n/*==============================================================*/\ncreate table Category (\n   CategoryNO           varchar(15)          not null,\n   CategoryName         varchar(15)          null,\n   Descriptions         varchar(100)         null,\n   constraint PK_CATEGORYNO primary key (CategoryNO)\n)\n\n-- 在Category表上，按商品类别编号属性列升序 和 商品类别名属性降序建立唯一值索引。\ncreate unique nonclustered index indexMO on Category(CategoryNO ASC,CategoryName DESC);\n\n-- 供应商表\n/*==============================================================*/\n/* Table: Supplier                                              */\n/*==============================================================*/\ncreate table Supplier (\n   SupplierNO           varchar(15)          not null,\n   SupplierName         varchar(15)          null,\n   Address              varchar(20)          null,\n   TelNumber               varchar(20)          null,\n   constraint PK_SUPPLIER primary key (SupplierNO)\n)\n\n-- 在表supplier表上，按供应商号 属性列的唯一值方式建立索引。\ncreate unique nonclustered index indexNO on Supplier(SupplierNO ASC); \n-- 删除supplier上的唯一值索引。\ndrop index indexNO on Supplier;\n\n\n```","categories":["SQLS"],"tags":["sqls"]},{"title":"sql_command","url":"/posts/27698/","content":"\n关于sqlServer的一些命令的创建\n\n<!--more-->\n# JavaType-Mapping-SqlType\n<img src = \"http://xtzl.wentexl.cn/%E6%96%87%E6%A1%A3.png\"> \n\n# Transact-SQL\n## 自定义数据类型\n```sql\n    -- 创建自定义数据类型\n    1, create type\n    例： create type goodsNO from varchar(20) Not NULL\n\n    2, sp_addtype\n    例： EXEC sp_addtype comment,text,NULL\n\n    -- EXEC ： 表示执行后面的存储过程\n    -- 删除自定义数据类型\n    1, sp_droptype \n    例： EXEC sp_droptype goodsNo\n\n    -- 查看自定义的comment的数据类型的相关信息\n    2, sp_help\n    例： EXEC sp_help comment\n```\n\n## 常量或变量\n```sql\n-- 常量\n日期常量：\n    '2/14/2018'  表示 2018 年 2月 14 日\n    '2018-1-19'  表示 2018 年 1月 19 日\n    'Mar 8,2018' 表示 2018 年 3月  8 日\n\n-- 局部变量\n-- 定义\ndeclare @local1 int\ndeclare @local2 char(5), @local3 float\n-- 赋值\nset @local1 = 56 -- 只可给单个变量赋值\nselect @local2 = 'world', @local3 = '34.2'\n-- 将table1表中local3为local1的值的数据，赋值给自定义的变量local2\nselect @local2  =  local3 from table1 where local2 = @local1\n\n-- 以文本形式输出\nprint(@local2)\n-- 以表格形式输出多个变量值\nselect @local2, @local3\n```\n\n## 流程控制语句\n```sql\n-- IF语句\ndeclare @in decimal(18,2), @sale decimal(18,2)\nselect @in = Inprice,@sale = SalePrice from goods where gooodsno = 'G001'\n\nIF @in > @sale\n    print('GN001是打折商品')\nelse if @in = @sale\n    print('测试用例')\nELSE\n    print('GN001是正价商品')\n\n\n-- Case语句\ncase expression\n    when expression1 then result1\n    when expression2 then result2\n    ELSE result3\nEND\n```\n\n# 存储类型\n* varchar(10)，只能存储10个英文字符或数字，也只能存储5个汉字；\n* char(10)，只能存储10个英文字符或数字，也只能存储5个汉字；\n* nvarchar(10)，即存储10个英文字符或数字，也能存储10个汉字；\n* nchar(10)，即存储10个英文字符或数字，也能存储10个汉字\n\n# Date或者DateTime类型的年月日函数\n* year(date)\n* month(date)\n* day(date)\n* datediff(datepart,startdate,enddate):计算两个时间的差值,比如：datediff(yy,getdate(),'2008-08-08') : 表示计算年份的差值\n* getdate() 是获取当时时间，类型是datetime类型\n\n# 截取字符串\n* left('abcdefg',3) ,从左开始截取3位\n* right('asdasd',4), 从右开始截取4位\n* substr('asdadasd',2,4) 截取下标2~3的字符\n\n\n\n\n\n\n\n\n\n\n","categories":["SQLS"],"tags":[]},{"title":"JUC","url":"/posts/30559/","content":">主要总结了关于JUC的相关知识点\n<!--more-->\n# 随记\n>* volatile ： 强制每个线程到主存去获取数据而不是去Cache\n\n## JUC辅助类\n### CountDownLatch(减少计数)\n>* 使用场景： 多个线程互相等待都执行完毕之后，统一执行主线程\n### CyclicBarrier(循环栅栏)\n>* 使用场景： 多个线程互相等待都执行完毕之后，统一执行另一线程\n### Semaphore(信号灯)\n>* 使用场景： 类似于线程池，多个线程抢夺有限个执行机会(锁的机制)\n\n# 锁\n## 无锁\n>多线程争夺资源，很乱\n## 普通锁\n>使用synchronized和ReentrantLock (都是独占锁)\n## 读写锁 ReentrantReadWriteLock\n> * 读读可以共享，支持多人读，可以提升性能\n> * 写锁还是一个线程独占的\n> **缺点:** \n>1, 造成锁饥饿，一直读却没有写\n>2, 同一线程读锁的情况下不能再写锁(可能会死锁)，但是同一线程写锁的情况下还可以去读锁\n> * 锁降级：写锁可以降级为读锁，读锁不能升级为写锁 :即同一线程读的时候不能写，但写的时候可以读\n\n\n## 锁的介绍 \n>* 自旋锁：自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁\n>* 自旋锁的其他种类\n>* 阻塞锁：被阻塞的线程，不会争夺锁。\n>* 可重入锁： 多次进入改锁的域\n>* 读写锁\n>* 互斥锁：锁本身就是互斥的\n>* 悲观锁：不相信，这里会是安全的，必须全部上锁\n>* 乐观锁：相信，这里是安全的。\n>* 公平锁：有优先级的锁\n>* 非公平锁：无优先级的锁\n>* 偏向锁：无竞争不锁，有竞争挂起，转为轻量锁\n>* 对象锁：锁住对象\n>* 线程锁\n>* 锁粗化：多锁变成一个，自己处理\n>* 轻量级锁：CAS 实现\n>* 锁消除：偏向锁就是锁消除的一种\n>* 锁膨胀：jvm实现，锁粗化\n>* 信号量:使用阻塞锁 实现的一种策略\n\n# 阻塞队列\n * 放入  |  取出  |     取队首元素 |    触发  \n * add   | remove  |   element |    抛异常  \n * offer |  poll   |     peek  |     返回Bool  \n * put   |  take    |     无   |     处于阻塞状态，一直处于运行  \n * offer(e,time,unit) |  poll(time,unit)  这种方式的可设置阻塞时间，如果超过设置时  间，则返回Bool\n\n\n# 创建线程的多种方式：\n * 1,继承Thread类 ：参数不可传入Callable\n * 2,实现Runnable接口\n * 3,通过Callable接口\n * 4,通过线程池的方式来创建接口\n\n# Runnable（Thread默认）与Callable接口的比较\n  1,返回值（R无，C有）  \n  2,是否会抛出异常(R无，C有)  \n  3,Callable 和 Runnable都是函数式接口，都可以使用 lambada 表达式  \n  4,实现方法名称:  \n  * Runnable: run方法  \n  * Callable: call方法  \n  \n>- - -\n  Runnable接口有个实现类：FutureTask  \n  * FutureTask构造可以传递 Callable,有Callable的构造方法  \n  * FutureTask可以先单开线程去做其他事情，最后汇总，汇总只需要一次  \n  * FutureTask实际上是构造方法既能传入Callable、也可以传入Runnable  \n\n\n\n\n# 线程池\n## ThreadPoolExecutor\n## 随记\n>* 当阻塞队列和核心线程都满了之后，如果还有线程，将直接优先处理刚来的线程而不是处理阻塞队列里面的线程\n### 参数\n```Java\n// 核心线程\n>int corePoolSize, \n>- - -\n// 最大线程数量\n>int maximumPoolSize,\n>- - -\n// 存活时间及其单位\n>long keepAliveTime,\n>TimeUnit unit,\n>- - -\n//阻塞队列 : 线程排队用的\n>BlockingQueue<Runnable> workQueue,\n>- - -\n//线程工厂：用于创建线程\n>ThreadFactory threadFactory,\n>- - -\n//拒绝策略 : 该线程池无法为其他线程提供服务了\n>RejectedExecutionHandler handler\n```\n## Executors\n>阿里开发规范已经不支持使用Executors了，而使用ThreadPoolExecutor代替\n### 一池 N 线程\n```java\nExecutorService executorService = Executors.newFixedThreadPool(3);\n```\n### 一池一线程\n```java\nExecutorService executorService1 = Executors.newSingleThreadExecutor();\n```\n### 自动根据需要创建线程，可扩容，遇强则强\n```java\nExecutorService executorService2 = Executors.newCachedThreadPool();\n```\n\n### 四种拒绝策略\n>* AbortPolicy(默认):直接抛出Rejected的异常\n>* CallerRunsPolicy: 将任务回退到调用者\n>* DiscardOldestPolicy: 抛弃队列中等待最久的任务，然后将当前任务加入到队列中，尝试再次提交当前任务\n>* DiscardPlicy : 默默丢弃无法处理的任务，不予处理也不抛出任何异常，如果运行任务丢失，这将是最好的策略\n\n\n","categories":["JavaStudy"],"tags":["JUC"]},{"title":"Redis","url":"/posts/27273/","content":"> 介绍了关于Redis的相关内容\n<!--more-->\n# 缓存注解\n```java\n@CacheConfig\n是一个类级别的注解，允许共享缓存的名称。\n一个类可能会有多个缓存操作而这些缓存操作可能是重复的，这时候可以使用@CacheConfig.\n```\n>- - -\n```java\n@Cacheable\n* 代表从缓存中查询指定的key，如果有，从缓存中取，不再执行方法。\n* 如果没有则执行方法，并且将方法的返回值和指定的key关联起来，放入到缓存中。\n\n主要参数：\n* value : 缓存的名称，在spring配置中定义，必须指定至少一个。\n* key: 缓存的key，可以为空，如果指定要按照spel表达式编写，如果不指定，则缺省按照方法的所有参数进行组合。\n* condition: 缓存的条件，可以为空，使用spek编写，返回true或false,只有为true使才进行缓存。\n\nExample:\n@Cacheable(value=\"thisredis\", key=\"'users_'+#id\")\npublic User findUser(Integer id) {}\n```\n>- - -\n>如果在类上配置了@CacheConfig,那么此时@Cacheable中的value就会取代@CacheConfig中cacheNames。  \n>如果在类上配置了@CacheConfig(cacheNames = \" \"),在该类下的@Cacheable中可以不用配置value。\n>- - -\n```java\n@CacheEvict\n标记在方法上，方法执行完毕之后根据条件或key删除对应的缓存。\n\nExample:\n@CacheEvict(value=\"thisredis\",   key=\"'users_'+#id\",condition=\"#id!=1\")\npublic void delUser(Integer id) {}\n\n主要参数：\nallEntries : 布尔类型 表示是否需要清除缓存中的所有元素。\nkey: 需要删除的缓存的key\n\n当我们在更新数据库的数据时，要使用@CacheEvict，需要把redis的缓存清空，否则查询的数据就是redis缓存中的数据，这样就会导致数据库和缓存数据不一致的问题。（页面不能及时的同步更新后的数据）。\n\n加上@CacehEvict 就会在查询数据时发现数据时最新的，与数据库保持一致。\n```","categories":[],"tags":["Redis"]},{"title":"IDEA_Hotkeys","url":"/posts/10026/","content":">日常学习的一个随笔\n<!--more-->\n# 获取request对象\n```java\n ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n```\n# 产生随机数\n```java\n System.out.println((int) (Math.random()*3));\n System.out.println(new Random().nextInt(20));\n\n```","categories":[],"tags":["随笔"]},{"title":"VersionController","url":"/posts/8310/","content":">总结了关于Spring全家桶以及Maven依赖的版本后缀意义，以及依赖关系\n>为了预防版本冲突或者版本不一致所导致的BUG\n<!--more-->\n\n# Maven版本后缀\n>* SNAPSHOT(快照版本Snapshot)\n>* RELEASE(发布版本release)\n>* Alpha：内测版，BUG 多，开发人员开发过程中使用，希腊字母α，第一，指最初版 \n>* Beta：早期版本，有缺陷，无大 BUG，可能加入新功能，进一步开发完善。\n>* Gamma: 经 beta 版，完善修改，成为正式发布的候选版本（Release Candidate）\n>* RC：(Release Candidate)：候选版本，几乎就是正式版了，一般需要 ASF 投票通过后，才会形成正式版本。\n>* GA：（Ggeneral Availability）：发行稳定版，官方推荐使用此版本。\n>* R，RELEASE：正式版，等价于 GA。\n>- - -\n>**其他版本**  \n>Alpha：内部测试版  \nBeta：外部测试版  \nBuild：修正版  \nCorporation 或 Enterprise：企业版  \nDelux：豪华版  \nDEMO：演示版，有功能限制  \nFree：免费版  \nFull：完全版  \nFinal：正式版  \nPro(professional)：专业版  \nPlus：加强版  \nRetail：零售版  \nRelease：发行版，有时间限制  \nShareware：共享版，虽然不会要求注册但是一般也有功能限制  \nSR：修正版  \nTrial：试用版（一般有时间或者功能限制）  \n\n# SpringCloudAlibaba 与 SpringCloud 与 Springboot 的对应关系\n>![alt](http://xtzl.wentexl.cn/%E4%B8%BB%E7%89%88%E6%9C%AC.png)\n\n# SpringCloud的组件\n>![alt](http://xtzl.wentexl.cn/Cloud%E7%BB%84%E4%BB%B6.png)","categories":["version"],"tags":["version"]},{"title":"Swagger2","url":"/posts/35285/","content":"\n> 描述了关于Swagger的简介和简单使用\n<!--more-->\n# 地址：\n>http://服务器ip:端口/swagger-ui.html\n# 什么是swagger2\n>编写和维护接口文档是每个程序员的职责，根据Swagger2可以快速帮助我们编写最新的API接口文档，再也不用担心开会前仍忙于整理各种资料了，间接提升了团队开发的沟通效率。\n# 常用注解\n>* @Api：修饰整个类，描述Controller的作用\n>* @ApiOperation：描述一个类的一个方法，或者说一个接口\n>* @ApiParam：单个参数描述\n>* @ApiModel：用对象来接收参数\n>* @ApiModelProperty：用对象接收参数时，描述对象的一个字段\n>* @ApiImplicitParam：一个请求参数\n>* @ApiImplicitParams：多个请求参数\n# 依赖\n```xml\n  <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui -->\n <dependency>\n      <groupId>io.springfox</groupId>\n      <artifactId>springfox-swagger-ui</artifactId>\n      <version>2.9.2</version>\n  </dependency>\n  <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 -->\n  <dependency>\n      <groupId>io.springfox</groupId>\n      <artifactId>springfox-swagger2</artifactId>\n      <version>2.9.2</version>\n      <scope>compile</scope>\n  </dependency>\n\n```","categories":["Utils"],"tags":["Swagger2"]},{"title":"JSTL 表达式","url":"/posts/9859/","content":"<!--more-->\n# JSTL\n##\t1. 概念：JavaServer Pages Tag Library  JSP标准标签库\n\t\t* 是由Apache组织提供的开源的免费的jsp标签\t\t<标签>\n\n##\t2. 作用：用于简化和替换jsp页面上的java代码\n\n##\t3. 使用步骤：\n\t\t1. 导入jstl相关jar包\n\t\t2. 引入标签库：taglib指令：  <%@ taglib %>\n\t\t3. 使用标签\n\n##\t4. 常用的JSTL标签\n\t\t1. if:相当于java代码的if语句\n\t\t\t1. 属性：\n\t            * test 必须属性，接受boolean表达式\n\t                * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容\n\t                * 一般情况下，test属性值会结合el表达式一起使用\n       \t\t 2. 注意：\n\t       \t\t * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签\n\t\t2. choose:相当于java代码的switch语句\n\t\t\t1. 使用choose标签声明         \t\t\t相当于switch声明\n            2. 使用when标签做判断         \t\t\t相当于case\n            3. 使用otherwise标签做其他情况的声明    \t相当于default\n\n\t\t3. foreach:相当于java代码的for语句\n\n##\t5. 练习：\n\t\t* 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中\n\n\n\n\n\n# 三层架构：软件设计架构\n##\t1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互\n##\t2. 业务逻辑层：处理业务逻辑的。\n##\t3. 数据访问层：操作数据存储文件。","categories":["JavaStudy"],"tags":["JSYL表达式"]},{"title":"EL 表达式","url":"/posts/5361/","content":">总结了关于EL表达式的相关知识\n<!--more-->\n>EL 表达式\n\n#\t1. 概念：Expression Language 表达式语言\n#\t2. 作用：替换和简化jsp页面中java代码的编写\n#\t3. 语法：${表达式}\n#\t4. 注意:\n>\tjsp默认支持el表达式的。如果要忽略el表达式\n##\t1. 设置jsp中page指令中：isELIgnored=\"true\" 忽略当前jsp页面中所有的el表达式\n##\t2. \\${表达式} ：忽略当前这个el表达式\n\n\n#\t5. 使用：\n##\t\t1. 运算：\n\t\t\t* 运算符：\n\t\t\t\t1. 算数运算符： + - * /(div) %(mod)\n\t\t\t\t2. 比较运算符： > < >= <= == !=\n\t\t\t\t3. 逻辑运算符： &&(and) ||(or) !(not)\n\t\t\t\t4. 空运算符： empty\n\t\t\t\t\t* 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0\n\t\t\t\t\t* ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0\n\t\t\t\t\t* ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度>0\n##\t\t2. 获取值\n\t\t\t1. el表达式只能从域对象中获取值\n\t\t\t2. 语法：\n###\t\t\t1. ${域名称.键名}：从指定域中获取指定键的值\n\t\t\t\t\t* 域名称：\n\t\t\t\t\t\t1. pageScope\t\t--> pageContext\n\t\t\t\t\t\t2. requestScope \t--> request\n\t\t\t\t\t\t3. sessionScope \t--> session\n\t\t\t\t\t\t4. applicationScope --> application（ServletContext）\n\t\t\t\t\t* 举例：在request域中存储了name=张三\n\t\t\t\t\t* 获取：${requestScope.name}\n\n###\t\t\t\t2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。\n\n\n\n##\t\t\t\t3. 获取对象、List集合、Map集合的值\n\t\t\t\t\t1. 对象：${域名称.键名.属性名}\n\t\t\t\t\t\t* 本质上会去调用对象的getter方法\n\n\t\t\t\t\t2. List集合：${域名称.键名[索引]}\n\n\t\t\t\t\t3. Map集合：\n\t\t\t\t\t\t* ${域名称.键名.key名称}\n\t\t\t\t\t\t* ${域名称.键名[\"key名称\"]}\n\n\n##\t\t3. 隐式对象：\n\t\t\t* el表达式中有11个隐式对象\n\t\t\t* pageContext：\n\t\t\t\t* 获取jsp其他八个内置对象\n\t\t\t\t\t* ${pageContext.request.contextPath}：动态获取虚拟目录","categories":["JavaStudy"],"tags":["EL表达式"]},{"title":"SpringSecurity-Web 权限","url":"/posts/21484/","content":"> 总结了关于SpringSecurity的Web权限控制方面的知识点\n<!--more-->\n# 设置登录的用户名和密码\n## 通过配置文件\n```yml\nspring:\n  security:\n    user:\n      name: Wente\n      password: wente695\n```\n\n## 自定义编写实现类\n> 从数据库中获取账户和密码，验证的时候是通过用户名获取到数据库的数据\n```java\n@Configuration\npublic class SecuriryConfig extends WebSecurityConfigurerAdapter {\n    @Resource\n    private UserDetailsService userDetailsService;\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailsService).passwordEncoder(password());\n    }\n    @Bean\n    PasswordEncoder password(){return new BCryptPasswordEncoder();}\n}\n```\n**Service端**\n```java\n  @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        List<GrantedAuthority> auths = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\");\n        return new User(\"mary\",new BCryptPasswordEncoder().encode(\"123\"),auths);\n    }\n```\n# 基于角色或者权限进行访问控制\n## hasAuthority 方法\n> 在配置类设置当前访问地址有哪些权限\n> 配置类中设置权限\n```java\n   .antMatchers(\"/test/index\").hasAnyAuthority(\"admins\")// 当前登录用户只有具有admins权限的才能访问这个路径\n```\n> 服务端配置权限\n```java\n  List<GrantedAuthority> auths = AuthorityUtils.commaSeparatedStringToAuthorityList(\"admins\");\n```\n## hasAnyAuthority方法\n```java\n   .antMatchers(\"/test/index\").hasAnyAuthority(\"admins,mannager\")// 当前登录用户只有具有admins,或者mannager的都可以\n```\n## hasRole方法\n> 但是在服务类里面添加角色权限的时候，必须要加一个ROLE_前缀\n>hasanyRole方法在配置类中多个角色用逗号隔开\n```java\n .antMatchers(\"/test/index\").hasRole(\"sale\") // 设置什么角色可以访问\n```\n>- - -\n```java\n  List<GrantedAuthority> auths = AuthorityUtils.commaSeparatedStringToAuthorityList(\"admins,ROLE_sale\");\n```\n>- - -\n\n# 基于注解配置SpringSecurity\n## 设置权限\n> 开启注解配置Security方式\n```java\n// prePostEnabled是表示支持事后验证的方式\n@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)\n```\n>接口类\n```java\n//@Secured({\"ROLE_sale\",\"ROLE_mannager\"})\n@PreAuthorize(\"hasAnyAuthority('admins')\")\n//@PostAuthorize(\"hasAnyAuthority('admins')\") // 在方法执行之后再做权限验证\n    public String update(){\n        return \"hello updata\";\n    }\n```\n## 过滤注解\n```java\n@PostFilter // 方法对返回数据进行过滤\n@PreFillter // 对传入方法的数据进行过滤\n```\n> 参数使用\n```java\n// 表示只返回的数据对象中的username是admin的对象\n@PostFilter(\"filterObject.username == 'admin'\")\n// 表示只传入的数据对象中的username属性是admin的对象\n@PreFilter(\"filterObject.username == 'admin'\")\n```\n# 用户注销\n> href的/logout是自带的，不需要自己去编写\n> 登出后再去访问需要登录的方法的请求就会被拦截，自动跳到登陆页面去\n ```xml\n  <a href=\"/logout\">退出</a>\n ```\n\n# 一定时间内自动登录\n","categories":["SpringSecurity"],"tags":[]},{"title":"boot_Security.md","url":"/posts/29525/","content":"> 主要是针对于SpringSecurity进行总结,主要采用的是SpringBoot + SpringSecurity\n<!--more-->\n# 核心要点\n>* 引入依赖之后访问方法都要先登录，登录用户名默认是user，密码在控制台\n\n# 依赖引入\n```xml\n   <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n```\n# 两个重要接口：\n##  UserDetailsServic 接口: 查询数据库用户名和密码的过程\n* 创建类继承UsernamePasswordAuthenticationFilter\n* 创建类实现UserDetailsService,编写查询数据过程，返回User对象，这个User对象是安全框架提供对象。\n\n## PasswordEncoder 接口：数据加密接口，用于返回User对象里面密码加密\n\n# 配置类\n\n\n","categories":["SpringSecurity"],"tags":["SpringSecurity"]},{"title":"Transaction","url":"/posts/43132/","content":"> 该文主要介绍了关于SpringBoot的事务管理的相关知识点\n<!--more-->\n# 核心\n>* Spring并不直接管理事务，而是通过各种事务管理器来调用特定平台的事务实现\n>* spring统一管理事务，把不同的数据库访问技术的事务处理统一起来\n>* 已经commit的事务是不能rollback的\n\n\n# 常用的事务管理器\n>* DataSourceTransactionManager：用于JDBC的持久化支持，也可用于IBATIS\n>* HibernateTransactionManager：用于Hibernate3的持久化支持\n>* JpaTransactionManager：用于Java持久化API的持久化支持\n>* JtaTransactionManager：主要用于分布式事务的支持\n\n# 事务的传播行为ProPagation\n>**事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式**  \n>优秀博文:http://t.csdn.cn/TgggY  \n> **重点：**\n>* PROPAGATION_REQUIRED : 表示当前方法必须运行在事务中，若当前存在事务，则在原有事务中运行，否则创建一个新的事务。\n>- - -\n>* PROPAGATION_REQUIRES_NEW :  新建事务，如果当前存在事务，把当前事务挂起。\n>- - -\n>* PROPAGATION_SUPPORTS : 如果当前有事务，则使用事务，如果当前没有事务，就以非事务方式执行\n>- - -\n>* Propagation.NOT_SUPPORTED :  以非事务方式执行操作，如果当前存在事务，就把当前事务挂起\n>- - -\n>- - -\n> **次要:**\n>* PROPAGATION_MANDATORY ：表示该方法必须在事务中运行，若当前事务不存在则抛异常。举例来说，一个service方法调用了两个dao方法，那么在执行其中的一个dao方法时，都要求已经启动了事务，否则需要抛异常。\n>- - -\n>* PROPAGATION_NESTED :表示若当前已存在一个事务，那么该方法将在嵌套事务中运行。嵌套事务可以独立于当前事务进行提交或回滚，若当前事务不存在，则该传播行为与PROPAGATION_REQUIRED一样。举例来说，一个service方法中调用了某dao方法，并且根据该dao方法执行的成功或失败区分了两套处理逻辑，这时候若dao执行失败，它只要保证不对数据库数据有任何影响（通过rollback）就可以了，不需要回滚整个service方法，故这个dao方法需要在嵌套事务中运行。\n>- - -\n>* PROPAGATION_NEVER : 表示当前方法不应该运行在事务中，若当前已经有一个事务在运行，则抛异常。这种适用于在某些dao操作中，它要求之前的事务已经结束，而它本身的操作结果不会受到其他dao操作结果的影响（比如被其他操作所rollback）。\n>- - -\n>* PROPAGATION_NOT_SUPPORTED : 表示当前方法不应该运行在事务中，若当前已经有一个事务在运行，则将其挂起。\n\n# 事务并发可能导致的错误\n>* 脏读：某事务读取了其他事务未提交的数据后，其他事务又将其数据回滚，导致该事务使用了无效的数据。\n>- - -\n>* 不可重复读：某事务执行两次相同的查询操作，但是由于在这两次操作中间存在其他事务更新了数据，从而导致两次查询的结果不一致。\n>- - -\n>* 幻读 ：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 删除或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候真实的数据集已经发生了变化，但是A却查询不出来这种变化，因此产生了幻读。\n>- - -\n\n# Spring提供的事务隔离isolation \n>若通过相关互斥机制保证事务的绝对隔离，则会很大程度影响并发的性能，最差情况就相当于事务是串行地执行。为了尽可能避免这些问题、权衡性能以及提高事务隔离的灵活性，Spring定义了五种隔离级别，以允许应用程序自己决定所能接受的、被其他事务所影响的程度。\n>- - -\n>* ISOLATION_DEFAULT : 使用底层数据库默认的隔离级别。\n>- - -\n>* ISOLATION_READ_UNCOMMITTED : 允许读取未提交的数据，这可能导致脏读、不可重复读和幻读。\n>- - -\n>* ISOLATION_READ_COMMITTED ：允许读取已提交的数据，这可以避免脏读，但是还是可能导致不可重复读和幻读。\n>- - -\n>* ISOLATION_REPEATABLE_READ : 对同一字段的多次读取结果是一致的，除非由本事务自己更新，这可以避免不可重复读和脏读，但是还是可能导致幻读。\n>- - -\n>* ISOLATION_SERIALIZABLE：完全按照ACID所要求的，可以避免脏读、不可重复读和幻读。注意：这种事务隔离级别的效率最差，因为它经常需要将事务相关的表进行加锁，锁粒度大。\n>- - -\n>![事务](http://xtzl.wentexl.cn/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E8%A7%84%E5%88%99.png)\n\n\n","categories":["SpringBoot"],"tags":["Transaction"]},{"title":"SpringAop","url":"/posts/21566/","content":">介绍了关于SpringBoot的相关知识点\n<!--more-->\n\n","categories":["SpringBoot"],"tags":["SpringAop"]},{"title":"Seata","url":"/posts/63021/","content":"> 介绍了分布式中关于Seata的知识\n<!--more-->\n# Seata重点\n>* 必须先启动Nacos后启动Seata\n\n\n# Seata介绍\n>* 1 + 3 的组件模型\n>* 分布式事务处理过程的-ID+三组件模型\n>* Transaction ID XID : 全局唯一的事务ID\n\n# Seata术语(三组件)\n## TC (Transaction Coordinator) - 事务协调者\n>维护全局和分支事务的状态，驱动全局事务提交或回滚。\n\n## TM (Transaction Manager) - 事务管理器\n>定义全局事务的范围：开始全局事务、提交或回滚全局事务。\n\n## RM (Resource Manager) - 资源管理器\n>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回\n滚。\n\n![seata](http://xtzl.wentexl.cn/Seata.png)\n>- - -\n\n# BASE理论 \n>BASE理论是对CAP的一种解决思路，包含三个思想：\n>- - -\n>* Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。\n>* Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。\n>* Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。\n>- - -\n>而分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论：\n>- - -\n>* AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。  \n>* CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态\n\n# 分布式事务解决方案\n>Seata提供了四种不同的分布式事务解决方案：\n>- - -\n>* XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入\n>* TCC模式：最终一致的分阶段事务模式，有业务侵入\n>* AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式\n>* SAGA模式：长事务模式，有业务侵入  \n\n**对比**\n![compare](http://xtzl.wentexl.cn/%E5%AF%B9%E6%AF%94.png)","categories":["distributed"],"tags":["Seata"]},{"title":"Cloud-Alibaba-Nacos","url":"/posts/33695/","content":">总结了关于SpringCloud-Alibaba-Nacos的相关知识\n<!--more-->\n# Nacos\n>* Nacos 就是注册中心 + 配置中心的组合\n>* 等价于 Nacos = Eureka + Config + Bus\n>* AP架构和CP架构都支持，可切换（C: 一致性 A：可用性  P:分区容错性）\n>* startup.cmd -m standalone  单机启动命令\n\n# 依赖引入\n> 父工程pom：\n```xml\n     <!--spring cloud alibaba 2.1.0.RELEASE-->\n            <dependency>\n                <groupId>com.alibaba.cloud</groupId>\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n                <version>2.1.0.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n\n```\n> 子工程pom：\n```xml\n        <!--SpringCloud ailibaba nacos -->\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n        </dependency>\n```\n\n# Nacos注册中心\n## 服务端Yml配置\n```yml\nserver:\n  port: 9002\n\nspring:\n  application:\n    name: nacos-payment-provider\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #配置Nacos地址\n        # 换成nginx的1111端口，做集群\n        #server-addr: 192.168.111.144:1111\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n\n```\n## 客户端Yml配置\n```yml\nserver:\n  port: 83\n\n\nspring:\n  application:\n    name: nacos-order-consumer\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848\n\n\nservice-url:\n  nacos-user-service: http://nacos-payment-provider\n```\n\n## 客户端Controller层\n> 由于在配置yml的时候，已经在service-url.nacos-user-service中配置过了，所以直接可用@Value注解进行引入\n```java\n  @Value(\"${service-url.nacos-user-service}\")\n    private String serverURL;\n```\n# Nacos 配置中心\n## 核心\n>* Nacos的Config配置自带动态刷新\n>* DataId必须按官方给定的格式命名\n## 新增依赖\n```xml\n     <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n        </dependency>\n\n```\n## yml配置\n>**bootstrap的优先级是高于application的**\n\n> bootstrap.yml\n```yml\nserver:\n  port: 3377\n\nspring:\n  application:\n    name: nacos-config-client\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #服务注册中心地址\n      config:\n        server-addr: localhost:8848 #配置中心地址\n        file-extension: yaml #指定yaml格式的配置\n```\n>application.yml\n```yml\nspring:\n  profiles:\n    active: dev\n```\n## 在Nacos端的配置文件名格式如下(设置DataId):\n>${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}  \n> 例如: nacos-config-client-dev.yaml\n\n## 分组管理\n![分组](http://xtzl.wentexl.cn/%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86.png)\n>* yml中设置分组,意为选择DEV环境下的配置生效\n```yml\nconfig:\n    group: DEV_GROUP\n```\n>* 不同的组别可以存在DataId相同的配置\n## 命名空间NameSpace\n>* yml文件配置命名空间\n```yml\nconfig:\n    namespace: f2009b56-a85a-487a-afeb-0927aa03a199\n```\n# 切换Nacos的数据库\n>*  Nacos自带一个derby数据库，但是要统一使用mysql数据库\n>*  sql执行脚本在nacos的安装路径中conf目录下\n>* sql执行之后，需要修改conf下application.properties,(mysql8)修改如下\n```txt\nspring.datasource.platform=mysql\ndb.num=1\ndb.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC\ndb.user.0=root\ndb.password.0=root\n```\n","categories":["Alibaba-Nacos"],"tags":["Nacos"]},{"title":"Cloud-Alibaba-Sentinel","url":"/posts/60668/","content":"> 总结了Sentinel的有关知识\n<!--more-->\n# 重点\n>* 实例重启后如果进入sentinel的web界面，则必须先调用一个任意的方法才能被检测到\n>* fallback管的是运行异常，blockHandler管的是配置违规\n>* 当fallback和blockHandler同时起效的时，优先起效的是blockHandler方法\n>* 自带负载均衡\n\n\n# 依赖引入\n```xml\n    <!--SpringCloud ailibaba nacos -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n    </dependency>\n    <!--SpringCloud ailibaba sentinel-datasource-nacos 后续sentinel做持久化用到-->\n    <dependency>\n        <groupId>com.alibaba.csp</groupId>\n        <artifactId>sentinel-datasource-nacos</artifactId>\n    </dependency>\n    <!--SpringCloud ailibaba sentinel -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\n    </dependency>\n```\n# 服务端 yml 配置\n```yml\nserver:\n  port: 8401\n\nspring:\n  application:\n    name: cloudalibaba-sentinel-service\n  cloud:\n    nacos:\n      discovery:\n        server-addr: localhost:8848 #Nacos服务注册中心地址\n    sentinel:\n      transport:\n        # 8080会监控8401查看是否健康\n        dashboard: localhost:8080 #配置Sentinel dashboard地址\n        # 默认是8719端口号,如果被占用了会自动+1\n        # 指定应用与Sentinel控制台交互的端口，应用本地会起一个该端口占用的HttpServer\n        port: 8719\n\n\n      datasource:\n        ds1:\n          nacos:\n            server-addr: localhost:8848\n            dataId: ${spring.application.name}\n            groupId: DEFAULT_GROUP\n            data-type: json\n            rule-type: flow\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n\n```\n# 流控规则\n>* QPS: 每秒的请求数，一般指每秒查询率\n>* 单机阈值: 请求数的多少\n## PostMan测试\n![postman](http://xtzl.wentexl.cn/PostMan.png)\n\n## 流控效果\n### 预热\n>* ColdFactor冷加载因子默认是3\n>* 请求QPS从 threshold/3 开始，经预热时长之后，QPS才会逐渐达到指定QPS值\n>* 预热主要是为了保护系统\n### 快速失败\n>* 只要不满足流控规则，直接让该请求失败\n### 排队等等\n>* 只要每个请求的等待时间不超过设定的超时时间，则每个请求都排队等待响应\n>* 而处理的速度，根据流控规则的单机阈值来决定\n>* 其中超时时间的单位是ms\n>* 如果请求超时，则报错\n\n## 流控模式\n### 关联\n![connect](http://xtzl.wentexl.cn/%E5%85%B3%E8%81%94.png)\n### 直接\n>* 仅仅针对于一个方法而言\n\n# 降级与熔断策略\n>* 官网讲解\n![熔断](http://xtzl.wentexl.cn/%E5%AE%98%E7%BD%91%E7%86%94%E6%96%AD.png)\n\n## RT:慢调用比例\n>* 注意：Sentinel默认RT最大时间为4900毫秒，可通过-Dcsp.sentinel.statistic.max.rt=xxx修改  \n>* 慢调用比例 = 慢调用请求数/请求总数\n>* 在单位统计时长内，如果慢调用比例大于阈值，且请求数大于最小请求数值，则触发熔断\n>* 经过一个熔断时长后，进入探测恢复状态（HALF-OPEN）阶段，即接下来的一个请求响应时间小于rt(200ms),则熔断结束，否则会再次被熔断。\n>* 慢调用不是异常，如果异常的话是不会进行服务降级而是直接报错\n![慢比例](http://xtzl.wentexl.cn/%E6%85%A2%E6%AF%94%E4%BE%8B1.png)\n\n>- - -\n\n## 异常比例\n>* 当单位统计时长内，请求数目大于设置的最小请求数目（5），并且异常的比例大于阈值（0.07），则接下来的熔断时长（3s，时间窗口的值）内请求会自动被熔断。  \n>* 经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]。\n>![异常](http://xtzl.wentexl.cn/%E5%BC%82%E5%B8%B8%E6%AF%94%E4%BE%8B1.8.4.png)\n\n>- - -\n\n## 异常数\n>* 异常数一般都是按分钟统计的\n>* 单位统计时长内，异常数达到设定的异常数则进入服务熔断，调用服务降级的函数\n>* 服务熔断之后，经过一个熔断时长之后，才会进入探测恢复状态\n>![异常数](http://xtzl.wentexl.cn/%E5%BC%82%E5%B8%B8%E6%95%B01.8.4.png)\n\n\n# 热点监控\n>* 在web界面自定义热点规则，当请求违背了热点规则之后，则执行blocakHandler所指的的方法\n>* @SentinelResource 的value属性只要保持唯一性就好，一般与GetMapping的value保持一致\n>* 运行异常不属于热点监控的范围，热点监控只管是否违背热点规则，运行异常也就不会走blockHandler这个方法\n## Controller层\n```java\n    @GetMapping(\"/testHotKey\")\n    @SentinelResource(value = \"testHotKey\", blockHandler = \"deal_testHotKey\")\n    public String testHotKey(@RequestParam(value = \"p1\", required = false) String p1,\n                             @RequestParam(value = \"p2\", required = false) String p2) {\n        int age = 10 / 0;\n        return \"------testHotKey\";\n    }\n    // 兜底的方法\n    public String deal_testHotKey(String p1, String p2, BlockException exception) {\n        //sentinel系统默认的提示：Blocked by Sentinel (flow limiting)\n        return \"------deal_testHotKey,o(╥﹏╥)o\";\n    }\n```\n## Web界面配置\n> * 该图表示监控携带第0个参数的请求，窗口时长内的请求数不能超过1次，资源名为@SentinelResource的Value值\n>* 参数例外项：当指定参数为一特定值的时候，阈值有所不同\n![热点规则](http://xtzl.wentexl.cn/%E5%8F%82%E6%95%B0%E4%BE%8B%E5%A4%96.png)\n\n\n\n# Sentinel 自定义限流处理逻辑\n>* 违反我们自己配置的流控规则才需要blockHandler\n>* 在配置流控规则的时候，资源标识最好只使用@SentinelResource注解的Value属性作为唯一标识\n## @SentinelResource\n>- - -\n>* (value = \"byResource\",blockHandler = \"handleException\")\n>* value是唯一标识，blockHandler是指定处理方法(兜底方法)的方法名\n>- - -\n>* (value = \"customerBlockHandler\",   \nblockHandlerClass = CustomerBlockHandler.class, blockHandler = \"handlerException2\")\n>* blockHandlerClass指定处理类，blockHandler指定类中的哪个方法\n>* 注意在写Handler类的方法的时候，所有方法都必须是static的，且handler类无须加入容器\n>- - -\n >* 其中属性exceptionsToIgnore = {IllegalArgumentException.class}，表示忽略IllegalArgumentException这个异常属性，但是这个忽略异常属性，仅仅指的是在Java层面，也就是fallback方法不响应该异常，但是Sentinel仍然会检测到该异常\n\n # Sentinele同样支持Open-feign\n >修改yml支持Open-feign\n ```yml\n # 激活Sentinel对Feign的支持\nfeign:\n  sentinel:\n    enabled: true\n ```\n >- - -\n ```java\n@FeignClient(value = \"nacos-payment-provider\", fallback = PaymentFallbackService.class)\n ```\n > 其中，service层分为接口+实现类，上面的注解标注在接口，fallback指向实现类\n\n# Sentinel持久化\n## 依赖引入\n```xml\n        <dependency>\n            <groupId>com.alibaba.csp</groupId>\n            <artifactId>sentinel-datasource-nacos</artifactId>\n        </dependency>\n```\n## YML配置\n> 将Sentinel配置进Nacos中\n```yml\nspring:\n  cloud:\n     sentinel: \n        datasource:\n          ds1:\n            nacos:\n              server-addr: localhost:8848\n              dataId: ${spring.application.name}\n              groupId: DEFAULT_GROUP\n              data-type: json\n              rule-type: flow\n```\n\n> 需要手动写进Nacos\n>* 在Nacos中需要新建一个配置文件s\n>* 配置文件名DataId就是Sentinel的实例服务名\n>* 配置文件的内容是Json格式\n```json\n[\n    {\n        \"resource\": \"/rateLimit/byUrl\",\n        \"limitApp\": \"default\",\n        \"grade\": 1,\n        \"count\": 1,\n        \"strategy\": 0,\n        \"controlBehavior\": 0,\n        \"clusterMode\": false\n    }\n]\n```\n**解释如下:**\n![json](http://xtzl.wentexl.cn/json.png)","categories":["Service_degradation"],"tags":["Sentinel"]},{"title":"MQ","url":"/posts/44276/","content":"> 总结了关于消息中间件MQ 的知识点\n<!--more-->\n# 核心:四大天王\n>* RabbitMQ\n>* RocketMQ\n>* ActiveMQ\n>* Kafka\n\n# 引入依赖\n```xml\n        <!--添加消息总线RabbitMQ支持来实现广播-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n        </dependency>\n```\n# client和Config端都需要添加yml的MQ的相关支持\n```yml\n#rabbitmq相关配置\nrabbitmq:\n  host: localhost\n  port: 5672\n  username: guest\n  password: guest\n\n```\n# 只需要发送一次，则client端处处生效\n> **中心Config端 多增加如下MQ配置，include改为:bus-refresh**\n```yml\n##rabbitmq相关配置,暴露bus刷新配置的端点\nmanagement:\n  endpoints: #暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: 'bus-refresh'\n\n```\n\n# 运维发送全体通知和精确通知\n> * 全体通知：  \n> localhost:3344/actuator/bus-refresh  \n> 其中，3344指的是中心Config端的端口号\n>- - -\n>* 精确通知：  \n>localhost:3344/actuator/bus-refresh/config-client:3366  \n>其中，config-client指的是config的服务名称，3366是实例的端口号\n> - - -\n\n> 以上是利用RabbitMQ来实现动态刷新Config的优化\n>- - -\n# SpringCloud Stream\n> **重点**  \n>* 凡是涉及到监控、刷新的，必须要引入actuator这个依赖\n>* 消费端不同的组可以存在重复消费\n>* 消费端同一个组不能存在重复消费\n>* 不做处理的默认每个接收的实例都是一个组\n>* 消费端group属性十分重要，因为这个属性既可以解决重复消费，又可以解决消息持久化\n>- - -\n> **核心设计思想**  \n>*  SpringCloud Stream是一个构建消息驱动微服务的框架，应用程序通过inputs或者 outputs来与SpringCloud Stream中的binder进行交互，我们可以通过配置来binding ，而 SpringCloud Stream 的binder负责与中间件交互\n>*  SpringCloud Stream由一个中间件中立的核组成，应用通过SpringCloud Stream插入的input(相当于消费者consumer，它是从队列中接收消息的)和output(相当于生产者producer，它是发送消息到队列中的)通道与外界交流\n>*  Binder是SpringCloud Stream的一个抽象概念，是应用与消息中间件之间的粘合剂，目前SpringCloud Stream实现了Kafka和RabbitMQ的binder通过binder，可以很方便的连接中间件，可以动态的改变消息的destinations（对应于 Kafka的topic，RabbitMQ的exchanges），这些都可以通过外部配置项来做到，甚至可以任意的改变中间件的类型但是不需要修改一行代码\n\n## 架构图1\n![alt](http://xtzl.wentexl.cn/%E7%BC%96%E7%A0%81API.png)\n## 架构图2\n![alt](http://xtzl.wentexl.cn/SCS%E6%9E%B6%E6%9E%84%E5%9B%BE2.png)\n\n## Stream的yml文件配置\n> **消息生产者(生产端)：**\n```yml\nserver:\n  port: 8801\n\nspring:\n  application:\n    name: cloud-stream-provider\n  cloud:\n    stream:\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\n        defaultRabbit: # 表示定义的名称，用于于binding整合\n          type: rabbit # 消息组件类型\n          environment: # 设置rabbitmq的相关的环境配置\n            spring:\n              rabbitmq:\n                host: localhost\n                port: 5672\n                username: guest\n                password: guest\n      bindings: # 服务的整合处理\n        output: # 这个名字是一个通道的名称\n          destination: studyExchange # 表示要使用的Exchange名称定义\n          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”\n          default-binder: defaultRabbit  # 设置要绑定的消息服务的具体设置\n\neureka:\n  client: # 客户端进行Eureka注册的配置\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: send-8802.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为IP地址\n\n```\n>- - -\n> **消息接收者(消费端)**\n```yml\nserver:\n  port: 8803\n\nspring:\n  application:\n    name: cloud-stream-consumer\n  cloud:\n    stream:\n      binders: # 在此处配置要绑定的rabbitmq的服务信息；\n        defaultRabbit: # 表示定义的名称，用于于binding整合\n          type: rabbit # 消息组件类型\n          environment: # 设置rabbitmq的相关的环境配置\n            spring:\n              rabbitmq:\n                host: localhost\n                port: 5672\n                username: guest\n                password: guest\n      bindings: # 服务的整合处理\n        input: # 这个名字是一个通道的名称\n          destination: studyExchange # 表示要使用的Exchange名称定义\n          content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain”\n          default-binder: defaultRabbit # 设置要绑定的消息服务的具体设置\n          group: atguiguA\n\neureka:\n  client: # 客户端进行Eureka注册的配置\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n  instance:\n    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）\n    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）\n    instance-id: receive-8803.com  # 在信息列表时显示主机名称\n    prefer-ip-address: true     # 访问的路径变为IP地址\n\n```\n\n## 业务层配置\n> **消息生产者(生产端)：**  \n> 仅仅是发送消息到消息队列而已\n> 其中关键注解是： @EnableBinding(Source.class)\n```java\n@RestController\npublic class SendMessageController\n{\n    @Resource\n    private IMessageProvider messageProvider;\n\n    @GetMapping(value = \"/sendMessage\")\n    public String sendMessage()\n    {\n        return messageProvider.send();\n    }\n\n}\n------------------------下面是Service层-------------------------------\n@EnableBinding(Source.class) //定义消息的推送管道\npublic class MessageProviderImpl implements IMessageProvider\n{\n    @Resource\n    private MessageChannel output; // 消息发送管道\n\n    @Override\n    public String send()\n    {\n        String serial = UUID.randomUUID().toString();\n        output.send(MessageBuilder.withPayload(serial).build());\n        System.out.println(\"*****serial: \"+serial);\n        return null;\n    }\n}\n```\n\n> **消息接收者(消费端)：**  \n> 从消息队列中取得信息\n> 其中关键注解是: @EnableBinding(Sink.class)\n```java\n@Component\n@EnableBinding(Sink.class)\npublic class ReceiveMessageListener {\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @StreamListener(Sink.INPUT)\n    public void input(Message<String> message) {\n        System.out.println(\"port:\" + serverPort + \"\\t接受：\" + message.getPayload());\n    }\n\n}\n```\n# 消息持久化\n> 消息持久化主要是依靠yml配置中binder下的input下的group属性，当停机之后如果消息队列中有消息在流通，配置了group属性的实例，重启之后仍然能够收到消息，如果没配置的话，将会错过消息","categories":["Service_MQ"],"tags":["MQ","SpringCloud-Stream"]},{"title":"Cloud_Config","url":"/posts/8012/","content":"> 主要总结和介绍了SpringCloud的常用配置\n<!--more-->\n> 要测试的话，也要在Windows的host文件做修改：127.0.0.1 config-3344.com\n> 测试链接：http://config-3344.com:3344/main/config-dev.yml\n# 主启动类注解引入\n```java\n@EnableConfigServer\n```\n# 依赖引入\n```xml\n   <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-config-server</artifactId>\n        </dependency>\n```\n# 中心Config的yml 配置\n```yml\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://gitee.com/mx0425/springcloud-config.git #GitHub上面的git仓库名字\n          ####搜索目录\n          search-paths:\n            - springcloud-config\n      ####读取分支\n      label: master\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n\n```\n# Client端Config的yml配置\n```yml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: main #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址k\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n```\n# Client端手动版动态刷新\n>**Controller层**\n```java\n类名上添加注解\n@RefreshScope\n```\n```yml\n# 暴露监控端点: 实现动态刷新用的\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n\n```\n>* **localhost:3355/actuator/refresh** \n>* 此时需要发一个如上的固定的post请求来刷新，这种方式只能针对单个的端口，下例就是3355这个端口进行刷新。\n>- - -\n>* 这样显然有**弊端**：假如有多个微服务客户端3355/3366/3377。。。。每一个都要手动去刷新岂不是很麻烦？？  \n>- - -\n>**优化**: 通过广播，一次通知，处处生效  \n>**广播设计思想**: 广播通知的是中心config  \n\n> 具体优化思想，见博文 Cloud_MQ\n\n\n","categories":["Serice_Config"],"tags":["SpringCloudConfig"]},{"title":"GateWay","url":"/posts/4296/","content":">对服务网关GateWay的知识总结\n<!--more-->\n# 核心与注意点\n>* GateWay作为网关也需要注册进注册中心\n>* 路由、断言、过滤器\n>* 网关不能部署在Tomcat、Jetty等Servlet容器里，只能打成jar包执行\n>* ​依赖于netty和WebFlux \n>* GateWay不能加Web的起步依赖的jar包\n\n# 架构图\n![alt](http://xtzl.wentexl.cn/%E6%9E%B6%E6%9E%84%E5%9B%BE.png)\n# 依赖导入\n```xml\n      <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-gateway</artifactId>\n        </dependency>\n```\n# 第一种配置方法：yml配置\n```yml\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n       #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名\n        - id: payment_routh\n          #uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/get/**         # 断言，路径相匹配的进行路由\n         #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n        - id: payment_routh2\n         # uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/lb/**         # 必须是真正提供服务的方法 \n         #- After=2020-05-13T21:55:10.016+08:00[Asia/Shanghai]\n         # -Before\n         # -Between=2020-05-13T21:55:10.016+08:00[Asia/Shanghai],2021-05-13T21:55:10.016+08:00[Asia/Shanghai]\n         #- Cookie=username,milo\n         #- Header=X-Request-Id, \\d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client: #服务提供者provider注册进eureka服务列表内\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultZone: http://eureka7001.com:7001/eureka\n\n```\n\n# 第二种配置方法：Config配置\n> 当访问/guonei的时候，自动转发到http://news.baidu.com/guonei\n```java\n   @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)\n    {\n        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();\n        routes.route(\"path_route_atguigu\",\n                r -> r.path(\"/guonei\")\n                        .uri(\"http://news.baidu.com/guonei\")).build();\n        return routes.build();\n    }\n\n```\n# yml配置的时候，断言选项\n![断言](http://xtzl.wentexl.cn/GateWay%E6%96%AD%E8%A8%80.png)\n\n# curl开发\n>*  判断是否携带名为X-Request-Id的请求头，且其值必须是一个大于0的整数  \n>* -Header=X-Request-Id, \\d+   \n>* curl http://localhost:9527/payment/lb -H \"X-Request-Id:123\"\n>- - -\n>* 判断请求是否携带cookie名为username，值为milo\n>*  -Cookie = username,milo\n>* curl http://localhost:9527/payment/lb --cookie \"username=123\"\n\n# 自定义过滤器\n> 主要是要实现GlobalFilter,Ordered这两个接口\n```java\n@Component\n@Slf4j\npublic class MyLogGateWayFilter implements GlobalFilter,Ordered\n{\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain)\n    {\n        log.info(\"***********come in MyLogGateWayFilter:  \"+new Date());\n        String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\");\n        if(uname == null)\n        {\n            log.info(\"*******用户名为null，非法用户，o(╥﹏╥)o\");\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\n            return exchange.getResponse().setComplete();\n        }\n        return chain.filter(exchange);\n    }\n    @Override\n    public int getOrder()\n    {\n        return 0;\n    }\n}\n```","categories":["Service_Gateway"],"tags":["GateWay"]},{"title":"JavaUtils","url":"/posts/13372/","content":">主要介绍了Java的各种工具类\n<!--more-->\n# IdUtil\n>* 主要介绍了各种id生成策略\n>* 生成的Id是用不重复的 \n>* String serialNumber = IdUtil.simpleUUID();\n\n# TimeUnit\n>* TimeUnit.DAYS //天  \n>* TimeUnit.HOURS //小时  \n>* TimeUnit.MINUTES //分钟  \n>* TimeUnit.SECONDS //秒  \n>* TimeUnit.MILLISECONDS //毫秒  \n>* TimeUnit.NANOSECONDS //毫微秒  \n>* TimeUnit.MICROSECONDS //微秒  \n>- - -\n>**转换：**\n>* public long toMillis(long d)    //转化成毫秒  \n>* public long toSeconds(long d)  //转化成秒  \n>* public long toMinutes(long d)  //转化成分钟  \n>* public long toHours(long d)    //转化成小时  \n>* public long toDays(long d)     //转化天   \n>- - -\n>**延时：** \n>* TimeUnit.SECONDS.sleep( 5 );\n>* TimeUnit.HOURS.sleep(1);\n\n# ZoneDateTime\n>* ZoneDateTime.now();可以获得当前时间串，在gateway中可以配置使用\n\n# 产生随机数的2种方法\n>两者均是左开右闭\n```java\n// 产生1~3的随机数\n System.out.println((int) (Math.random()*3) +1);\n // 产生0~20的随机数\n System.out.println(new Random().nextInt(20));\n```","categories":["JavaStudy"],"tags":["JavaUtils"]},{"title":"Cloud_Hystrix","url":"/posts/64571/","content":">Hystrix属于服务降级部分，这里将会详细介绍关于Hystrix的相关知识\n<!--more-->\n# Hystrix介绍\n>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等。  \n>Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。  \n>- - -\n>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控(类似熔断保险丝)，向调用方返回—个符合预期的、可处理的备选响应(FallBack)。  \n>而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n\n# Hystrix核心\n> * 服务降级\n> * 服务熔断\n> * 接近实时的监控\n\n# 依赖导入\n```xml\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n        </dependency>\n```\n>- - -\n# 服务降级----------------\n# 服务提供端8001设置fallbcakMethod兜底\n>- - -\n>主启动类添加注解，开启断路器功能\n```java\n@EnableCircuitBreaker\n```\n>- - -\n> 解释：  \n>* 业务层添加。如果paymentInfo_TimeOut()在规定的3s内执行失败，则立即访问   paymentInfo_TimeOutHandler()方法作为fallbackMethod方法  \n> * 只要是当前服务不可用了，马上做服务降级\n> * 如果是在服务端配置的服务降级，不能通过80端口回调，只能自测\n```java\n    @HystrixCommand(fallbackMethod = \"paymentInfo_TimeOutHandler\",\n    commandProperties = {\n        @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"3000\")})\n    public String paymentInfo_TimeOut(Integer id)\n    {\n        try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }\n        return \"线程池:  \"+Thread.currentThread().getName()+\" id:  \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\"+\"  耗时(秒): 5\";\n    }\n\n    public String paymentInfo_TimeOutHandler(Integer id)\n    {\n        return \"线程池:  \"+Thread.currentThread().getName()+\"  8001系统繁忙或者运行报错，请稍后再试,id:  \"+id+\"\\t\"+\"o(╥﹏╥)o\";\n    }\n\n```\n\n# 客户端80设置fallbackMethod\n>主启动类添加注解  \n> 其中@EnableHystrix中也包含了@EnableCircuitBreaker\n```java\n@EnableHystrix\n```\n>- - -\n>客户端yml中的配置  \n\n```yml\nfeign:\n  hystrix:\n  #如果处理自身的容错就开启。开启方式与生产端不一样。\n    enabled: true \n```\n>通用fallback方法 :  \n\n> 若单个方法有具体指明fallback方法，则使用其具体的方法\n```java\n// hystrix 全局fallback方法标注在Controller的类头\n@DefaultProperties(defaultFallback = \"payment_Global_FallbackMethod\")\npublic class OrderFeignController{}\n```\n\n# 客户端80解决代码冗余和膨胀\n> 这样写的话，就不需要在Controller层进行指定了\n> 这样写的优先级仍然大于DefaultProperties的优先级\n```java\n// 在service层的注解添加fallback\n@FeignClient(value = \"cloud-provider-hystrix-payment\",fallback = PaymentFallbackServiceImpl.class)\n```\n```java\n// 书写service层的实现类\n@Component\npublic class PaymentFallbackServiceImpl implements PaymentFeignService {}\n```\n>- - -\n# 服务熔断-----------------------------------\n>## 核心\n> * 服务降级--熔断--慢慢恢复调用电路  \n>- - -\n\n\n> # 服务端\n> ## Controller层\n```java\n  //====服务熔断\n    @GetMapping(\"/payment/circuit/{id}\")\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id)\n    {\n        String result = paymentService.paymentCircuitBreaker(id);\n        log.info(\"****result: \"+result);\n        return result;\n    }\n```\n>## Serice层\n\n```java\n //=====服务熔断\n    @HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\",commandProperties = {\n        // 是否开启断路器v\n        @HystrixProperty(name = \"circuitBreaker.enabled\",value = \"true\"),\n        // 请求次数\n        @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),\n         // 时间窗口期，在这个时间以内，请求次数达到多少后跳闸\n        @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),\n        // 失败率达到多少后跳闸\n        @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\",value = \"60\"),\n    })\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id)\n    {\n        if(id < 0)\n        {\n            throw new RuntimeException(\"******id 不能负数\");\n        }\n        // 使用工具包生成流水号\n        String serialNumber = IdUtil.simpleUUID();\n\n        return Thread.currentThread().getName()+\"\\t\"+\"调用成功，流水号: \" + serialNumber;\n    }\n    public String paymentCircuitBreaker_fallback(@PathVariable(\"id\") Integer id)\n    {\n        return \"id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: \" +id;\n    }\n\n```\n\n# Hystrix断路器总结\n## 熔断需要依靠断路器\n![断路器](http://xtzl.wentexl.cn/%E6%96%AD%E8%B7%AF%E5%99%A8.png)\n\n## 断路器开启或关闭的条件\n>* 当满足一定的阀值的时候(默认10秒内超过20个请求次数)\n>* 当失败率达到一定的时候( 默认10秒内超过50%的请求失败)\n>* 到达以上阀值，断路器将会开启\n>* 当开启的时候，所有请求都不会进行转发\n>* 一段时间之后(默认是5秒)，这个时候断路器是半开状态，会让其中-一个请求进行转发。\n>* 如果成功，断路器会关闭，若失败，继续开启。\n\n# HystrixDashboard\n## 监控图详解\n![监控图](http://xtzl.wentexl.cn/%E7%9B%91%E6%8E%A7%E5%9B%BE.png)\n## 监控数据详解\n![监控数据](http://xtzl.wentexl.cn/%E7%9B%91%E6%8E%A7%E5%9B%BE%E6%95%B0%E6%8D%AE.png)","categories":["Service_degradation"],"tags":["Hystrix"]},{"title":"Cloud_OpenFeign","url":"/posts/40393/","content":">主要记录了关于OpenFeign的知识\n<!--more-->\n\n# 核心\n>* 微服务接口 + @FeignClient\n>* Feign自带负载均衡配置项，默认支持Ribbon\n>* OpenFeign默认等待1秒钟，之后将会报超时错误\n>* 面向接口编程\n>* 主要就是在80端口多了一层Service\n>* 在Service层这里直接使用注解而不使用RestTemplate\n>* 更加方便和简洁\n>* @FeignClient()接口类中，使用@RequestParam时必须指定value\n>* Feign和热部署有可能会冲突，且在使用的时候，要注意接口层的参数是否有在请求体内的，如果没表明是否在请求体，会导致调用失败，如果在请求体，就要更换httpclient的依赖，否则可能会出现Get请求被自动转成Post请求的情况\n\n\n# 依赖引入\n```xml\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-openfeign</artifactId>\n        </dependency>\n```\n# 主启动类\n```java\n@EnableFeignClients\n```\n# 80端微服务接口\n**Serice端**\n```java\n@Component\n@FeignClient(value = \"cloud-payment-service\")\npublic interface PaymentFeignService\n{\n    // 这里面的GetMapping是指的是服务实例中的方法的路径，并且会自动将获取到的路径变量加到路径中去\n    @GetMapping(value = \"/payment/get/{id}\")\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id);\n}\n```\n**Controller端**\n```java\npublic class OrderFeignController\n{\n    @Resource\n    private PaymentFeignService paymentFeignService;\n    @GetMapping(value = \"/consumer/payment/get/{id}\")\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id)\n    {\n        return paymentFeignService.getPaymentById(id);\n    }\n\n}\n```\n\n# 设置超时时间\n```yml\n#设置feign客户端超时时间(OpenFeign默认支持ribbon)\nribbon:\n  #指的是建立连接所用的时间，适用于网络状况正常的情况下, 两端连接所用的时间\n  ReadTimeout: 5000\n  #指的是建立连接后从服务器读取到可用资源所用的时间\n  ConnectTimeout: 5000\n```\n# 设置OpenFeign的日志\n## 自定义Config类，加入Bean设置日志级别\n```java\n@Configuration\npublic class FeignConfig\n{\n    @Bean\n    Logger.Level feignLoggerLevel()\n    {\n        return Logger.Level.FULL;\n    }\n}\n```\n## 在yml配置中设置日志的监控接口\n```yml\nlogging:\n  level:\n    # feign日志以 debug 级别监控 com.atguigu.springcloud.service.PaymentFeignService 接口，debug级别会直接在控制台console中打印出来\n    xtzl.ljw.service.PaymentFeignService: debug\n```\n","categories":["Service_invoke"],"tags":["OpenFeign"]},{"title":"Cloud_Sleuth","url":"/posts/15024/","content":"> 分布式请求链路跟踪  :   \n> 总结了Springcloud-Sleuth的相关知识\n<!--more-->\n# zipkin  \n>* 安装使用jar包，然后直接敲 java -jar xxx.jar 这个命令就好\n>* 图形化界面端口号9411  \n\n**链路图:**\n![链路图](http://xtzl.wentexl.cn/Sleuth%E5%9B%BE.png)\n>* span 表示链路来源：通俗来说 span 就是一次请求信息\n>* Trance 类似于树结构的Span集合，表示一条调用链路，存在唯一标识\n\n**依赖引入**\n```xml\n     <!--包含了sleuth+zipkin-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zipkin</artifactId>\n        </dependency>\n```\n**yml配置**\n> yml解释：\n>* base-url: 监控的数据需要发到9411上去  \n>* 采样率一般0.5就够了，表示只需要一半的数据就好\n```yml\nspring:\n    zipkin:\n        base-url: http://localhost:9411\n    sleuth:\n        sampler:\n        #采样率值介于0到1之间，1则表示全部采集\n        probability: 1\n```\n\n","categories":["Service_Sleuth"],"tags":["Sleuth"]},{"title":"Ribbon","url":"/posts/49475/","content":"> 整理了关于Ribbon的相关知识\n<!--more-->\n# 核心\n>* 主要核心就是负载均衡\n\n# 依赖引入\n```xml\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n      <version>2.2.1.RELEASE</version>\n      <scope>compile</scope>\n    </dependency>\n```\n# Ribbon的核心组件IRule七种负载均衡的选择方式\n>- - -\n>(出厂默认)RoundRobinRule： 轮询，轮流访问不同的实例\n>- - -\n>RandomRule : 随机，随机访问不同的实例\n>- - -\n>RetryRule:  \n先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内进行重试，获取可用的服务。\n>- - -\n>WeightedResponseTimeRule:  \n对RoundRobinRule的扩展，响应速度越快的实例选择权重就越大，越容易被选择。\n>- - -\n>BestAvailableRule:  \n会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务。\n>- - - \n>AvailabilityFilteringRule:  \n先过滤掉故障实例，再选择并发较小的实例。\n>- - -\n>ZoneAvoidanceRule:  \n>默认规则，复合判断server所在区域的性能和server的可用性选择服务器。\n>- - -\n# Ribbon修改负载均衡的方式\n> **一定不能在主配置类可以扫到的包下，必须新建一个主配置类扫不到的包**\n> 注意点：  \n> * 注解里的服务名要小写\n> * 配置类名不能是MyRule，否则报错\n```java\n// IRule配置类添加\n@Configuration\npublic class MySelfRule {\n    @Bean\n    public IRule myrule(){\n        // 修改为随机方式\n        return new RandomRule(); \n    }\n}\n\n//80端口主运行类注解添加\n//其中name表示的是微服务名称\n@RibbonClient(name = \"cloud-payment-service\",configuration = MySelfRule.class)\n```\n# Ribbon的轮询算法\n> rest接口的第几次请求数 % 服务器集群实例数量 = 实际调用的服务器(实例)的下标\n```java\n// 获取指定服务的所有实例集合\n List<ServiceInstance> instances = discoveryClient.getInstances(\"consul-provider-payment\");\n 例如：\n instances[0]=127.0.0.1:8001\n instances[1]=127.0.0.1:8002\n\n```\n\n\n\n","categories":["Service_invoke"],"tags":["Ribbon"]},{"title":"Consul","url":"/posts/29713/","content":">总结了关于Consul的相关知识点\n<!--more-->\n# 小知识\n>* 启动consul可以配置环境变量\n>* consul agent -dev 命令来启动consul\n>* Consul的首页： http://localhost:8500\n\n# 依赖导入\n```xml\n   <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n        </dependency>\n```\n# application.yml 配置\n```yml\n###consul服务端口号\nserver:\n  port: 8006\n\nspring:\n  application:\n    name: consul-provider-payment\n  ####consul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n\n```\n# 主启动类\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\n```\n\n","categories":["Service_Registry"],"tags":["Consul"]},{"title":"LinuxWords","url":"/posts/17418/","content":">总结了一些关于linux的操作命令\n<!--more-->\n\n># SCP命令\n>## 将本地linux服务器的文件拷贝到远程的linux服务器上\n```linux\nscp  /root/file1.txt  username@202.202.146.245:/home/S12004060119/\n```\n>## 将远程linux的文件拷贝到自己的linux本地服务器\n```linux\nscp  username@202.202.146.245:/home/S12004060119/file.txt /root/sh/\n```\n>## 把本地Windows系统的文件夹传到远程linux服务器上\n```linux\nscp -P 22 -r E:\\weixin\\ S12004060119@202.202.146.245:/home/S12004060119/\n```\n># 快捷键\n>Ctrl+l  ：清屏  \nCtrl+o ：执行当前命令，并选择上一条命令  \nCtrl+s ：阻止屏幕输出  \nCtrl+q ：允许屏幕输出  \nCtrl+c ：终止命令  \nCtrl+z ：挂起命令  \nCtrl+d ：输入结束，即EOF的意思，或者注销linux系统\n\n\n# 基本命令\n>* pwd命令  \n>查看当前用户所在的路径\n>* passwd命令  \n>格式： passwd 用户名\n>给用户指定密码\n>* init 命令  \n>Int 3：字符界面\n>Int 5：图形界面\n>* set nu 命令  \n>set nu表示设置行号\n>set nonu表示取消行号\n>* cat命令  复制文件  \n>Cat file1.txt>>file2.txt\n>* cp复制  \n>cp file1.txt /*/*/*\n>* mv命令  \n>mv a b 实现重命名  \n>mv 文件名 移动目的地后的文件名  \n>mv 文件名 修改后的文件名\n","categories":["command"],"tags":["linux"]},{"title":"GitWords","url":"/posts/33301/","content":">记录了git的常用命令\n<!--more-->\n# Git颜色\n>* 红褐色：创建之后没有add，没提交，不在版本控制范围之内，这时候文件是红褐色的，需要先add文件；\n>* 绿色：add之后是文件绿色的，没有提交（commit）;\n>* 蓝色：原本拉取过来之后就有一个文件，改动过后没有提交（commit）是蓝色的，提交之后，变成正常颜色。\n# Git常用操作命令\n>* git ls-files 查看暂存区文件\n>- - -\n>* git init 初始化仓库\n>- - -\n>* git add . 添加所有文件进暂存区\n>- - -\n>* git commit 提交到本地仓库\n>- - -\n>* git push 推送到远程仓库\n>- - -\n>* git pull 从远程仓库拉取最新代码\n>* git pull origin main // 从origin远程仓库拉取分支main的代码到本地的当前分支\n>* git pull -rebase\n>- - -\n>* git checkout -b master 新建一个master分支\n>- - -\n>* git branch -al 查看所有本地分支\n>- - -\n>* git checkout 本地分支名 切换到其他的本地分支\n>- - -\n>* git remote add origin git@github.com:xxxx/xx.git //origin是自定义的远程库的名字，这是给本地仓库添加远程仓库\n>- - -\n>* git remote rm origin 与远程仓库解绑\n>- - -\n>* git remote -v 查看远程仓库的相关信息\n>- --\n>* git push -u origin master  //把当前分支master推送到远程；远程库是空的，所以第一次push加上-u参数；不仅推送了且两个master分支相关联，后续push命令简化git push origin master\n>* git push origin master:main //把本地的master分支上传到origin远程仓库的main分支去\n>* git push origin main // 当且仅当本地分支和远程分支名相同的时候可以直接这样push\n>- - -\n>* git clone git@github.com:lengnuann/L.git xtzl/ljw/ 克隆指令将远程仓库的代码克隆到本地的xtzk/ljw这个文件夹之下\n>- - -\n>* git log 查看日志\n>- - -\n>* git branch --set-upstream-to origin/main master 关联分支，将远程仓库的main分支和master相关联，如果执行失败，先去IDEA的Git下的Pull中获取分支，多刷新一下\n>- - -\n>* git stash 暂存工作区的内容\n>- - -\n>* git stash pop 恢复暂存的工作区内容\n>- - -\n>* git stash list 查询工作区所有stash的列表\n>- - -\n>* git stash apply 例如：git stash apply stash@{2} 表示指定stash@{2}这个暂存版本，如果不指定，则git stash pop默认恢复最新的一次stash\n>- - -\n>* git stash clear 清空stash\n>- - -\n>* git branch --set-upstream-to=gitee/master master :关联远程分支与本地分支，第二个master指的是第本地分支，gitee/master，指的是gitee设置远程仓库名，中的远程分支master,其中远程仓库必须有该分支\n>- - -\n>* git reset --hard 6b2b7aa ：强制回退到某个版本，将不会保存原来的代码（慎用！！！）\n>- - -\n>* git branch  --track  experimental  origin/experimental ：同样是追踪分支\n>* git branch -m master main 将matser分支更名为main分支 \n>- - - \n>* git config --global push.default simple  //设置默认行为为simple。 Git2.0以后\n >- - -\n >* git config --global push.default matching //设置默认行为为matching。Git2.0以前\n >- - -\n >* git reflog // 查看版本信息\n\n# 三种新建项目绑定gitee的远程仓库方式\n# git clone\n> 可以直接git clone远程仓库，就默认绑定clone的那个分支和本地的master分支了\n\n# git remote add -f url\n> 添加 -f 参数相当于执行一次git fetch操作，将会把远程的同名分支都绑定到本地的分支\n> 然后输入 git pull origin master,即可将远程origin的仓库中的master分支绑定拉取到当前分支，如果本地分支没有远程分支已有的分支，则自动在本地创建，但是这样做的弊端就是每次都要手动选择拉取远程仓库的哪一个分支\n\n# git remote add url \n> 执行完这个之后需要手动再执行一次 git fetch\n> git fetch 之后，会自动将远程仓库的同名分支与本地仓库进行匹配绑定，如果本地没有分支，则自动在本地新建同名分支并绑定。\n\n# 两个独立仓库的合并\n> 即便是远程仓库和本地仓库并没有历史相同版本点，也可以进行合并  \n>git pull origin master –allow-unrelated-histories\n> 如果合并失败，就只能使用rebase了\n> git pull --rebase origin master","categories":["command"],"tags":["git"]},{"title":"IDEA_Hotkeys","url":"/posts/10025/","content":"> IDEA的使用快捷键\n<!--more-->\n>**IDEA使用的快捷键**   \n\n>ctrl + D：复制上一行  \n>- - -\n>Ctrl+D: 同时也可以表示结束输入  \n>- - -\n>Shift + alt +↑（↓） ：上下移动某一行  \n>- - -\n>ctrl+/ ：注释  \n>- - -\n>ctrl+r : 查找和替换  \n>- - -\n>ctrl+alt+t: 抓异常快捷键  \n>- - -\n>shift连按两次：查询  \n>- - -\n>ctrl+alt+b：通过接口查看其实现类 \n>- - - \n>alt+insert+fn : 生成getter和setter方法  \n>- - -\n>ctrl+f: 搜索查看  \n>- - -\n>ctrl+a：一键全选  \n>- - -\n>shift+home:选中单行  \n>- - -\n>Ctrl+i:  选择实现方法  \n>- - -\n>Ctrl+Q: 查看上下文信息\n>- - -\n>shift+tab:取消缩进\n>- - -\n>Ctrl+alt+B: 显示实现类\n>- - -\n>Ctrl+shift+n : 查找类或者文件 \n>- - -\n>Ctrl + O : 快速重写\n>- - -\n>Ctrl + P : 查看参数\n>- - -\n>- - -\n>**调试**\n>* F8单步调试。不进入函数内部\n>- - -\n>* F7 单步调试 进入函数肉部\n>- - -\n>* Shift+F7 选择要进入的函数\n>- - -\n>* Shift+F8 跳出函数\n>- - -\n>* Alt+F9 运行到断点\n>- - -\n>* Alt+F8 执行表达式查看结果\n>- - -\n>* F9继续执行，进入下一个断点或执行完程序\n>- - -\n>* Ctr|+F8 设置/取消当前行断点\n>- - -\n>* Ctrl+Shift+F8 查看断点\n>- - -","categories":["IDEA"],"tags":["Hotkeys"]},{"title":"Eureka","url":"/posts/57702/","content":">关于EureKa的知识笔记：Eureka的服务注册与发现\n<!--more-->\n# 小知识\n> * Eureka不用自己注册自己\n> * 注意启动顺序，服务端必须先启动才能检索到客户端\n> * 集群配置：互相注册，相互守望\n> * 配置host之后记得在cmd使用ipconfig /flushdns刷新一下\n> * 大坑！！！:配置集群之后，直接点击链接是访问不了的！！多了一层路径！必须要手动输入地址!\n> * defaultZone如果有多个url，不同的url通过逗号隔开\n\n># 依赖引入\n>## 服务注册端 server\n```xml\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n        </dependency>\n```\n>## 客户端 client\n```xml\n         <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n```\n\n># 单机版在Application.yml中配置\n>## 单机版在server端中的yml配置\n```yml\neureka:\n instance:\n   hostname: localhost  #eureka服务端的实例名字\n client:\n   register-with-eureka: false    #表示不向注册中心注册自己\n   fetch-registry: false   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\n   service-url:\n     #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n     defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\n```\n>## 单机版在client端的yml配置\n```yml\neureka:\n  client:\n    #表明自己需要注册进Eureka中\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有信息，默认为true。\n    #单节点无所谓，集群的话必须设置为true才能配合ribbon使用负载均衡\n    fetch-registry: true\n    service-url:\n      #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n      #单机指向自己\n      defaultZone: http://localhost:7001/eureka\n\n```\n\n\n> # 集群版在Application.xml中的配置\n> ## 在Client端的yml配置\n>- - -\n> 最主要的在于defalutZone的变化  \n> eureka7001.com是host文件配置的主机名\n> \n```yml\neureka:\n  client:\n    register-with-eureka: true\n    fetch-registry: true\n    service-url:\n    #集群指向所以注册中心的eureka\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n```\n>## 在Server端的yml配置\n```yml\neureka:\n  instance:\n    hostname: eureka7002.com  #eureka服务端的实例名字\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n    service-url:\n    #集群指向其他eureka\n      defaultZone: http://eureka7001.com:7001/eureka\n```\n\n># 在主运行类中的注解标识\n>## Server端使用的主键\n```java\n@EnableEurekaServer\n```\n>## Client端使用的注解\n```java\n@EnableEurekaClient\n```\n\n># 服务发现\n> 将服务信息放到到注册中心去  \n> 通过服务发现来活动该服务的信息\n```java\n    // Controller 添加\n    @Resource\n    private DiscoveryClient discoveryClient;\n    \n    // 主运行类添加\n    @EnableDiscoveryClient\n```\n\n# Instance配置\n```yml\n  instance:\n    # 微服务下实例名称修改\n    instance-id: payment8002\n    # 显示IP地址\n    prefer-ip-address: true\n```\n># Eureka的自我保护机制\n>自我保护机制:默认情况下EurekaClient定时向EurekaServer端发送心跳包  \n如果Eureka在server端在一定时间内(默认90秒)没有收到EurekaClient发送心跳包 ,便会直接从服务注册列表中剔除该服务  \n>但是在短时间( 90秒中)内丢失了大量的服务实例心跳,\n这时候EurekaServer会开启自我保护机制,不会剔除该服务(该现象可能出现在网络不通的情况使得 EurekaClient为出现宕机  \n>此时如果换做别的注册中心如果一定时间内没有收到心跳会将剔除该服务,这样就出现了严重失误,因为客户端还能正常发送心跳只是网络延迟问题，而保护机制是为了解决此问题而产生的)\n\n># 关闭Eureka的自动保护机制\n>server端\n```yml\n## Server端的yml中设置关闭自我保护机制，保证不可用服务被及时踢除\neureka:\n  server:\n     enable-self-preservation: false\n     eviction-interval-timer-in-ms: 2000\n```\n>client端设置心跳响应时间\n```yml\neureka:\n  instance:\n#    Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\n   lease-renewal-interval-in-seconds: 1\n#    Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\n   lease-expiration-duration-in-seconds: 2\n```\n","categories":["Service_Registry"],"tags":["Eureka"]},{"title":"Cloud-summary","url":"/posts/42402/","content":">介绍和总结整个SpringCloud的理论体系\n# SpringCloud架构图\n![SpringCloud架构图](http://xtzl.wentexl.cn/SpringCloud%E6%9E%B6%E6%9E%84%E5%9B%BE.png)\n\n<!--more-->\n# 注册中心的异同点\n>## **CAP**\n>- - -\n>**解释**：  \n>C :(强一致性):   对某个指定的客户端来说，读操作保证能够返回最新的写操作结果。  \n>A :(可用性):     非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应)  \n>P :(分区容错性): 当出现网络分区后，系统能够继续“履行职责”。\n>- - -\n>* 分布式系统理论上不可能选择CA架构，只能选择CP或者AP 架构。\n>* CAP理论关注粒度是数据，而不是整个系统的设计策略\n>* AP(Eureka) ; CP(Consul) ; HA(高可用，也是Eureka)  \n>![CAP](http://xtzl.wentexl.cn/SpringCloud/CAP.png)\n\n\n# SpringCloud总图\n![总图](http://xtzl.wentexl.cn/SpringCloud.png)\n\n\n","categories":["SpringCould"],"tags":[]},{"title":"dependencies","url":"/posts/18669/","content":"> 该博文主要记录了在Cloud微服务开发中常用的依赖\n\n# 父工程\n```xml\n<!-- 统一管理jar包版本 -->\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n        <junit.version>4.12</junit.version>\n        <log4j.version>1.2.17</log4j.version>\n        <lombok.version>1.16.18</lombok.version>\n        <mysql.version>5.1.47</mysql.version>\n        <druid.version>1.1.16</druid.version>\n        <mybatis.spring.boot.version>1.3.0</mybatis.spring.boot.version>\n    </properties>\n\n    <!-- 1、只是声明依赖，并不实际引入，子项目按需声明使用的依赖 -->\n    <!-- 2、子项目可以继承父项目的 version 和 scope -->\n    <!-- 3、子项目若指定了 version 和 scope，以子项目为准 -->\n    <dependencyManagement>\n        <dependencies>\n            <!--spring boot 2.2.2-->\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-dependencies</artifactId>\n                <version>2.2.2.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <!--spring cloud Hoxton.SR1-->\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Hoxton.SR1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <!--spring cloud alibaba 2.1.0.RELEASE-->\n            <dependency>\n                <groupId>com.alibaba.cloud</groupId>\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n                <version>2.1.0.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n\n<!-- 以上依赖不能出现在子工程 -->\n\n\n            <dependency>\n                <groupId>mysql</groupId>\n                <artifactId>mysql-connector-java</artifactId>\n                <version>${mysql.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.alibaba</groupId>\n                <artifactId>druid</artifactId>\n                <version>${druid.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>org.mybatis.spring.boot</groupId>\n                <artifactId>mybatis-spring-boot-starter</artifactId>\n                <version>${mybatis.spring.boot.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>junit</groupId>\n                <artifactId>junit</artifactId>\n                <version>${junit.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>log4j</groupId>\n                <artifactId>log4j</artifactId>\n                <version>${log4j.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>org.projectlombok</groupId>\n                <artifactId>lombok</artifactId>\n                <version>${lombok.version}</version>\n                <optional>true</optional>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n\n# 子工程\n```xml\n\n    <dependencies>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/com.alibaba/druid -->\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid-spring-boot-starter</artifactId>\n            <version>1.2.8</version>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-jdbc</artifactId>\n        </dependency>\n           <!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n     </dependencies>\n```\n# 通用工程依赖\n```xml\n <dependencies>\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all -->\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-all</artifactId>\n            <version>5.1.0</version>\n        </dependency>\n</dependencies>\n\n```","categories":["dependencies"],"tags":["dependencies"]},{"title":"Configuration_header","url":"/posts/65104/","content":">在Web开发中，该博文对常用配置类的配置头进行了总结\n<!--more-->\n# Web开发常用配置头的总结\n\n>## Mabatis的 Mapper.xml 配置头\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"xtzl.ljw.Dao.PaymentMapper\">\n</mapper>\n``` \n \n>## Bean.xml 配置头\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n</beans>\n\n```","categories":["Configuration"],"tags":["Configuration_header"]},{"title":"Mabtis && MybatisPlus","url":"/posts/31024/","content":">总结了Mabtis和plus的一些小细节的知识\n<!--more-->\n\n# Mabatis&&Plus 小知识总结\n\n## type-aliases-package\n### type-aliases-package作用\n>在Mybatis的mapper.xml文件中resultType的type或者paramterType会返回自定义entity  \n此时可以用全类名名来指定这些实体。\n### type-aliases-package配置\n```yml\nmybatis:\n    type-aliases-package=xtzl.ljw.entities\n```\n\n## 指定Mapper路径\n```yml\nmybatis:\n    mapper-locations: classpath:mapper/*.xml\n```\n## useGeneratedKeys\n>在使用useGeneratedKeys=\"true\"后返回值是1，期待返回实体主键\n>insert方法返回值依然是修改行数  \n需要从传入的实体中取对应属性值。  \n比如user表对应User类，主键是id\n那么int i =insertUser（user）;  \n方法执行后 i 还是1\n但是user.getId();得到的值就是主键了\n>- - -\n>一般来说需要和 keyProperty=\"id\" 联用，意为指定主键\n\n# MybatisPlus配置\n","categories":["Mabtis_Plus"],"tags":["mabtis"]},{"title":"JavaNorms","url":"/posts/17711/","content":"> 在学习过程中，对一些常见的开发格式和开发规范，以及一些规范类进行了整理和总结\n<!--more-->\n\n# 规范类:\n## POJO 类\n```markdown\n\"Plain Ordinary Java Object\"，简单普通的java对象。主要用来指代那些没有遵循特定的java对象模型，约定或者框架的对象。\n\nPOJO的内在含义是指那些:\n有一些private的参数作为对象的属性，然后针对每一个参数定义get和set方法访问的接口。\n没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。\n```\n\n## JavaBean\n```markdown\nJavaBean 是一种JAVA语言写成的可重用组件。JavaBean符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。\n它的方法命名，构造及行为必须符合特定的约定:\n    · 所有属性为private。\n    · 这个类必须有一个公共的缺省构造函数。即是提供无参数的构造器。\n    · 这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范。\n    · 这个类应是可序列化的。实现serializable接口。\n\n因为这些要求主要是靠约定而不是靠实现接口，所以许多开发者把JavaBean看作遵从特定命名约定的POJO\n```\n# Rest风格详情介绍\n>* GET （常用于查询）\n>- - -\n>* POST（常用于保存）\n>- - -\n>* PUT（常用于更新修改）\n>- - -\n>* DELETE（常用于删除）\n\n## 传统风格: RequestMapping\n><![传统风格](http://xtzl.wentexl.cn/CT.png)  \n## Restful风格: 增删改查\n![Rest](http://xtzl.wentexl.cn/Rest%E9%A3%8E%E6%A0%BC.png)\n## 两种模式的区别：\n>**风格与规则的区别：**  \n>Restful风格要简洁了很多，并且把行为都隐藏了  \n风格是一种约定俗成的方式，这种约定并不是一定要遵守的，可以不去使用这种约定，即也可以使用传统风格。而规范呢是一种大家必须遵守的规则，你如果不按照这个规范来书写代码，那么就不被允许运行。  所以被叫做REST风格，而不是叫做REST规范。  \n\n\n","categories":["JavaStudy"],"tags":["JavaNorms"]},{"title":"S_Annotation","url":"/posts/54839/","content":"> 注解的使用\n<!--more-->\n\n# 常用注解的解释与使用\n\n## 与 SQL 有关的注解\n### @Param\n首先明确这个注解是为SQL语句中参数赋值而服务的。    \n\n @Param的作用就是给参数命名，比如在mapper里面某方法A（int id）  \n 当添加注解后A（@Param(\"userId\") int id）  \n 也就是说外部想要取出传入的id值，只需要取它的参数名userId就可以了。  \n 将参数值传如SQL语句中，通过#{userId}进行取值给SQL的参数赋值\n\n```SQL\nmapper:\npublic User selectUser(@Param(\"userName\") String name,@Param(\"password\") String pwd);\n\nxml:\n<select id=\"selectUser\" resultMap=\"User\">  \n   select * from user  where user_name = #{userName} and user_password=#{password}  \n</select>\n可发现，userName为映射名，相当于起的是个别名\n\n注意点：  \n·当使用了@Param注解来声明参数的时候，SQL语句取值使用#{}，${}取值都可以。\n·当不使用@Param注解声明参数的时候，必须使用的是#{}来取参数。使用${}方式取值会报错。\n·不使用 @Param注解时，参数只能有一个，并且是Javabean。在SQL语句里可以引用JavaBean的性，而且只能引用JavaBean的属性。\n\n\n实际上：\n即便是不使用这个注解，也可以直接通过#{}去访问NewUser的成员变量，也是可以的，但是也只能有一个参数，这个参数就只能是NewUser这个JavaBean对象\n    <insert id=\"insertN\" parameterType=\"xtzl.boot.bean.NewUser\">\n        insert into user (username,password,sex,status) values (#{username},#{password},#{sex},#{status})\n    </insert>\n\n```\n### TableField\n>@TableField(exist = false) 注解加载bean属性上，表示当前属性不是数据库的字段，但在项目中必须使用，这样在新增等使用bean的时候，mybatis-plus就会忽略这个，不会报错。\n```java\n    // 插入\n    @TableField(fill = FieldFill.INSERT)\n    private LocalDateTime createTime;\n    // 插入或更新的时候填充字段\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private LocalDateTime updateTime;   \n\nDEFAULT ：默认不处理\nINSERT ： 插入操作时进行填充字段\nUPDATE ：更新操作时填充字段\nINSERT_UPDATE ：插入和更新操作时填充字段\n\n\n```\n## @EnableWebSecurity\n>**EnableWebSecurity注解有两个作用**\n>* 1: 加载了WebSecurityConfiguration配置类, 配置安全认证策略。\n>* 2: 加载了AuthenticationConfiguration, 配置了认证信息。\n\n","categories":["Annotation"],"tags":["Annotation"]},{"title":"Maven_Write","url":"/posts/35182/","content":"\n> 关于Maven的一些小知识点\n<!--more-->\n\n# 直接手动从中央仓库下载依赖\n>## 地址：https://www.mvnrepository.com/\n>## 下载格式\n```markdown\n    mvn dependency:get -DremoteRepositories=https://mvnrepository.com/artifact/org.projectlombok/lombok -DgroupId=org.projectlombok -DartifactId=lombok -Dversion=1.18.12\n\n特别注意： 等号后面一定不能留空格，否则会出现找不到坐标的错误\n\n```\n# 坐标\n>注：groupId 在新建项目的时候可以自行指定，以便于在项目中新建通用模块之后导入其他模块\n> - - - \n> groupId和artifactId是maven管理项目包时用作区分的字段，就像是地图上的坐标。  \nartifactId：artifactId一般是项目名或者模块名。  \ngroupId：groupId分为几个字段，例如cn.com.fullstack，前面的com叫【域】，后面的是你自己起的域名。\n>- - -\n>groupId一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。  \n域又分为org、com、cn等等许多，其中org为非营利组织，com为商业组织。  \n举个apache公司的tomcat项目例子：这个项目的groupId是org.apache，它的域是org（因为tomcat是非营利项目），公司名称是apache，artigactId是tomcat。","categories":["maven"],"tags":["maven"]},{"title":"Cloud-Base","url":"/posts/52648/","content":"\n> SpringCould的学习随堂笔记\n\n<!--more-->\n\n# SpringCould 随堂笔记\n\n>## 父工程框架  \n  \n> ### 父工程统一管理Jar包\n```xml\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>12</maven.compiler.source>\n    <maven.compiler.target>12</maven.compiler.target>\n    <junit.version>4.12</junit.version>\n    <lombok.version>1.18.10</lombok.version>\n    <log4j.version>1.2.17</log4j.version>\n    <mysql.version>8.0.21</mysql.version>\n    <druid.version>1.0.9</druid.version>\n    <mybatis.spring.boot.version>2.2.2</mybatis.spring.boot.version>\n  </properties>\n```\n>### 必要依赖\n```xml\n    <dependencies>\n      <!--spring boot 2.2.2-->\n      <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-dependencies</artifactId>\n        <version>2.2.2.RELEASE</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      <!--spring cloud Hoxton.SR1-->\n      <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-dependencies</artifactId>\n        <version>Hoxton.SR1</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      <!--spring cloud alibaba 2.1.0.RELEASE-->\n      <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n        <version>2.1.0.RELEASE</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n\n```\n\n\n>## 子工程application配置文件\n### 数据源配置\n```yml\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: org.gjt.mm.mysql.Driver\n    url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&characterEncoding=utf-8&useSSL=false\n    username: root\n    password: root\n\n```\n### 唯一标识\n```yml\nspring:\n  application:\n    name: cloud-payment-service\n```\n## Devtools 开启热部署\n> 注：电脑不太行不建议开启，太锤子卡了\n>1. 导入jar包\n>2. 引spring-boot-maven-plugin插件\n>3. 在IDEA的Compile中调设置.\n>4. 重启IDEA\n\n\n## RestTemplate\n> 可用 订单80端口去调用8001端口的服务进行操作\n```java\n  @Bean\n    public RestTemplate getRestTemplate(){\n        return new RestTemplate();\n    }\n```\n> ### 两种方式：\n```java\n  // 第一种是写死的，第二种是URL为集群的服务名\n  // 微服务可能有多个端口\n   // public static final String PAYMENT_URL=\"http://localhost:8001\";\n    public static final String PAYMENT_URL=\"http://CLOUD-PAYMENT-SERVICE\";\n    @Resource\n    private RestTemplate restTemplate;\n\n    // GET请求实际上调用了POST请求\n    @GetMapping(\"/consumer/payment/create\")\n    public CommonResult<Payment> create(Payment payment){\n        return restTemplate.postForObject(PAYMENT_URL+\"/payment/create\",payment,CommonResult.class);\n    }\n\n    @GetMapping(\"/consumer/payment/get/{id}\")\n    public CommonResult<Payment> getPayment(@PathVariable(\"id\") Long id){\n        System.out.println(id);\n        log.info(String.valueOf(id));\n        return restTemplate.getForObject(PAYMENT_URL+\"/payment/get/\"+id,CommonResult.class);\n    }\n\n坑： 此处我使用@Pathgram 无法获取到路径变量\n```\n**细节**  \n>在微服务的Controller中，涉及到POST请求，一定不要忘记加@RequstBody这个注解，当80端口的请求到微服务端口的方法时\n```java\n    @PostMapping(\"/payment/create\")\n    public CommonResult create(@RequestBody Payment payment){\n    }\n```\n# 负载均衡\n> 微服务没被写死端口号的时候\n> 在配置类里面必须加 @LoadBalanced 才行\n> @LoadBalanced赋予RestTemplate负载均衡的能力:轮班值日\n```java\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate(){\n        return new RestTemplate();\n    }\n```\n>**RestTemplate返回对象选择**\n![RestTemplate返回](http://xtzl.wentexl.cn/restTemplate%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1.png)\n\n","categories":["SpringCould"],"tags":["SpringCould"]},{"title":"CppFunctions","url":"/posts/12049/","content":"> 总结了C++常用函数\n\n<!-- more-->\n\n># C++ 函数总结\n\n>## 判断大小写\n```Cpp\n//用来判断一个字符是否为字母，如果是字符则返回非零，否则返回零。\n 1.isalpha()\n\n//用来判断一个字符是否为数字或者字母，也就是说判断一个字符是否属于a~z||A~Z||0~9。是返回非零，不是返回0。\n2.isalnum()\n\n//用来判断一个字符是否为小写字母，也就是是否属于a~z。是返回非零，不是返回0。\n3.islower()\n\n//用来判断一个字符是否为大写字母。是返回非零，不是返回0。\n4.isupper()\n\n//a为字符时，如果a是小写字母则将其转换为大写字母，否则不变。a为数字则将其按ASCLL码转换为对应字符。（其实即使a是字符，输入之后还是会将其转换为int类型）\n5. char c = toupper(a)\n\n//a为字符时，如果a是大写字母则将其转换为小写字母，否则不变。a为数字则将其按ASCLL码转换为对应字符。\n6.char c=tolower(a)\n\n//用来判断一个字符是否为数字，如果是数字则返回非零，否则返回零。\n7.isdigit()\n\n//将数字转换为字符串，这里注意如果是浮点型数转字符，会将精度范围内小数点后的数全部显示出来\n8.to_string()\n//数字转字符串：例如：\nfloat b = 2.;\ns = to_string(b);\ncout << s<<\" \"<<s.size();\n输出为：2.000000 8\n```\n\n# 字符串\n> ## 字符串的一些常用操作\n```Cpp\n  // count删了之后只替换一个字符\n  str.replace(index,count,instead) ->void\n  // 重载很多，startIndex默认为0，从字符串下标为0开始找\n  str.find(tagetStr,startIndex) -> first_index\n\n```\n> ## 字符串的复制和拼接\n  ```Cpp\n  strcpy函数进行字符串的复制\n  //将 first_name 复制给 full_name\n  strcpy(full_name, first_name);   \n\n------------------------------------------------------------------------\n\n  strcat()函数进行字符串的拼接\n  //将 last_name 拼接在 full_name 之后\n  strcat(full_name, last_name);   \n\n  // 字符与字符串之间可以用 + 来连接\n  string s; char ch;\n  s = s + ch;\n  ```\n\n## 字符串与整数的转换\n```Cpp\n// nums为字符串，stoi函数存在于头文件<string>中\nint k = stoi(nums);\n\n// num为整数，to_string函数也在string中\nstring s=to_string(num)\n```\n\n## 字符与整数的互换\n```Cpp\n// 字符转整数，直接强转\nchar c='8' ;\nint a ;\na =(int) (c - '0') ;\n\n// 整数转字符\nint b;\nchar c;\nc = b + '0'\n\n```\n\n# algorithm 函数中的reverse\n```Cpp\nreverse无返回值\n\nstr.begin()是指向str的第一个元素\nstr.end()是指向最后一个元素的后一个位置\n\n1.reverse(str.begin(),str.end()) 反转整个字符串\n \t \n2.reverse(vector.begin(),vector.end()) 反转向量\n \n3.reverse(a,a+strlen(a)) 反转数组\n```","categories":["Cpp"],"tags":["functions"]},{"title":"CppLei","url":"/posts/20863/","content":">介绍了C++中常用的类型、关键字\n<!-- more -->\n\n# C++常用类型及其关键字整理\n>* 在C++中，指针和数组都是采用的引用传递，普通结构体，类，和其他基础类型都是采用的值传递\n>* 只有加了&才能让其他类型的数据使用引用传递\n>* 如果是指针传递，指针变量本身没加&就仍然是值传递，但是指针指向的地址上的改变是形参和实参一致的\n>## Bool 类型\n```cpp\nbool 变量是 值保存  真或者假这个值 （TRUE 或者 FAUSE），1表示真，0 表示假。在Ｃ语言中所有的非零值都为真所以给bool变量赋值，赋值为0则为0。赋值为非0 则为1。\n```\n>## Cout 关键字\n```cpp\nCout<<“sadasd”<< endl\n```\n>## Cin： 输入\n```cpp\nCin >> n;\n\nCin.getline(arrchar,20);\n\n// 直接使用string库函数中的getline可以得到一个字符串输入s\nvoid main() {s\n\tint A;\n\tint B;\n\tstring str;\n\n\t// 可接收一个包含空格的字符串，并赋值给str,最好将getline先在前面\n\tgetline(cin, str);\n\t// cin遇到空格和回车都会执行结束\n\tcin >> A;\n\tcin >> B;\n\n\tint C = A + B;\n\tcout << C;\n\tcout << str;\n}\n\n注：getline()函数中的arrchar是表示的字符数组，20表示的是最多输入19个字符，或者遇到回车结束\n```\n>## const 类型\n```Cpp\nconst int max =500;\nconst static int arr[] = {1,2,3,4}\t\n注：const关键字主要是用来声明常量的，定义之后不能改变了\n```\n>## string 关键字\n```Cpp\nstring s1=”asd”;\n\nstring s2=”asdasd”;\n\nString s= s1+s2; // 字符串的拼接\n\n类比java的input.nextline（获取输入的整个一行）\ngetline(cin,s);// 获取输入的整个一行并赋值给字符串变量s\n\ns.length() // 获取字符串的长度，会包括空格\n\nS.substr(start,counts); // 从下标为start开始取，一共取counts个字符\n\nS.substr(start); // 从下标为start开始取，取遍整个字符串后面的所有字符\n```\n>## 结构体\n```Cpp\n    struct stu{\n        string name;\n        int age;\n    }\n\n    void main(){\n        stu a[10];\n    }\n\n    注:结构体可以直接用名字进行引用\n```\n>## &的引用\n```markdown\n    可在自定义的函数的参数前加一个&，main函数直接传参数，便可在地址上修改参数的值\n```\n>## Pair类型\n```cpp\n    定义和初始化：\n    pair<int,int> data;\n\n    pair<int,int> p2(p1); // 用已经有的pair对象p1来初始化p2\n    \n    pair<int,double> p3(1,1.2); \n\n    pair<int,int> p4 ;  //没有写初始化值，自动初始化为(0,0)\n\n注：每个pair可以存储两个值，这两个值可以是不同的数据类型，存储的值可以是基本数据类型，也可以是自己定义的数据类型\n```\n\n>## 可变数组 Vectory\n```cpp\n   vector <int> arr; \n\tarr.resize(10); // 给该数组分配十个空间\n\tarr[0] = 1;\n\tarr.push_back(20); // 将20放到数组的最后\n\tvector <int> arr2 (10,3); // 给开辟10个空间，给每个空间都初始化为3\n\t// 使用arr[0]=1,这样的方式赋值的时候，一定是已经给数组分配过空间了的，否则编译失败\n\t// 但是使用pushback的话，可以先不分配空间\n\n\t// 迭代器自动遍历整个数组\n\t// arr.end()的位置是在数组的最后一个元素的下一个位置\n\tfor (auto p = arr2.begin(); p != arr2.end(); p++) {\n\t\tcout << *p << \" \";\n\t\tcout << *p << endl;\n\t}\n\n```\n\n>## set集合 ： 存储不含重复元素的集合\n```cpp\n\n    set<int> sarr; \n\tsarr.insert(1); // 给集合添加元素 1\n\tsarr.insert(2); // 给集合添加元素 2\n\tsarr.insert(3); // 给集合添加元素 3\n\n\tsarr.find(3); // 返回值是指针，在集合中寻找有没有3\n\n\tif (sarr.find(1)==sarr.end()) { // 指针指向最后一个元素的下一个位置\n\t\t// 查找失败，集合中没有\n\t\tcout << \"集合中没有这个元素\" << endl ;\n\t}\n\telse {\n\t\t// 找到了\n\t\tcout << *sarr.find(1) << endl;\n\t}\n\tsarr.erase(2);// 从集合中删除 2 这个元素\n\n\t// set集合的遍历\n\tfor (auto p = sarr.begin(); p != sarr.end(); p++) {\n\t\tcout << *p << endl;\n\t}\n\n```\n\n>## map集合 ： 存储键值对的集合\n```cpp\n    map<string,int> mymap;\n\t//添加元素\n\tmymap[\"xt\"] = 3; \n\tmymap[\"zl\"] = 4;\n\tmymap.insert({ \"xxx\",4 });\n\tfor (auto p = mymap.begin(); p != mymap.end(); p++) {\n\t\t// first 表示的是键，second 表示的是值\n\t\t// p代指map集合中的一个元素，实际上是个指针，指向结构体\n\t\tcout << p->first << \" : \" << p->second << endl;\n\t}\n\n```\n\n>## 栈 stack ：先入后出\n```cpp\n    stack<int> sta;\n\tsta.push(1);\n\tsta.push(2);\n\n\t// 打印栈顶元素\n\tcout << sta.top() << endl;\n\tsta.pop(); // 出栈且无返回值\n\tsta.size(); // 获取栈的长度\n```\n>## 队列：先入后出\n```cpp\n    queue<int>qu;\n\t// 入队\n\tqu.push(1);\n\tqu.push(2);\n\tqu.push(3);\n\t// 出队\n\tqu.pop();\n\t// 获取队首\n\tqu.front();\n\t// 获取队尾\n\tqu.back();\n\t// 长度\n\tqu.size();\n    // 入队            \n    pos.emplace(x);\n```\n>## bitset数组\n```cpp\n定义：类似一个字符数组，直接输出的话，是一个二进制数，如果按照数组输出的话，和直接输出相反\n\nbitset<5> b;\t\t // 表示5个二进制位，初始化为0 ： 00000\n\tbitset<5> b(3);\t    // 1是无符号数，输出b为 ：00011 , 此时括号里的数就是二进制数所表示的十进制数\n\tbitset<5> b(\"111\"); //111是字符串，表示在b的低3位是1 : 00111\n\tstring s; int pos, n;\n\tbitset<5>b(s, pos, n);// 类似于上面那个，但是这个是截取部分s然后作为参数，从下标为pos开始，读取n个字符\n    \n    // 下面的是返回为bool类型的函数 ： \n\tb.any(); // 是否有 1\n\tb.none(); //是否不存在1\n\tb.count();//1的个数\n\tb.size();//b中的元素个数\n\tb.test(3);//下标为3的元素是不是 1 \n    \n    // 操作函数\n\tb.flip(); // 所有位取反\n\tb.flip(i); // 第i为取反\n\tb.reset(); // 所有位归零\n\tb.reset(i);// 第i位归零\n\t\n\tunsigned long long1=b.to_ulong();// 转换成unsignedlong的类型\n```\n\n>## sort排序\n```cpp\n    vector<int> arr3(10); // 先分配十个空间\n\n\t// 默认为升序\n\tsort(arr3.begin(), arr3.end()); // 从begin到end这部分进行排序，左开右闭[ )，因为end所在的位置是没有数据的\n\t\n\tvector<int> arr4(10);\n\tsort(arr4.begin(), arr4.end(), cmp); // begin的是x，end的是y\n\n// cmp自定义排序\n// 返回1就顺序不变，如果返回0就会自动交换位置，实际上就是利用了快速排序的原理\n    bool cmp(int x, int y) { \n\t    return x > y; //降序\n    }\n\n// swap交换\n    swap(a[1],a[2]); // 表示把a数组中的下标为1和2的元素位置进行交换\n\n```\n","categories":["Cpp"],"tags":["grammer","cpp"]},{"title":"CppHeadFiles","url":"/posts/56443/","content":"> 介绍与总结了C++的常用头文件\n\n<!-- more -->\n# C++头文件总结\n## 多函数头文件\n```markdown\n1.include<iostream> 输入输出流，得调用这个头文件才能使用cin,cout\n\n2.#include<iomanip> 可以调用一些函数，如fixed()<<setprecision()等\n\n3.#include<cmath> 用于调用一些数学函数\n\n4.#include<string> 调用这个头文件才可以调用字符串类型的变量\n\n5.#include<algorithm> 用于调用各种函数，如sort()\n\n```\n\n## 数据结构头文件\n```markdown\n#include<list> : 列表 \n\n#include<map> ： map集合\n\n#include<queue> : 队列\n\n#include<vector> : 不定长数组\n\n#include<stack> : 栈\n\n```\n\n","categories":["Cpp"],"tags":[]},{"title":"Markdown 教程","url":"/posts/33206/","content":"\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n> Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\n> Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\n> Markdown 编写的文档后缀为 `.md`, `.markdown`。\n\n<!-- more -->\n末尾连续两次空格是换行\n\n# 标题\n👆 看起来就像上面这个。Markdown 标题有两种格式。\n\n## 使用 `=` 和 `-` 标记一级和二级标题\n`=` 和 `-` 标记语法格式如下：\n```markdown\n我展示的是一级标题\n=================\n\n我展示的是二级标题\n-----------------\n```\n\n## 使用 `#` 号标记\n使用 `#` 号可表示 1-6 级标题，一级标题对应一个 `#` 号，二级标题对应两个 `#` 号，以此类推。\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n# 段落样式\nMarkdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。\n当然也可以在段落后面使用一个空行来表示重新开始一个段落。\n\n## 字体\nMarkdown 可以使用以下几种字体：\n> *斜体文本*\n> **粗体文本**\n> ***粗斜体文本***\n```markdown\n*斜体文本*\n_斜体文本_\n\n**粗体文本**\n__粗体文本__\n\n***粗斜体文本***\n___粗斜体文本___\n```\n\n## 分隔线\n可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。\n也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n> - - -\n> 我\n> - - -\n> 裂\n> - - -\n> 开\n> - - -\n> 了\n>\n> - - -\n```markdown\n***\n* * *\n*****\n- - -\n----------\n```\n\n## 删除线\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 `~~` 即可，实例如下：\n> RUNOOB.COM\n> GOOGLE.COM\n> ~~BAIDU.COM~~\n```markdown\nRUNOOB.COM\nGOOGLE.COM\n~~BAIDU.COM~~\n```\n\n## 下划线\n下划线可以通过 HTML 的 `<u>` 标签来实现：\n> <u>带下划线文本</u>\n```html\n<u>带下划线文本</u>\n```\n\n## 脚注\n脚注是对文本的补充说明。Markdown 脚注的格式如下:\n```markdown\n[^要注明的文本]\n```\n以下实例演示了脚注的用法：\n> 阿米娅[^阿米娅]\n```markdown\n创建脚注格式类似这样 [^阿米娅]\n[^阿米娅]: 博士，您还有很多事情需要处理。现在还不能休息哦。\n```\n\n# Markdown 列表\nMarkdown 支持有序列表和无序列表。\n无序列表使用星号(`*`)、加号(`+`)或是减号(`-`)作为列表标记：\n> * 第一项\n> * 第二项\n> * 第三项\n```markdown\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n```\n有序列表使用数字并加上 `.` 号来表示，如：\n> 1. 第一项\n> 2. 第二项\n> 3. 第三项\n```markdown\n1. 第一项\n2. 第二项\n3. 第三项\n```\n\n## 列表嵌套\n列表嵌套只需在子列表中的选项添加四个空格即可：\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n\n\n```markdown\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n```\n\n# Markdown 区块\nMarkdown 区块引用是在段落开头使用 `>` 符号 ，然后后面紧跟一个空格符号：\n> 这是一个区块\n```markdown\n> 这是一个区块\n```\n另外区块是可以嵌套的，一个 `>` 符号是最外层，两个 `>` 符号是第一层嵌套，以此类推：\n> 最外层\n> > 第一层嵌套\n> >\n> > > 第二层嵌套\n```markdown\n> 最外层\n> > 第一层嵌套\n> > > 第二层嵌套\n```\n\n## 区块中使用列表\n区块中使用列表实例如下：\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n```markdown\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n```\n\n## 列表中使用区块\n如果要在列表项目内放进区块，那么就需要在 `>` 前添加四个空格的缩进。\n区块中使用列表实例如下：\n* 第一项\n  > 菜鸟教程\n  > 学的不仅是技术更是梦想\n* 第二项\n```markdown\n* 第一项\n    > 菜鸟教程\n    > 学的不仅是技术更是梦想\n* 第二项\n```\n\n# Markdown 代码\n如果是段落上的一个函数或片段的代码可以用反引号把它包起来（\\`），例如：\n`printf()` 函数\n```markdown\n`printf()` 函数\n```\n## 代码区块\n代码区块使用 4 个空格或者一个制表符（Tab 键）。\n也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：\n实例如下：\n```javascript\n$(document).ready(function () {\n    alert('RUNOOB');\n});\n```\n\n# Markdown 链接\n链接使用方法如下：\n> [链接名称](#链接地址)\n> 或者直接使用链接地址\n> <https://github.com/Yue-plus>\n```markdown\n[链接名称](链接地址)\n<https://github.com/Yue-plus>\n```\n\n## 高级链接\n可以通过变量来设置一个链接，变量赋值在文档末尾进行：\n> 这个链接用 `1` 作为网址变量 [Google][1]\n> 这个链接用 `mysite` 作为网址变量 [Yue_plus][mysite]\n```markdown\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 mysite 作为网址变量 [Yue_plus][mysite]\n然后在文档的结尾为变量赋值（网址）\n\n  [1]: http://www.google.com/\n  [mysite]: https://github.com/Yue-plus\n```\n\n# Markdown 图片\nMarkdown 图片语法格式如下：\n```markdown\n![alt 属性文本](图片地址)\n![alt 属性文本](图片地址 \"可选标题\")\n```\n开头一个感叹号 !\n接着一个方括号，里面放上图片的替代文字\n接着一个英文括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 'title' 属性的文字。\n> ![罗德岛集结](https://ak.hypergryph.com/upload/images/20190228/118078295785f64dac736c6ade50bb76.jpg \"罗德岛集结\")\n```markdown\n![罗德岛集结](https://ak.hypergryph.com/upload/images/20190228/118078295785f64dac736c6ade50bb76.jpg \"罗德岛集结\")\n```\n当然，你也可以像网址那样对图片网址使用变量:\n```markdown\n这个链接用 `2` 作为网址变量 [凯尔希][2].\n然后在文档的结尾为变量赋值（网址）\n\n[2]: https://ak.hypergryph.com/upload/images/20190228/143666074a406ecaa6cd4271dc7c5127.jpg\n```\nMarkdown 还没有办法指定图片的高度与宽度，如果需要的话，也可以使用普通的 `<img>` 标签。\n> <img src=\"https://ak.hypergryph.com/assets/index/images/ak/common/story/item_infected.png\" width=\"200px\">\n```html\n<img src=\"https://ak.hypergryph.com/assets/index/images/ak/common/story/item_infected.png\" width=\"200px\">\n```\n\n# Markdown 表格\nMarkdown 制作表格使用 `|` 来分隔不同的单元格，使用 `-` 来分隔表头和其他行。\n语法格式如下：\n\n| 表头   | 表头   |\n| ------ | ------ |\n| 单元格 | 单元格 |\n| 单元格 | 单元格 |\n\n```markdown\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n```\n\n可以设置表格的对齐方式：\n\n`-:` 设置内容和标题栏居右对齐。\n`:-` 设置内容和标题栏居左对齐。\n`:-:` 设置内容和标题栏居中对齐。\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n# Markdown 高级技巧\n##支持的 HTML 元素\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n目前支持的 HTML 元素有：`<kbd>` `<b>` `<i>` `<em>` `<sup>` `<sub>` `<br>`等，如：\n> 使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n```markdown\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n```\n\n## 转义\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\n> \\*\\* 正常显示星号 \\*\\*\n```markdown\n**文本加粗** \n\\*\\* 正常显示星号 \\*\\*\n```\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n```markdown\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n```\n\n## 数学公式\n当需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n\n> 参考 [使用 `hexo-filter-mathjax` 过滤器来显示数学公式](https://github.com/Yue-plus/hexo-theme-arknights#数学公式)\n\n> 可以在行内包含数学公式： $i\\hbar\\frac{\\partial}{\\partial t}\\psi=-\\frac{\\hbar^2}{2m}\\nabla^2\\psi+V\\psi$ 注意单 `$` 内部不能有空格！\n> $$\n> \\begin{eqnarray\\*}\n> \\nabla\\cdot\\vec{E}&=&\\frac{\\rho}{\\epsilon_0}\\\\\\\\\n> \\nabla\\cdot\\vec{B}&=&0\\\\\\\\\n> \\nabla\\times\\vec{E}&=&-\\frac{\\partial B}{\\partial t}\\\\\\\\\n> \\nabla\\times\\vec{B}&=&\\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t}\\right)\\\\\\\\\n> \\end{eqnarray\\*}\n> $$\n\n```markdown\n可以在行内包含数学公式： $i\\hbar\\frac{\\partial}{\\partial t}\\psi=-\\frac{\\hbar^2}{2m}\\nabla^2\\psi+V\\psi$ 注意单 `$` 内部不能有空格！\n$$\n\\begin{eqnarray\\*}\n\\nabla\\cdot\\vec{E}&=&\\frac{\\rho}{\\epsilon_0}\\\\\\\\\n\\nabla\\cdot\\vec{B}&=&0\\\\\\\\\n\\nabla\\times\\vec{E}&=&-\\frac{\\partial B}{\\partial t}\\\\\\\\\n\\nabla\\times\\vec{B}&=&\\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t}\\right)\\\\\\\\\n\\end{eqnarray\\*}\n$$\n```\n\n[^阿米娅]: 博士，您还有很多事情需要处理。现在还不能休息哦。\n\n[1]: http://www.google.com/\n[mysite]: https://github.com/Yue-plus","categories":[],"tags":["Markdown"]}]