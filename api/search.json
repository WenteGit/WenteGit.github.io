[{"title":"MQ","url":"/posts/44276/","content":"> 总结了关于消息中间件MQ 的知识点\n<!--more-->\n# 核心:四大天王\n>* RabbitMQ\n>* RocketMQ\n>* ActiveMQ\n>* Kafka\n\n> **重点**  \n>* 凡是涉及到监控、刷新的，必须要引入actuator这个依赖\n>* 不同的组可以存在重复消费\n>* 同一个组不能存在重复消费\n>* 不做处理的默认每个接收的实例都是一个组\n# 引入依赖\n```xml\n        <!--添加消息总线RabbitMQ支持-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n        </dependency>\n```\n# client添加yml的相关支持\n```yml\n#rabbitmq相关配置\nrabbitmq:\n  host: localhost\n  port: 5672\n  username: guest\n  password: guest\n\n```\n# 中心Config端 多增加一个这个，include改为:bus-refresh\n# 只需要发送一次，则client端处处生效\n```yml\n##rabbitmq相关配置,暴露bus刷新配置的端点\nmanagement:\n  endpoints: #暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: 'bus-refresh'\n\n```\n\n# 运维发送全体通知和精确通知\n> * 全体通知：  \n> localhost:3344/actuator/bus-refresh  \n> 其中，3344指的是中心Config端的端口号\n>- - -\n>* 精确通知：  \n>localhost:3344/actuator/bus-refresh/config-client:3366  \n>其中，config-client指的是config的服务名称，3366是实例的端口号\n> - - -\n\n# SpringCloud Stream\n## 架构图1\n![alt](http://xtzl.wentexl.cn/%E7%BC%96%E7%A0%81API.png)\n## 架构图2\n![alt](http://xtzl.wentexl.cn/SCS%E6%9E%B6%E6%9E%84%E5%9B%BE2.png)","categories":["Service_MQ"],"tags":["MQ"]},{"title":"Cloud_Config","url":"/posts/8012/","content":"> 主要总结和介绍了SpringCloud的常用配置\n<!--more-->\n> 要测试的话，也要在Windows的host文件做修改：127.0.0.1 config-3344.com\n> 测试链接：http://config-3344.com:3344/main/config-dev.yml\n# 主启动类注解引入\n```java\n@EnableConfigServer\n```\n# 依赖引入\n```xml\n   <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-config-server</artifactId>\n        </dependency>\n```\n# 中心Config的yml 配置\n```yml\nserver:\n  port: 3344\n\nspring:\n  application:\n    name:  cloud-config-center #注册进Eureka服务器的微服务名\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://gitee.com/mx0425/springcloud-config.git #GitHub上面的git仓库名字\n          ####搜索目录\n          search-paths:\n            - springcloud-config\n      ####读取分支\n      label: master\n#rabbitmq相关配置\nrabbitmq:\n  host: localhost\n  port: 5672\n  username: guest\n  password: guest\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n\n##rabbitmq相关配置,暴露bus刷新配置的端点\nmanagement:\n  endpoints: #暴露bus刷新配置的端点\n    web:\n      exposure:\n        include: 'bus-refresh'\n\n```\n# Client端Config的yml配置\n```yml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    #Config客户端配置\n    config:\n      label: main #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址k\n\n#服务注册到eureka地址\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n\n# 暴露监控端点: 实现动态刷新用的\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n\n```\n# Client端手动版动态刷新\n>**Controller层**\n```java\n类名上添加注解\n@RefreshScope\n```\n```yml\n# 暴露监控端点: 实现动态刷新用的\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n\n```\n此时还需要发一个固定的post请求来刷新\n>**localhost:3355/actuator/refresh**","categories":["Serice_Config"],"tags":["SpringCloudConfig"]},{"title":"GateWay","url":"/posts/57702/","content":">对服务网关GateWay的知识总结\n<!--more-->\n# 核心与注意点\n>* GateWay作为网关也需要注册进注册中心\n>* 路由、断言、过滤器\n>* 网关不能部署在Tomcat、Jetty等Servlet容器里，只能打成jar包执行\n>* ​依赖于netty和WebFlux \n>* GateWay不能加Web的起步依赖的jar包\n\n# 架构图\n![alt](http://xtzl.wentexl.cn/%E6%9E%B6%E6%9E%84%E5%9B%BE.png)\n# 依赖导入\n```xml\n      <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-gateway</artifactId>\n        </dependency>\n```\n# 第一种配置方法：yml配置\n```yml\nserver:\n  port: 9527\n\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由\n      routes:\n       #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名\n        - id: payment_routh\n          #uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/get/**         # 断言，路径相匹配的进行路由\n         #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名\n        - id: payment_routh2\n         # uri: http://localhost:8001          #匹配后提供服务的路由地址\n          uri: lb://cloud-payment-service #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/lb/**         # 必须是真正提供服务的方法 \n         #- After=2020-05-13T21:55:10.016+08:00[Asia/Shanghai]\n         # -Before\n         # -Between=2020-05-13T21:55:10.016+08:00[Asia/Shanghai],2021-05-13T21:55:10.016+08:00[Asia/Shanghai]\n         #- Cookie=username,milo\n         #- Header=X-Request-Id, \\d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client: #服务提供者provider注册进eureka服务列表内\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultZone: http://eureka7001.com:7001/eureka\n\n```\n\n# 第二种配置方法：Config配置\n> 当访问/guonei的时候，自动转发到http://news.baidu.com/guonei\n```java\n   @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)\n    {\n        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();\n        routes.route(\"path_route_atguigu\",\n                r -> r.path(\"/guonei\")\n                        .uri(\"http://news.baidu.com/guonei\")).build();\n        return routes.build();\n    }\n\n```\n# yml配置的时候，断言选项\n![断言](http://xtzl.wentexl.cn/GateWay%E6%96%AD%E8%A8%80.png)\n\n# curl开发\n>*  判断是否携带名为X-Request-Id的请求头，且其值必须是一个大于0的整数  \n>* -Header=X-Request-Id, \\d+   \n>* curl http://localhost:9527/payment/lb -H \"X-Request-Id:123\"\n>- - -\n>* 判断请求是否携带cookie名为username，值为milo\n>*  -Cookie = username,milo\n>* curl http://localhost:9527/payment/lb --cookie \"username=123\"\n\n# 自定义过滤器\n> 主要是要实现GlobalFilter,Ordered这两个接口\n```java\n@Component\n@Slf4j\npublic class MyLogGateWayFilter implements GlobalFilter,Ordered\n{\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain)\n    {\n        log.info(\"***********come in MyLogGateWayFilter:  \"+new Date());\n        String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\");\n        if(uname == null)\n        {\n            log.info(\"*******用户名为null，非法用户，o(╥﹏╥)o\");\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\n            return exchange.getResponse().setComplete();\n        }\n        return chain.filter(exchange);\n    }\n    @Override\n    public int getOrder()\n    {\n        return 0;\n    }\n}\n```","categories":["Service_Gateway"],"tags":["GateWay"]},{"title":"JavaUtils","url":"/posts/13372/","content":">主要介绍了Java的各种工具类\n<!--more-->\n# IdUtil\n>* 主要介绍了各种id生成策略\n>* 生成的Id是用不重复的 \n>* String serialNumber = IdUtil.simpleUUID();\n\n# TimeUnit\n>* TimeUnit.DAYS //天  \n>* TimeUnit.HOURS //小时  \n>* TimeUnit.MINUTES //分钟  \n>* TimeUnit.SECONDS //秒  \n>* TimeUnit.MILLISECONDS //毫秒  \n>* TimeUnit.NANOSECONDS //毫微秒  \n>* TimeUnit.MICROSECONDS //微秒  \n>- - -\n>**转换：**\n>* public long toMillis(long d)    //转化成毫秒  \n>* public long toSeconds(long d)  //转化成秒  \n>* public long toMinutes(long d)  //转化成分钟  \n>* public long toHours(long d)    //转化成小时  \n>* public long toDays(long d)     //转化天   \n>- - -\n>**延时：** \n>* TimeUnit.SECONDS.sleep( 5 );\n>* TimeUnit.HOURS.sleep(1);\n\n# ZoneDateTime\n>* ZoneDateTime.now();可以获得当前时间串，在gateway中可以配置使用","categories":["Java"],"tags":["JavaUtils"]},{"title":"Cloud_Hystrix","url":"/posts/64571/","content":">Hystrix属于服务降级部分，这里将会详细介绍关于Hystrix的相关知识\n<!--more-->\n# Hystrix介绍\n>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等。  \n>Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。  \n>- - -\n>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控(类似熔断保险丝)，向调用方返回—个符合预期的、可处理的备选响应(FallBack)。  \n>而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n\n# Hystrix核心\n> * 服务降级\n> * 服务熔断\n> * 接近实时的监控\n\n# 依赖导入\n```xml\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n        </dependency>\n```\n>- - -\n# 服务降级----------------\n# 服务提供端8001设置fallbcakMethod兜底\n>- - -\n>主启动类添加注解，开启断路器功能\n```java\n@EnableCircuitBreaker\n```\n>- - -\n> 解释：  \n>* 业务层添加。如果paymentInfo_TimeOut()在规定的3s内执行失败，则立即访问   paymentInfo_TimeOutHandler()方法作为fallbackMethod方法  \n> * 只要是当前服务不可用了，马上做服务降级\n> * 如果是在服务端配置的服务降级，不能通过80端口回调，只能自测\n```java\n    @HystrixCommand(fallbackMethod = \"paymentInfo_TimeOutHandler\",\n    commandProperties = {\n        @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value=\"3000\")})\n    public String paymentInfo_TimeOut(Integer id)\n    {\n        try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }\n        return \"线程池:  \"+Thread.currentThread().getName()+\" id:  \"+id+\"\\t\"+\"O(∩_∩)O哈哈~\"+\"  耗时(秒): 5\";\n    }\n\n    public String paymentInfo_TimeOutHandler(Integer id)\n    {\n        return \"线程池:  \"+Thread.currentThread().getName()+\"  8001系统繁忙或者运行报错，请稍后再试,id:  \"+id+\"\\t\"+\"o(╥﹏╥)o\";\n    }\n\n```\n\n# 客户端80设置fallbackMethod\n>主启动类添加注解  \n> 其中@EnableHystrix中也包含了@EnableCircuitBreaker\n```java\n@EnableHystrix\n```\n>- - -\n>客户端yml中的配置  \n\n```yml\nfeign:\n  hystrix:\n  #如果处理自身的容错就开启。开启方式与生产端不一样。\n    enabled: true \n```\n>通用fallback方法 :  \n> 若单个方法有具体指明fallback方法，则使用其具体的方法\n```java\n// hystrix 全局fallback方法标注在Controller的类头\n@DefaultProperties(defaultFallback = \"payment_Global_FallbackMethod\")\npublic class OrderFeignController{}\n```\n\n# 客户端80解决代码冗余和膨胀\n> 这样写的话，就不需要在Controller层进行指定了\n> 这样写的优先级仍然大于DefaultProperties的优先级\n```java\n// 在service层的注解添加fallback\n@FeignClient(value = \"cloud-provider-hystrix-payment\",fallback = PaymentFallbackServiceImpl.class)\n```\n```java\n// 书写service层的实现类\n@Component\npublic class PaymentFallbackServiceImpl implements PaymentFeignService {}\n```\n>- - -\n# 服务熔断-----------------------------------\n>## 核心\n> * 服务降级--熔断--慢慢恢复调用电路  \n>- - -\n\n\n> # 服务端\n> ## Controller层\n```java\n  //====服务熔断\n    @GetMapping(\"/payment/circuit/{id}\")\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id)\n    {\n        String result = paymentService.paymentCircuitBreaker(id);\n        log.info(\"****result: \"+result);\n        return result;\n    }\n```\n>## Serice层\n\n```java\n //=====服务熔断\n    @HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\",commandProperties = {\n        // 是否开启断路器v\n        @HystrixProperty(name = \"circuitBreaker.enabled\",value = \"true\"),\n        // 请求次数\n        @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),\n         // 时间窗口期，在这个时间以内，请求次数达到多少后跳闸\n        @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),\n        // 失败率达到多少后跳闸\n        @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\",value = \"60\"),\n    })\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id)\n    {\n        if(id < 0)\n        {\n            throw new RuntimeException(\"******id 不能负数\");\n        }\n        // 使用工具包生成流水号\n        String serialNumber = IdUtil.simpleUUID();\n\n        return Thread.currentThread().getName()+\"\\t\"+\"调用成功，流水号: \" + serialNumber;\n    }\n    public String paymentCircuitBreaker_fallback(@PathVariable(\"id\") Integer id)\n    {\n        return \"id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: \" +id;\n    }\n\n```\n\n# Hystrix断路器总结\n## 熔断需要依靠断路器\n![断路器](http://xtzl.wentexl.cn/%E6%96%AD%E8%B7%AF%E5%99%A8.png)\n\n## 断路器开启或关闭的条件\n>* 当满足一定的阀值的时候(默认10秒内超过20个请求次数)\n>* 当失败率达到一定的时候( 默认10秒内超过50%的请求失败)\n>* 到达以上阀值，断路器将会开启\n>* 当开启的时候，所有请求都不会进行转发\n>* 一段时间之后(默认是5秒)，这个时候断路器是半开状态，会让其中-一个请求进行转发。\n>* 如果成功，断路器会关闭，若失败，继续开启。\n\n# HystrixDashboard\n## 监控图详解\n![监控图](http://xtzl.wentexl.cn/%E7%9B%91%E6%8E%A7%E5%9B%BE.png)\n## 监控数据详解\n![监控数据](http://xtzl.wentexl.cn/%E7%9B%91%E6%8E%A7%E5%9B%BE%E6%95%B0%E6%8D%AE.png)","categories":["Service_degradation"],"tags":["Hystrix"]},{"title":"Cloud_OpenFeign","url":"/posts/40393/","content":">主要记录了关于OpenFeign的知识\n<!--more-->\n\n# 核心\n>* 微服务接口 + @FeignClient\n>* Feign自带负载均衡配置项，默认支持Ribbon\n>* OpenFeign默认等待1秒钟，之后将会报超时错误\n>* 面向接口编程\n>* 主要就是在80端口多了一层Service\n>* 在Service层这里直接使用注解而不使用RestTemplate\n>* 更加方便和简洁\n\n\n# 依赖引入\n```xml\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-openfeign</artifactId>\n        </dependency>\n```\n# 主启动类\n```java\n@EnableFeignClients\n```\n# 80端微服务接口\n**Serice端**\n```java\n@Component\n@FeignClient(value = \"cloud-payment-service\")\npublic interface PaymentFeignService\n{\n    // 这里面的GetMapping是指的是服务实例中的方法的路径，并且会自动将获取到的路径变量加到路径中去\n    @GetMapping(value = \"/payment/get/{id}\")\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id);\n}\n```\n**Controller端**\n```java\npublic class OrderFeignController\n{\n    @Resource\n    private PaymentFeignService paymentFeignService;\n    @GetMapping(value = \"/consumer/payment/get/{id}\")\n    public CommonResult<Payment> getPaymentById(@PathVariable(\"id\") Long id)\n    {\n        return paymentFeignService.getPaymentById(id);\n    }\n\n}\n```\n\n# 设置超时时间\n```yml\n#设置feign客户端超时时间(OpenFeign默认支持ribbon)\nribbon:\n  #指的是建立连接所用的时间，适用于网络状况正常的情况下, 两端连接所用的时间\n  ReadTimeout: 5000\n  #指的是建立连接后从服务器读取到可用资源所用的时间\n  ConnectTimeout: 5000\n```\n# 设置OpenFeign的日志\n## 自定义Config类，加入Bean设置日志级别\n```java\n@Configuration\npublic class FeignConfig\n{\n    @Bean\n    Logger.Level feignLoggerLevel()\n    {\n        return Logger.Level.FULL;\n    }\n}\n```\n## 在yml配置中设置日志的监控接口\n```yml\nlogging:\n  level:\n    # feign日志以 debug 级别监控 com.atguigu.springcloud.service.PaymentFeignService 接口，debug级别会直接在控制台console中打印出来\n    xtzl.ljw.service.PaymentFeignService: debug\n```\n","categories":["Service_invoke"],"tags":["OpenFeign"]},{"title":"Ribbon","url":"/posts/49475/","content":"> 整理了关于Ribbon的相关知识\n<!--more-->\n# 核心\n>* 主要核心就是负载均衡\n\n\n# 依赖引入\n```xml\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n      <version>2.2.1.RELEASE</version>\n      <scope>compile</scope>\n    </dependency>\n```\n# Ribbon的核心组件IRule七种负载均衡的选择方式\n>- - -\n>(出厂默认)RoundRobinRule： 轮询，轮流访问不同的实例\n>- - -\n>RandomRule : 随机，随机访问不同的实例\n>- - -\n>RetryRule:  \n先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内进行重试，获取可用的服务。\n>- - -\n>WeightedResponseTimeRule:  \n对RoundRobinRule的扩展，响应速度越快的实例选择权重就越大，越容易被选择。\n>- - -\n>BestAvailableRule:  \n会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务。\n>- - - \n>AvailabilityFilteringRule:  \n先过滤掉故障实例，再选择并发较小的实例。\n>- - -\n>ZoneAvoidanceRule:  \n>默认规则，复合判断server所在区域的性能和server的可用性选择服务器。\n>- - -\n# Ribbon修改负载均衡的方式\n> **一定不能在主配置类可以扫到的包下，必须新建一个主配置类扫不到的包**\n> 注意点：  \n> * 注解里的服务名要小写\n> * 配置类名不能是MyRule，否则报错\n```java\n// IRule配置类添加\n@Configuration\npublic class MySelfRule {\n    @Bean\n    public IRule myrule(){\n        // 修改为随机方式\n        return new RandomRule(); \n    }\n}\n\n//80端口主运行类注解添加\n//其中name表示的是微服务名称\n@RibbonClient(name = \"cloud-payment-service\",configuration = MySelfRule.class)\n```\n# Ribbon的轮询算法\n> rest接口的第几次请求数 % 服务器集群实例数量 = 实际调用的服务器(实例)的下标\n```java\n// 获取指定服务的所有实例集合\n List<ServiceInstance> instances = discoveryClient.getInstances(\"consul-provider-payment\");\n 例如：\n instances[0]=127.0.0.1:8001\n instances[1]=127.0.0.1:8002\n\n```\n\n\n\n","categories":["Service_invoke"],"tags":["Ribbon"]},{"title":"Consul","url":"/posts/29713/","content":">总结了关于Consul的相关知识点\n<!--more-->\n# 小知识\n>* 启动consul可以配置环境变量\n>* consul agent -dev 命令来启动consul\n>* Consul的首页： http://localhost:8500\n\n# 依赖导入\n```xml\n   <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n        </dependency>\n```\n# application.yml 配置\n```yml\n###consul服务端口号\nserver:\n  port: 8006\n\nspring:\n  application:\n    name: consul-provider-payment\n  ####consul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n\n```\n# 主启动类\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\n```\n\n","categories":["Service_Registry"],"tags":["Consul"]},{"title":"GitWords","url":"/posts/17418/","content":">记录了git的常用命令\n<!--more-->\n# Git常用操作命令\n>* git ls-files 查看暂存区文件\n>- - -\n>* git init 初始化仓库\n>- - -\n>* git add . 添加所有文件进暂存区\n>- - -\n>* git commit 提交到本地仓库\n>- - -\n>* git push 推送到远程仓库\n>- - -\n>* git pull 从远程仓库拉取最新代码\n>- - -\n>* git checkout -b master 新建一个master分支\n>- - -\n>* git branch -al 查看所有分支\n>- - -\n>* git checkout 本地分支名 切换到其他的本地分支\n>- - -\n>* git remote add origin git@github.com:xxxx/xx.git //origin是自定义的远程库的名字，这是给本地仓库添加远程仓库\n>- - -\n>* git remote rm origin 与远程仓库解绑\n>- - -\n>* git remote -v 查看远程仓库的相关信息\n>- --\n>* git push -u origin master  //把当前分支master推送到远程；远程库是空的，所以第一次push加上-u参数；不仅推送了且两个master分支相关联，后续push命令简化git push origin master\n>- - -\n>* git clone git@github.com:lengnuann/L.git xtzl/ljw/ 克隆指令将远程仓库的代码克隆到本地的xtzk/ljw这个文件夹之下\n>- - -\n>* git log 查看日志\n>- - -\n>* git branch --set-upstream-to origin/main master 关联分支，将远程仓库的main分支和master相关联，如果执行失败，先执行 git fetch 来找回main分支\n>- - -\n>* git stash 暂存工作区的内容\n>- - -\n>* git stash pop 恢复暂存的工作区内容\n>- - -\n>* git stash list 查询工作区所有stash的列表\n>- - -\n>* git stash apply 例如：git stash apply stash@{2} 表示指定stash@{2}这个暂存版本，如果不指定，则git stash pop默认恢复最新的一次stash\n>- - -\n>* git stash clear 清空stash\n\n\n\n","categories":["command"],"tags":["git"]},{"title":"LinuxWords","url":"/posts/17418/","content":">总结了一些关于linux的操作命令\n<!--more-->\n\n># SCP命令\n>## 将本地linux服务器的文件拷贝到远程的linux服务器上\n```linux\nscp  /root/file1.txt  username@202.202.146.245:/home/S12004060119/\n```\n>## 将远程linux的文件拷贝到自己的linux本地服务器\n```linux\nscp  username@202.202.146.245:/home/S12004060119/file.txt /root/sh/\n```\n>## 把本地Windows系统的文件夹传到远程linux服务器上\n```linux\nscp -P 22 -r E:\\weixin\\ S12004060119@202.202.146.245:/home/S12004060119/\n```\n># 快捷键\n>Ctrl+l  ：清屏  \nCtrl+o ：执行当前命令，并选择上一条命令  \nCtrl+s ：阻止屏幕输出  \nCtrl+q ：允许屏幕输出  \nCtrl+c ：终止命令  \nCtrl+z ：挂起命令  \nCtrl+d ：输入结束，即EOF的意思，或者注销linux系统\n\n\n# 基本命令\n>* pwd命令  \n>查看当前用户所在的路径\n>* passwd命令  \n>格式： passwd 用户名\n>给用户指定密码\n>* init 命令  \n>Int 3：字符界面\n>Int 5：图形界面\n>* set nu 命令  \n>set nu表示设置行号\n>set nonu表示取消行号\n>* cat命令  复制文件  \n>Cat file1.txt>>file2.txt\n>* cp复制  \n>cp file1.txt /*/*/*\n>* mv命令  \n>mv a b 实现重命名  \n>mv 文件名 移动目的地后的文件名  \n>mv 文件名 修改后的文件名\n","categories":["command"],"tags":["linux"]},{"title":"IDEA_Hotkeys","url":"/posts/10025/","content":"> IDEA的使用快捷键\n<!--more-->\n>**IDEA使用的快捷键**   \n\n>ctrl + D：复制上一行  \n>- - -\n>Ctrl+D: 同时也可以表示结束输入  \n>- - -\n>Shift + alt +↑（↓） ：上下移动某一行  \n>- - -\n>ctrl+/ ：注释  \n>- - -\n>ctrl+r : 查找和替换  \n>- - -\n>ctrl+alt+t: 抓异常快捷键  \n>- - -\n>shift连按两次：查询  \n>- - -\n>ctrl+alt+b：通过接口查看其实现类 \n>- - - \n>alt+insert+fn : 生成getter和setter方法  \n>- - -\n>ctrl+f: 搜索查看  \n>- - -\n>ctrl+a：一键全选  \n>- - -\n>shift+home:选中单行  \n>- - -\n>Ctrl+i:  选择实现方法  \n>- - -\n>Ctrl+Q: 上下文信息，看需要什么参数  \n>- - -\n>shift+tab:取消缩进\n>- - -\n>Ctrl+alt+B: 显示实现类\n>- - -","categories":["IDEA"],"tags":["Hotkeys"]},{"title":"Eureka","url":"/posts/57702/","content":">关于EureKa的知识笔记：Eureka的服务注册与发现\n<!--more-->\n# 小知识\n> * Eureka不用自己注册自己\n> * 注意启动顺序，服务端必须先启动才能检索到客户端\n> * 集群配置：互相注册，相互守望\n> * 配置host之后记得在cmd使用ipconfig /flushdns刷新一下\n> * 大坑！！！:配置集群之后，直接点击链接是访问不了的！！多了一层路径！必须要手动输入地址!\n> * defaultZone如果有多个url，不同的url通过逗号隔开\n\n># 依赖引入\n>## 服务注册端 server\n```xml\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n        </dependency>\n```\n>## 客户端 client\n```xml\n         <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n```\n\n># 单机版在Application.yml中配置\n>## 单机版在server端中的yml配置\n```yml\neureka:\n instance:\n   hostname: localhost  #eureka服务端的实例名字\n client:\n   register-with-eureka: false    #表示不向注册中心注册自己\n   fetch-registry: false   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\n   service-url:\n     #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n     defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\n```\n>## 单机版在client端的yml配置\n```yml\neureka:\n  client:\n    #表明自己需要注册进Eureka中\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有信息，默认为true。\n    #单节点无所谓，集群的话必须设置为true才能配合ribbon使用负载均衡\n    fetch-registry: true\n    service-url:\n      #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n      #单机指向自己\n      defaultZone: http://localhost:7001/eureka\n\n```\n\n\n> # 集群版在Application.xml中的配置\n> ## 在Client端的yml配置\n>- - -\n> 最主要的在于defalutZone的变化  \n> eureka7001.com是host文件配置的主机名\n> \n```yml\neureka:\n  client:\n    register-with-eureka: true\n    fetch-registry: true\n    service-url:\n    #集群指向所以注册中心的eureka\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n```\n>## 在Server端的yml配置\n```yml\neureka:\n  instance:\n    hostname: eureka7002.com  #eureka服务端的实例名字\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n    service-url:\n    #集群指向其他eureka\n      defaultZone: http://eureka7001.com:7001/eureka\n```\n\n># 在主运行类中的注解标识\n>## Server端使用的主键\n```java\n@EnableEurekaServer\n```\n>## Client端使用的注解\n```java\n@EnableEurekaClient\n```\n\n># 服务发现\n> 将服务信息放到到注册中心去  \n> 通过服务发现来活动该服务的信息\n```java\n    // Controller 添加\n    @Resource\n    private DiscoveryClient discoveryClient;\n    \n    // 主运行类添加\n    @EnableDiscoveryClient\n```\n\n# Instance配置\n```yml\n  instance:\n    # 微服务下实例名称修改\n    instance-id: payment8002\n    # 显示IP地址\n    prefer-ip-address: true\n```\n># Eureka的自我保护机制\n>自我保护机制:默认情况下EurekaClient定时向EurekaServer端发送心跳包  \n如果Eureka在server端在一定时间内(默认90秒)没有收到EurekaClient发送心跳包 ,便会直接从服务注册列表中剔除该服务  \n>但是在短时间( 90秒中)内丢失了大量的服务实例心跳,\n这时候EurekaServer会开启自我保护机制,不会剔除该服务(该现象可能出现在网络不通的情况使得 EurekaClient为出现宕机  \n>此时如果换做别的注册中心如果一定时间内没有收到心跳会将剔除该服务,这样就出现了严重失误,因为客户端还能正常发送心跳只是网络延迟问题，而保护机制是为了解决此问题而产生的)\n\n># 关闭Eureka的自动保护机制\n>server端\n```yml\n## Server端的yml中设置关闭自我保护机制，保证不可用服务被及时踢除\neureka:\n  server:\n     enable-self-preservation: false\n     eviction-interval-timer-in-ms: 2000\n```\n>client端设置心跳响应时间\n```yml\neureka:\n  instance:\n#    Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\n   lease-renewal-interval-in-seconds: 1\n#    Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\n   lease-expiration-duration-in-seconds: 2\n```\n","categories":["Service_Registry"],"tags":["Eureka"]},{"title":"Cloud-summary","url":"/posts/42402/","content":">介绍和总结整个SpringCloud的理论体系\n# SpringCloud架构图\n![SpringCloud架构图](http://xtzl.wentexl.cn/SpringCloud%E6%9E%B6%E6%9E%84%E5%9B%BE.png)\n\n<!--more-->\n# 注册中心的异同点\n>## **CAP**\n>- - -\n>**解释**：  \n>C :(强一致性):   对某个指定的客户端来说，读操作保证能够返回最新的写操作结果。  \n>A :(可用性):     非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应)  \n>P :(分区容错性): 当出现网络分区后，系统能够继续“履行职责”。\n>- - -\n>* 分布式系统理论上不可能选择CA架构，只能选择CP或者AP 架构。\n>* CAP理论关注粒度是数据，而不是整个系统的设计策略\n>* AP(Eureka) ; CP(Consul) ; HA(高可用，也是Eureka)  \n>![CAP](http://xtzl.wentexl.cn/SpringCloud/CAP.png)\n\n\n\n\n\n","categories":["SpringCould"],"tags":[]},{"title":"dependencies","url":"/posts/18669/","content":"> 该博文主要记录了在Cloud微服务开发中常用的依赖\n\n# 父工程\n```xml\n<!-- 统一管理jar包版本 -->\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n        <junit.version>4.12</junit.version>\n        <log4j.version>1.2.17</log4j.version>\n        <lombok.version>1.16.18</lombok.version>\n        <mysql.version>5.1.47</mysql.version>\n        <druid.version>1.1.16</druid.version>\n        <mybatis.spring.boot.version>1.3.0</mybatis.spring.boot.version>\n    </properties>\n\n    <!-- 1、只是声明依赖，并不实际引入，子项目按需声明使用的依赖 -->\n    <!-- 2、子项目可以继承父项目的 version 和 scope -->\n    <!-- 3、子项目若指定了 version 和 scope，以子项目为准 -->\n    <dependencyManagement>\n        <dependencies>\n            <!--spring boot 2.2.2-->\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-dependencies</artifactId>\n                <version>2.2.2.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <!--spring cloud Hoxton.SR1-->\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Hoxton.SR1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <!--spring cloud alibaba 2.1.0.RELEASE-->\n            <dependency>\n                <groupId>com.alibaba.cloud</groupId>\n                <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n                <version>2.1.0.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n\n<!-- 以上依赖不能出现在子工程 -->\n\n\n            <dependency>\n                <groupId>mysql</groupId>\n                <artifactId>mysql-connector-java</artifactId>\n                <version>${mysql.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.alibaba</groupId>\n                <artifactId>druid</artifactId>\n                <version>${druid.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>org.mybatis.spring.boot</groupId>\n                <artifactId>mybatis-spring-boot-starter</artifactId>\n                <version>${mybatis.spring.boot.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>junit</groupId>\n                <artifactId>junit</artifactId>\n                <version>${junit.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>log4j</groupId>\n                <artifactId>log4j</artifactId>\n                <version>${log4j.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>org.projectlombok</groupId>\n                <artifactId>lombok</artifactId>\n                <version>${lombok.version}</version>\n                <optional>true</optional>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n\n# 子工程\n```xml\n\n    <dependencies>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/com.alibaba/druid -->\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid-spring-boot-starter</artifactId>\n            <version>1.2.8</version>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-jdbc</artifactId>\n        </dependency>\n           <!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n     </dependencies>\n```\n# 通用工程依赖\n```xml\n <dependencies>\n        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <scope>runtime</scope>\n            <optional>true</optional>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all -->\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-all</artifactId>\n            <version>5.1.0</version>\n        </dependency>\n</dependencies>\n\n```","categories":["dependencies"],"tags":["dependencies"]},{"title":"Configuration_header","url":"/posts/65104/","content":">在Web开发中，该博文对常用配置类的配置头进行了总结\n<!--more-->\n# Web开发常用配置头的总结\n\n>## Mabatis的 Mapper.xml 配置头\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"xtzl.ljw.Dao.PaymentMapper\">\n</mapper>\n``` \n \n>## Bean.xml 配置头\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n</beans>\n\n```","categories":["Configuration"],"tags":["Configuration_header"]},{"title":"Cpp_accumulate","url":"/posts/31024/","content":">总结了Mabtis的一些小细节的知识\n<!--more-->\n\n# Mabatis&&Plus 小知识总结\n\n## type-aliases-package\n### type-aliases-package作用\n>在Mybatis的mapper.xml文件中resultType的type或者paramterType会返回自定义entity  \n此时可以用全类名名来指定这些实体。\n### type-aliases-package配置\n```yml\nmybatis:\n    type-aliases-package=xtzl.ljw.entities\n```\n\n## 指定Mapper路径\n```yml\nmybatis:\n    mapper-locations: classpath:mapper/*.xml\n```\n## useGeneratedKeys\n>在使用useGeneratedKeys=\"true\"后返回值是1，期待返回实体主键\n>insert方法返回值依然是修改行数  \n需要从传入的实体中取对应属性值。  \n比如user表对应User类，主键是id\n那么int i =insertUser（user）;  \n方法执行后 i 还是1\n但是user.getId();得到的值就是主键了\n>- - -\n>一般来说需要和 keyProperty=\"id\" 联用，意为指定主键\n","categories":["Mabtis"],"tags":["accumulate"]},{"title":"JavaNorms","url":"/posts/17711/","content":"> 在学习过程中，对一些常见的开发格式和开发规范，以及一些规范类进行了整理和总结\n<!--more-->\n\n# 规范类:\n## POJO 类\n```markdown\n\"Plain Ordinary Java Object\"，简单普通的java对象。主要用来指代那些没有遵循特定的java对象模型，约定或者框架的对象。\n\nPOJO的内在含义是指那些:\n有一些private的参数作为对象的属性，然后针对每一个参数定义get和set方法访问的接口。\n没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。\n```\n\n## JavaBean\n```markdown\nJavaBean 是一种JAVA语言写成的可重用组件。JavaBean符合一定规范编写的Java类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被其它的程序员或者框架使用。\n它的方法命名，构造及行为必须符合特定的约定:\n    · 所有属性为private。\n    · 这个类必须有一个公共的缺省构造函数。即是提供无参数的构造器。\n    · 这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范。\n    · 这个类应是可序列化的。实现serializable接口。\n\n因为这些要求主要是靠约定而不是靠实现接口，所以许多开发者把JavaBean看作遵从特定命名约定的POJO\n```\n# Rest风格详情介绍\n>* GET （常用于查询）\n>- - -\n>* POST（常用于保存）\n>- - -\n>* PUT（常用于更新修改）\n>- - -\n>* DELETE（常用于删除）\n\n## 传统风格: RequestMapping\n><![传统风格](http://xtzl.wentexl.cn/CT.png)  \n## Restful风格: 增删改查\n![Rest](http://xtzl.wentexl.cn/Rest%E9%A3%8E%E6%A0%BC.png)\n## 两种模式的区别：\n>**风格与规则的区别：**  \n>Restful风格要简洁了很多，并且把行为都隐藏了  \n风格是一种约定俗成的方式，这种约定并不是一定要遵守的，可以不去使用这种约定，即也可以使用传统风格。而规范呢是一种大家必须遵守的规则，你如果不按照这个规范来书写代码，那么就不被允许运行。  所以被叫做REST风格，而不是叫做REST规范。  \n\n\n","categories":["Java"],"tags":["JavaNorms"]},{"title":"S_Annotation","url":"/posts/54839/","content":"> 注解的使用\n<!--more-->\n\n# 常用注解的解释与使用\n\n## 与 SQL 有关的注解\n### @Param\n首先明确这个注解是为SQL语句中参数赋值而服务的。    \n\n @Param的作用就是给参数命名，比如在mapper里面某方法A（int id）  \n 当添加注解后A（@Param(\"userId\") int id）  \n 也就是说外部想要取出传入的id值，只需要取它的参数名userId就可以了。  \n 将参数值传如SQL语句中，通过#{userId}进行取值给SQL的参数赋值\n\n```SQL\nmapper:\npublic User selectUser(@Param(\"userName\") String name,@Param(\"password\") String pwd);\n\nxml:\n<select id=\"selectUser\" resultMap=\"User\">  \n   select * from user  where user_name = #{userName} and user_password=#{password}  \n</select>\n可发现，userName为映射名，相当于起的是个别名\n\n注意点：  \n·当使用了@Param注解来声明参数的时候，SQL语句取值使用#{}，${}取值都可以。\n·当不使用@Param注解声明参数的时候，必须使用的是#{}来取参数。使用${}方式取值会报错。\n·不使用 @Param注解时，参数只能有一个，并且是Javabean。在SQL语句里可以引用JavaBean的性，而且只能引用JavaBean的属性。\n\n\n实际上：\n即便是不使用这个注解，也可以直接通过#{}去访问NewUser的成员变量，也是可以的，但是也只能有一个参数，这个参数就只能是NewUser这个JavaBean对象\n    <insert id=\"insertN\" parameterType=\"xtzl.boot.bean.NewUser\">\n        insert into user (username,password,sex,status) values (#{username},#{password},#{sex},#{status})\n    </insert>\n\n```","categories":["Annotation"],"tags":["Annotation"]},{"title":"Maven_Write","url":"/posts/35182/","content":"\n> 关于Maven的一些小知识点\n<!--more-->\n\n# 直接手动从中央仓库下载依赖\n>## 地址：https://www.mvnrepository.com/\n>## 下载格式\n```markdown\n    mvn dependency:get -DremoteRepositories=https://mvnrepository.com/artifact/org.projectlombok/lombok -DgroupId=org.projectlombok -DartifactId=lombok -Dversion=1.18.12\n\n特别注意： 等号后面一定不能留空格，否则会出现找不到坐标的错误\n\n```\n# 坐标\n>注：groupId 在新建项目的时候可以自行指定，以便于在项目中新建通用模块之后导入其他模块\n> - - - \n> groupId和artifactId是maven管理项目包时用作区分的字段，就像是地图上的坐标。  \nartifactId：artifactId一般是项目名或者模块名。  \ngroupId：groupId分为几个字段，例如cn.com.fullstack，前面的com叫【域】，后面的是你自己起的域名。\n>- - -\n>groupId一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。  \n域又分为org、com、cn等等许多，其中org为非营利组织，com为商业组织。  \n举个apache公司的tomcat项目例子：这个项目的groupId是org.apache，它的域是org（因为tomcat是非营利项目），公司名称是apache，artigactId是tomcat。","categories":["maven"],"tags":["maven"]},{"title":"Cloud-Base","url":"/posts/52648/","content":"\n> SpringCould的学习随堂笔记\n\n<!--more-->\n\n# SpringCould 随堂笔记\n\n>## 父工程框架  \n  \n> ### 父工程统一管理Jar包\n```xml\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>12</maven.compiler.source>\n    <maven.compiler.target>12</maven.compiler.target>\n    <junit.version>4.12</junit.version>\n    <lombok.version>1.18.10</lombok.version>\n    <log4j.version>1.2.17</log4j.version>\n    <mysql.version>8.0.21</mysql.version>\n    <druid.version>1.0.9</druid.version>\n    <mybatis.spring.boot.version>2.2.2</mybatis.spring.boot.version>\n  </properties>\n```\n>### 必要依赖\n```xml\n    <dependencies>\n      <!--spring boot 2.2.2-->\n      <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-dependencies</artifactId>\n        <version>2.2.2.RELEASE</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      <!--spring cloud Hoxton.SR1-->\n      <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-dependencies</artifactId>\n        <version>Hoxton.SR1</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n      <!--spring cloud alibaba 2.1.0.RELEASE-->\n      <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n        <version>2.1.0.RELEASE</version>\n        <type>pom</type>\n        <scope>import</scope>\n      </dependency>\n\n```\n\n\n>## 子工程application配置文件\n### 数据源配置\n```yml\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: org.gjt.mm.mysql.Driver\n    url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&characterEncoding=utf-8&useSSL=false\n    username: root\n    password: root\n\n```\n### 唯一标识\n```yml\nspring:\n  application:\n    name: cloud-payment-service\n```\n## Devtools 开启热部署\n> 注：电脑不太行不建议开启，太锤子卡了\n>1. 导入jar包\n>2. 引spring-boot-maven-plugin插件\n>3. 在IDEA的Compile中调设置.\n>4. 重启IDEA\n\n\n## RestTemplate\n> 可用 订单80端口去调用8001端口的服务进行操作\n```java\n  @Bean\n    public RestTemplate getRestTemplate(){\n        return new RestTemplate();\n    }\n```\n> ### 两种方式：\n```java\n  // 第一种是写死的，第二种是URL为集群的服务名\n  // 微服务可能有多个端口\n   // public static final String PAYMENT_URL=\"http://localhost:8001\";\n    public static final String PAYMENT_URL=\"http://CLOUD-PAYMENT-SERVICE\";\n    @Resource\n    private RestTemplate restTemplate;\n\n    // GET请求实际上调用了POST请求\n    @GetMapping(\"/consumer/payment/create\")\n    public CommonResult<Payment> create(Payment payment){\n        return restTemplate.postForObject(PAYMENT_URL+\"/payment/create\",payment,CommonResult.class);\n    }\n\n    @GetMapping(\"/consumer/payment/get/{id}\")\n    public CommonResult<Payment> getPayment(@PathVariable(\"id\") Long id){\n        System.out.println(id);\n        log.info(String.valueOf(id));\n        return restTemplate.getForObject(PAYMENT_URL+\"/payment/get/\"+id,CommonResult.class);\n    }\n\n坑： 此处我使用@Pathgram 无法获取到路径变量\n```\n**细节**  \n>在微服务的Controller中，涉及到POST请求，一定不要忘记加@RequstBody这个注解，当80端口的请求到微服务端口的方法时\n```java\n    @PostMapping(\"/payment/create\")\n    public CommonResult create(@RequestBody Payment payment){\n    }\n```\n# 负载均衡\n> 微服务没被写死端口号的时候\n> 在配置类里面必须加 @LoadBalanced 才行\n> @LoadBalanced赋予RestTemplate负载均衡的能力:轮班值日\n```java\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate(){\n        return new RestTemplate();\n    }\n```\n>**RestTemplate返回对象选择**\n![RestTemplate返回](http://xtzl.wentexl.cn/restTemplate%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1.png)\n\n","categories":["SpringCould"],"tags":["SpringCould"]},{"title":"Algorithm","url":"/posts/6062/","content":"> 算法总结\n<!--more-->\n\n># 全排列\n## 将字符串中的每个字母转变大小写,返回所有可能得到的字符串集合 \n**算法思路：**    \n如果下一个字符 c 是字母，将当前已遍历过的字符串全排列复制两份。  \n在第一份的每个字符串末尾添加 lowercase(c)，在第二份的每个字符串末尾添加 uppercase(c)。  \n如果下一个字符 c 是数字，将 c 直接添加到每个字符串的末尾。  \n\n**编程语言: Python**\n```Py\ndef letterCasePermutation(self, S):\n        ans = [[]]\n        for char in S:\n            n = len(ans)\n            \n            if char.isalpha():\n                for i in xrange(n):\n                    ans.append(ans[i][:])\n                    ans[i].append(char.lower())\n                    ans[n+i].append(char.upper())\n            else:\n                for i in xrange(n):\n                    ans[i].append(char)\n\n```\n># DFS 深度优先\n># BFS 广度优先\n># 递归与回溯\n>题目描述:  \n>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>>ans;\n    vector<int>temp;\n    vector<vector<int>> combine(int n, int k) {\n        dfs(1, n, k);\n        return ans;\n    }\n    // 1 2 3 4\n    void dfs(int cur,int n,int k) {\n// 如果当前temp的大小为s，未确定状态的区间[cur,n] 的长度为t，如果s + t < ks+t<k\n// 那么即使 tt 个都被选中，也不可能构造出一个长度为k的序列\n        if (temp.size() + (n - cur + 1) < k) {\n            return;\n        }\n        if (temp.size() == k) {\n            ans.push_back(temp);\n            return;\n        }\n\n        temp.push_back(cur);\n        dfs(cur + 1, n, k);\n        temp.pop_back();\n        dfs(cur + 1, n,k);\n    }\n};\n\n```\n\n># 二分查找\n># 双指针\n># 滑动窗口\n># DP动态规划\n## 各个房间内都有一定的现金，相邻的房间不可同时偷，求最好的偷取方案。\n**算法思路：**  \n依次保存偷当前房间的话，算上之前的一共能偷到的总金额  \n**编程语言：C++**\n```cpp\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        if (nums.empty()) {\n            return 0;\n        }\n        else if (nums.size() == 1) {\n            return nums[0];\n        }\n        else if (nums.size() == 2) {\n            return nums[0] > nums[1] ? nums[0] : nums[1];\n        }\n\n        vector<int> dp(nums.size(), 0);\n        dp[0] = nums[0];\n        dp[1] = max(nums[0], nums[1]);\n\n        for (int i = 2; i < nums.size(); i++) {\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\n        }\n        return dp[nums.size() - 1];\n    }\n};\n\n```\n## 给定一个三角形 triangle ，找出自底向上求的最小路径和。\n**算法思路**\n> 从倒数第二排开始，每次将该层的元素的下一层的相邻元素的最小的保存到该层元素，逐层返回到最顶层，则最顶层保存的就是最小路径  \n\n**编程语言：C++**\n```cpp\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int size = triangle.size();\n        for (int i = size -2; i >=0 ; i--) {\n            for (int j = 0; j < triangle[i].size(); j++) {\n                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);\n            }\n        }\n        return triangle[0][0];\n    }\n};\n\n```\n\n># 位运算\n","categories":["Algorithm"],"tags":["Algorithm"]},{"title":"Cpp_accumulate","url":"/posts/31023/","content":"\n> 在平时的算法练习中，对Cpp的一些零碎知识的积累总结\n<!--more-->\n\n# Cpp综合积累\n\n> ## 函数方法\n### vector\n> vector也可以当做栈来使用  \n> 如下：pop_back表示出栈，push_back表示入栈  \n> arr.back 表示获取栈顶元素  \n> arr.front 表示获取栈底元素或者叫做队列头元素\n```Cpp\n    vector<int>arr = { 1,2,3 };\n    arr.pop_back();\n    cout<<arr.back();\n    cout << arr.front();\n```\n## 关键字\n### new关键字\n> new关键字可用作new一个新的对象出来，并返回一个指针类型的变量指向该对象，可以new类，也可以new结构体","categories":["Cpp"],"tags":["accumulate"]},{"title":"CppHeadFiles","url":"/posts/56444/","content":"> 总结了C++常用函数\n\n<!-- more-->\n\n># C++ 函数总结\n\n>## 判断大小写\n```Cpp\n//用来判断一个字符是否为字母，如果是字符则返回非零，否则返回零。\n 1.isalpha()\n\n//用来判断一个字符是否为数字或者字母，也就是说判断一个字符是否属于a~z||A~Z||0~9。是返回非零，不是返回0。\n2.isalnum()\n\n//用来判断一个字符是否为小写字母，也就是是否属于a~z。是返回非零，不是返回0。\n3.islower()\n\n//用来判断一个字符是否为大写字母。是返回非零，不是返回0。\n4.isupper()\n\n//a为字符时，如果a是小写字母则将其转换为大写字母，否则不变。a为数字则将其按ASCLL码转换为对应字符。（其实即使a是字符，输入之后还是会将其转换为int类型）\n5. char c = toupper(a)\n\n//a为字符时，如果a是大写字母则将其转换为小写字母，否则不变。a为数字则将其按ASCLL码转换为对应字符。\n6.char c=tolower(a)\n\n//用来判断一个字符是否为数字，如果是数字则返回非零，否则返回零。\n7.isdigit()\n\n//将数字转换为字符串，这里注意如果是浮点型数转字符，会将精度范围内小数点后的数全部显示出来\n8.to_string()\n//数字转字符串：例如：\nfloat b = 2.;\ns = to_string(b);\ncout << s<<\" \"<<s.size();\n输出为：2.000000 8\n```\n> ## 字符串的复制和拼接\n  ```Cpp\n  strcpy函数进行字符串的复制\n  //将 first_name 复制给 full_name\n  strcpy(full_name, first_name);   \n\n------------------------------------------------------------------------\n\n  strcat()函数进行字符串的拼接\n  //将 last_name 拼接在 full_name 之后\n  strcat(full_name, last_name);   \n\n  // 字符与字符串之间可以用 + 来连接\n  string s; char ch;\n  s = s + ch;\n  ```\n\n## 字符串与整数的转换\n```Cpp\n// nums为字符串，stoi函数存在于头文件<string>中\nint k = stoi(nums);\n\n// num为整数，to_string函数也在string中\nstring s=to_string(num)\n```\n\n## 字符与整数的互换\n```Cpp\n// 字符转整数，直接强转\nchar c='8' ;\nint a ;\na =(int) (c - '0') ;\n\n// 整数转字符\nint b;\nchar c;\nc = b + '0'\n\n```","categories":["Cpp"],"tags":["functions"]},{"title":"CppHeadFiles","url":"/posts/56443/","content":"> 介绍与总结了C++的常用头文件\n\n<!-- more -->\n# C++头文件总结\n## 多函数头文件\n```markdown\n1.include<iostream> 输入输出流，得调用这个头文件才能使用cin,cout\n\n2.#include<iomanip> 可以调用一些函数，如fixed()<<setprecision()等\n\n3.#include<cmath> 用于调用一些数学函数\n\n4.#include<string> 调用这个头文件才可以调用字符串类型的变量\n\n5.#include<algorithm> 用于调用各种函数，如sort()\n\n```\n\n## 数据结构头文件\n```markdown\n#include<list> : 列表 \n\n#include<map> ： map集合\n\n#include<queue> : 队列\n\n#include<vector> : 不定长数组\n\n#include<stack> : 栈\n\n```\n\n","categories":["Cpp"],"tags":[]},{"title":"CppLei","url":"/posts/20863/","content":">介绍了C++中常用的类型、关键字\n<!-- more -->\n\n# C++常用类型及其关键字整理\n\n>## Bool 类型\n```cpp\nbool 变量是 值保存  真或者假这个值 （TRUE 或者 FAUSE），1表示真，0 表示假。在Ｃ语言中所有的非零值都为真所以给bool变量赋值，赋值为0则为0。赋值为非0 则为1。\n```\n>## Cout 关键字\n```cpp\nCout<<“sadasd”<< endl\n```\n>## Cin： 输入\n```cpp\nCin >> n;\n\nCin.getline(arrchar,20);\n\n注：getline()函数中的arrchar是表示的字符数组，20表示的是最多输入19个字符，或者遇到回车结束\n```\n>## const 类型\n```Cpp\nconst int max =500;\nconst static int arr[] = {1,2,3,4}\t\n注：const关键字主要是用来声明常量的，定义之后不能改变了\n```\n>## string 关键字\n```Cpp\nstring s1=”asd”;\n\nstring s2=”asdasd”;\n\nString s= s1+s2; // 字符串的拼接\n\n类比java的input.nextline（获取输入的整个一行）\ngetline(cin,s);// 获取输入的整个一行并赋值给字符串变量s\n\ns.length() // 获取字符串的长度，会包括空格\n\nS.substr(start,counts); // 从下标为start开始取，一共取counts个字符\n\nS.substr(start); // 从下标为start开始取，取遍整个字符串后面的所有字符\n```\n>## 结构体\n```Cpp\n    struct stu{\n        string name;\n        int age;\n    }\n\n    void main(){\n        stu a[10];\n    }\n\n    注:结构体可以直接用名字进行引用\n```\n>## &的引用\n```markdown\n    可在自定义的函数的参数前加一个&，main函数直接传参数，便可在地址上修改参数的值\n```\n>## Pair类型\n```cpp\n    定义和初始化：\n    pair<int,int> data;\n\n    pair<int,int> p2(p1); // 用已经有的pair对象p1来初始化p2\n    \n    pair<int,double> p3(1,1.2); \n\n    pair<int,int> p4 ;  //没有写初始化值，自动初始化为(0,0)\n\n注：每个pair可以存储两个值，这两个值可以是不同的数据类型，存储的值可以是基本数据类型，也可以是自己定义的数据类型\n```\n\n>## 可变数组 Vectory\n```cpp\n   vector <int> arr; \n\tarr.resize(10); // 给该数组分配十个空间\n\tarr[0] = 1;\n\tarr.push_back(20); // 将20放到数组的最后\n\tvector <int> arr2 (10,3); // 给开辟10个空间，给每个空间都初始化为3\n\t// 使用arr[0]=1,这样的方式赋值的时候，一定是已经给数组分配过空间了的，否则编译失败\n\t// 但是使用pushback的话，可以先不分配空间\n\n\t// 迭代器自动遍历整个数组\n\t// arr.end()的位置是在数组的最后一个元素的下一个位置\n\tfor (auto p = arr2.begin(); p != arr2.end(); p++) {\n\t\tcout << *p << \" \";\n\t\tcout << *p << endl;\n\t}\n\n```\n\n>## set集合 ： 存储不含重复元素的集合\n```cpp\n\n    set<int> sarr; \n\tsarr.insert(1); // 给集合添加元素 1\n\tsarr.insert(2); // 给集合添加元素 2\n\tsarr.insert(3); // 给集合添加元素 3\n\n\tsarr.find(3); // 返回值是指针，在集合中寻找有没有3\n\n\tif (sarr.find(1)==sarr.end()) { // 指针指向最后一个元素的下一个位置\n\t\t// 查找失败，集合中没有\n\t\tcout << \"集合中没有这个元素\" << endl ;\n\t}\n\telse {\n\t\t// 找到了\n\t\tcout << *sarr.find(1) << endl;\n\t}\n\tsarr.erase(2);// 从集合中删除 2 这个元素\n\n```\n\n>## map集合 ： 存储键值对的集合\n```cpp\n    map<string,int> mymap;\n\t//添加元素\n\tmymap[\"xt\"] = 3; \n\tmymap[\"zl\"] = 4;\n\tmymap.insert({ \"xxx\",4 });\n\tfor (auto p = mymap.begin(); p != mymap.end(); p++) {\n\t\t// first 表示的是键，second 表示的是值\n\t\t// p代指map集合中的一个元素，实际上是个指针，指向结构体\n\t\tcout << p->first << \" : \" << p->second << endl;\n\t}\n\n```\n\n>## 栈 stack ：先入后出\n```cpp\n    stack<int> sta;\n\tsta.push(1);\n\tsta.push(2);\n\n\t// 打印栈顶元素\n\tcout << sta.top() << endl;\n\tsta.pop(); // 出栈且无返回值\n\tsta.size(); // 获取栈的长度\n```\n>## 队列：先入后出\n```cpp\n    queue<int>qu;\n\t// 入队\n\tqu.push(1);\n\tqu.push(2);\n\tqu.push(3);\n\t// 出队\n\tqu.pop();\n\t// 获取队首\n\tqu.front();\n\t// 获取队尾\n\tqu.back();\n\t// 长度\n\tqu.size();\n    // 入队            \n    pos.emplace(x);\n```\n>## bitset数组\n```cpp\n定义：类似一个字符数组，直接输出的话，是一个二进制数，如果按照数组输出的话，和直接输出相反\n\nbitset<5> b;\t\t // 表示5个二进制位，初始化为0 ： 00000\n\tbitset<5> b(3);\t    // 1是无符号数，输出b为 ：00011 , 此时括号里的数就是二进制数所表示的十进制数\n\tbitset<5> b(\"111\"); //111是字符串，表示在b的低3位是1 : 00111\n\tstring s; int pos, n;\n\tbitset<5>b(s, pos, n);// 类似于上面那个，但是这个是截取部分s然后作为参数，从下标为pos开始，读取n个字符\n    \n    // 下面的是返回为bool类型的函数 ： \n\tb.any(); // 是否有 1\n\tb.none(); //是否不存在1\n\tb.count();//1的个数\n\tb.size();//b中的元素个数\n\tb.test(3);//下标为3的元素是不是 1 \n    \n    // 操作函数\n\tb.flip(); // 所有位取反\n\tb.flip(i); // 第i为取反\n\tb.reset(); // 所有位归零\n\tb.reset(i);// 第i位归零\n\t\n\tunsigned long long1=b.to_ulong();// 转换成unsignedlong的类型\n```\n\n>## sort排序\n```cpp\n    vector<int> arr3(10); // 先分配十个空间\n\n\t// 默认为升序\n\tsort(arr3.begin(), arr3.end()); // 从begin到end这部分进行排序，左开右闭[ )，因为end所在的位置是没有数据的\n\t\n\tvector<int> arr4(10);\n\tsort(arr4.begin(), arr4.end(), cmp); // begin的是x，end的是y\n\n// cmp自定义排序\n// 返回1就顺序不变，如果返回0就会自动交换位置，实际上就是利用了快速排序的原理\n    bool cmp(int x, int y) { \n\t    return x > y; //降序\n    }\n\n// swap交换\n    swap(a[1],a[2]); // 表示把a数组中的下标为1和2的元素位置进行交换\n\n```\n","categories":["Cpp"],"tags":["grammer","cpp"]},{"title":"Markdown 教程","url":"/posts/33206/","content":"\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n> Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\n> Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\n> Markdown 编写的文档后缀为 `.md`, `.markdown`。\n\n<!-- more -->\n末尾连续两次空格是换行\n\n# 标题\n👆 看起来就像上面这个。Markdown 标题有两种格式。\n\n## 使用 `=` 和 `-` 标记一级和二级标题\n`=` 和 `-` 标记语法格式如下：\n```markdown\n我展示的是一级标题\n=================\n\n我展示的是二级标题\n-----------------\n```\n\n## 使用 `#` 号标记\n使用 `#` 号可表示 1-6 级标题，一级标题对应一个 `#` 号，二级标题对应两个 `#` 号，以此类推。\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n# 段落样式\nMarkdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。\n当然也可以在段落后面使用一个空行来表示重新开始一个段落。\n\n## 字体\nMarkdown 可以使用以下几种字体：\n> *斜体文本*\n> **粗体文本**\n> ***粗斜体文本***\n```markdown\n*斜体文本*\n_斜体文本_\n\n**粗体文本**\n__粗体文本__\n\n***粗斜体文本***\n___粗斜体文本___\n```\n\n## 分隔线\n可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。\n也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n> - - -\n> 我\n> - - -\n> 裂\n> - - -\n> 开\n> - - -\n> 了\n>\n> - - -\n```markdown\n***\n* * *\n*****\n- - -\n----------\n```\n\n## 删除线\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 `~~` 即可，实例如下：\n> RUNOOB.COM\n> GOOGLE.COM\n> ~~BAIDU.COM~~\n```markdown\nRUNOOB.COM\nGOOGLE.COM\n~~BAIDU.COM~~\n```\n\n## 下划线\n下划线可以通过 HTML 的 `<u>` 标签来实现：\n> <u>带下划线文本</u>\n```html\n<u>带下划线文本</u>\n```\n\n## 脚注\n脚注是对文本的补充说明。Markdown 脚注的格式如下:\n```markdown\n[^要注明的文本]\n```\n以下实例演示了脚注的用法：\n> 阿米娅[^阿米娅]\n```markdown\n创建脚注格式类似这样 [^阿米娅]\n[^阿米娅]: 博士，您还有很多事情需要处理。现在还不能休息哦。\n```\n\n# Markdown 列表\nMarkdown 支持有序列表和无序列表。\n无序列表使用星号(`*`)、加号(`+`)或是减号(`-`)作为列表标记：\n> * 第一项\n> * 第二项\n> * 第三项\n```markdown\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n```\n有序列表使用数字并加上 `.` 号来表示，如：\n> 1. 第一项\n> 2. 第二项\n> 3. 第三项\n```markdown\n1. 第一项\n2. 第二项\n3. 第三项\n```\n\n## 列表嵌套\n列表嵌套只需在子列表中的选项添加四个空格即可：\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n\n\n```markdown\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n```\n\n# Markdown 区块\nMarkdown 区块引用是在段落开头使用 `>` 符号 ，然后后面紧跟一个空格符号：\n> 这是一个区块\n```markdown\n> 这是一个区块\n```\n另外区块是可以嵌套的，一个 `>` 符号是最外层，两个 `>` 符号是第一层嵌套，以此类推：\n> 最外层\n> > 第一层嵌套\n> >\n> > > 第二层嵌套\n```markdown\n> 最外层\n> > 第一层嵌套\n> > > 第二层嵌套\n```\n\n## 区块中使用列表\n区块中使用列表实例如下：\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n```markdown\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n```\n\n## 列表中使用区块\n如果要在列表项目内放进区块，那么就需要在 `>` 前添加四个空格的缩进。\n区块中使用列表实例如下：\n* 第一项\n  > 菜鸟教程\n  > 学的不仅是技术更是梦想\n* 第二项\n```markdown\n* 第一项\n    > 菜鸟教程\n    > 学的不仅是技术更是梦想\n* 第二项\n```\n\n# Markdown 代码\n如果是段落上的一个函数或片段的代码可以用反引号把它包起来（\\`），例如：\n`printf()` 函数\n```markdown\n`printf()` 函数\n```\n## 代码区块\n代码区块使用 4 个空格或者一个制表符（Tab 键）。\n也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：\n实例如下：\n```javascript\n$(document).ready(function () {\n    alert('RUNOOB');\n});\n```\n\n# Markdown 链接\n链接使用方法如下：\n> [链接名称](#链接地址)\n> 或者直接使用链接地址\n> <https://github.com/Yue-plus>\n```markdown\n[链接名称](链接地址)\n<https://github.com/Yue-plus>\n```\n\n## 高级链接\n可以通过变量来设置一个链接，变量赋值在文档末尾进行：\n> 这个链接用 `1` 作为网址变量 [Google][1]\n> 这个链接用 `mysite` 作为网址变量 [Yue_plus][mysite]\n```markdown\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 mysite 作为网址变量 [Yue_plus][mysite]\n然后在文档的结尾为变量赋值（网址）\n\n  [1]: http://www.google.com/\n  [mysite]: https://github.com/Yue-plus\n```\n\n# Markdown 图片\nMarkdown 图片语法格式如下：\n```markdown\n![alt 属性文本](图片地址)\n![alt 属性文本](图片地址 \"可选标题\")\n```\n开头一个感叹号 !\n接着一个方括号，里面放上图片的替代文字\n接着一个英文括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 'title' 属性的文字。\n> ![罗德岛集结](https://ak.hypergryph.com/upload/images/20190228/118078295785f64dac736c6ade50bb76.jpg \"罗德岛集结\")\n```markdown\n![罗德岛集结](https://ak.hypergryph.com/upload/images/20190228/118078295785f64dac736c6ade50bb76.jpg \"罗德岛集结\")\n```\n当然，你也可以像网址那样对图片网址使用变量:\n```markdown\n这个链接用 `2` 作为网址变量 [凯尔希][2].\n然后在文档的结尾为变量赋值（网址）\n\n[2]: https://ak.hypergryph.com/upload/images/20190228/143666074a406ecaa6cd4271dc7c5127.jpg\n```\nMarkdown 还没有办法指定图片的高度与宽度，如果需要的话，也可以使用普通的 `<img>` 标签。\n> <img src=\"https://ak.hypergryph.com/assets/index/images/ak/common/story/item_infected.png\" width=\"200px\">\n```html\n<img src=\"https://ak.hypergryph.com/assets/index/images/ak/common/story/item_infected.png\" width=\"200px\">\n```\n\n# Markdown 表格\nMarkdown 制作表格使用 `|` 来分隔不同的单元格，使用 `-` 来分隔表头和其他行。\n语法格式如下：\n\n| 表头   | 表头   |\n| ------ | ------ |\n| 单元格 | 单元格 |\n| 单元格 | 单元格 |\n\n```markdown\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n```\n\n可以设置表格的对齐方式：\n\n`-:` 设置内容和标题栏居右对齐。\n`:-` 设置内容和标题栏居左对齐。\n`:-:` 设置内容和标题栏居中对齐。\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n# Markdown 高级技巧\n##支持的 HTML 元素\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n目前支持的 HTML 元素有：`<kbd>` `<b>` `<i>` `<em>` `<sup>` `<sub>` `<br>`等，如：\n> 使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n```markdown\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n```\n\n## 转义\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\n> \\*\\* 正常显示星号 \\*\\*\n```markdown\n**文本加粗** \n\\*\\* 正常显示星号 \\*\\*\n```\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n```markdown\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n```\n\n## 数学公式\n当需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n\n> 参考 [使用 `hexo-filter-mathjax` 过滤器来显示数学公式](https://github.com/Yue-plus/hexo-theme-arknights#数学公式)\n\n> 可以在行内包含数学公式： $i\\hbar\\frac{\\partial}{\\partial t}\\psi=-\\frac{\\hbar^2}{2m}\\nabla^2\\psi+V\\psi$ 注意单 `$` 内部不能有空格！\n> $$\n> \\begin{eqnarray\\*}\n> \\nabla\\cdot\\vec{E}&=&\\frac{\\rho}{\\epsilon_0}\\\\\\\\\n> \\nabla\\cdot\\vec{B}&=&0\\\\\\\\\n> \\nabla\\times\\vec{E}&=&-\\frac{\\partial B}{\\partial t}\\\\\\\\\n> \\nabla\\times\\vec{B}&=&\\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t}\\right)\\\\\\\\\n> \\end{eqnarray\\*}\n> $$\n\n```markdown\n可以在行内包含数学公式： $i\\hbar\\frac{\\partial}{\\partial t}\\psi=-\\frac{\\hbar^2}{2m}\\nabla^2\\psi+V\\psi$ 注意单 `$` 内部不能有空格！\n$$\n\\begin{eqnarray\\*}\n\\nabla\\cdot\\vec{E}&=&\\frac{\\rho}{\\epsilon_0}\\\\\\\\\n\\nabla\\cdot\\vec{B}&=&0\\\\\\\\\n\\nabla\\times\\vec{E}&=&-\\frac{\\partial B}{\\partial t}\\\\\\\\\n\\nabla\\times\\vec{B}&=&\\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t}\\right)\\\\\\\\\n\\end{eqnarray\\*}\n$$\n```\n\n[^阿米娅]: 博士，您还有很多事情需要处理。现在还不能休息哦。\n\n[1]: http://www.google.com/\n[mysite]: https://github.com/Yue-plus","categories":[],"tags":["Markdown"]},{"title":"Sdemo","url":"/posts/1536/","content":"\n![](https://ak.hycdn.cn/announce/images/20220623/c6de324d90b1963bf1b4664871753d60.jpg)\n\n<!-- more -->\n\n## 一、全新活动SideStory「绿野幻梦」，活动关卡开启\n\n**活动说明：** 活动期间将开放「绿野幻梦」活动关卡，玩家可通过活动关卡作战、完成相关活动任务以及活动商店兑换获取相关活动奖励\n\n**解锁条件：** 通关主线1-10\n\n**活动关卡将进行分段式开启：**\n\n**◆“实验基地”开启时间：** 07月05日 16:00 - 07月19日 03:59\n\n**◆“莱茵总部”开启时间：** 07月12日 16:00 - 07月19日 03:59\n\n![](https://ak.hycdn.cn/announce/images/20220623/891f45683fe66911f6a1247e246195c8)\n\n**【数据采集】**\n\n**活动说明：** 活动期间，玩家可通过活动关卡作战完成“数据采集”中相关任务获取奖励\n\n**主要奖励：** 活动干员 ***【★★★★★：星源】*** 、 ***【莱茵实验培养舱】家具（部分）*** 、 神秘试剂\n\n**【危险物品回收处】**\n\n**开放时间：** 07月05日 16:00 - 07月26日 03:59\n\n**兑换说明：** 活动期间，玩家可通过挑战活动关卡及【数据采集】获取「神秘试剂」，消耗「神秘试剂」来兑换【危险物品回收处】中物品\n\n**主要物品：** ***【星源】信物*** 、 ***【莱茵实验培养舱】家具（部分）*** 、寻访凭证、高级养成素材、龙门币、作战记录、家具零件等\n\n◆本次活动期间【情报处理室】将无法浏览当期活动剧情，活动结束后该活动剧情将收录至【情报处理室】中\n\n![](https://ak.hycdn.cn/announce/images/20220623/79fb10c2a72c62023c64040d0676060a.jpg)\n\n## 二、【沙洲引路人】限时寻访开启\n\n**活动时间：** 07月05日 16:00 - 07月19日 03:59\n\n**活动说明：** 活动期间【沙洲引路人】限时寻访开启，该寻访中以下干员出现率上升\n\n***★★★★★★：多萝西（占6★出率的50%）***\n\n***★★★★★：承曦格雷伊 / 白面鸮（占5★出率的50%）***\n\n**注意：** 本次活动【沙洲引路人】寻访为【标准寻访】\n\n![](https://ak.hycdn.cn/announce/images/20220623/706e4d5ab3f51918694af906aa82c6d1.jpg)\n\n## 三、新干员登场，信赖获取提升\n\n新增干员：\n\n***★★★★★★：多萝西***\n\n***★★★★★：承曦格雷伊***\n\n***★★★★★：星源***\n\n**注意：**\n\n◆新增干员【星源】仅在本次「绿野幻梦」活动中获取。暂不加入【沙洲引路人】及任何【标准寻访】\n\n◆新增干员【多萝西】、【承曦格雷伊】除加入【沙洲引路人】寻访外，将在07月07日04:00后加入并常驻其余【标准寻访】卡池\n\n◆本次活动关卡内以上新增干员信赖获取提升\n\n![](https://ak.hycdn.cn/announce/images/20220623/d7ed9b8d6be5a8be3dea7f494f271ee1.JPG)\n\n## 四、【珊瑚海岸】系列，新装限时上架\n\n**贩售时间：** 07月05日 16:00 - 07月19日 03:59\n\n**活动说明：** 活动期间以下干员新增时装将在时装商店上架并进行限时贩售\n\n***◆珊瑚海岸系列 - “灿阳朝露 SD08” - 卡涅利安***\n\n***◆珊瑚海岸系列 - “悠然假日 HDm04” - 炎客***\n\n***◆珊瑚海岸系列 - “夏卉 FA641” - 夜半***\n\n![](https://ak.hycdn.cn/announce/images/20220623/7be9d3d552ee3b7c9c15eacc2a106c13.JPG)\n\n## 五、【时代】系列，复刻时装限时上架\n\n**贩售时间：** 07月05日 16:00 - 07月19日 03:59\n\n**活动说明：** 活动期间以下干员时装将在时装商店复刻上架并进行限时贩售\n\n***◆时代系列 - “白沙” - 蜜蜡***\n\n***◆时代系列 - “伦式巫女” - 月禾***\n\n***◆时代系列 - “闲适午后” - 调香师***\n\n![](https://ak.hycdn.cn/announce/images/20220623/3b7347a3c357995e53d51a3b93b0015d.JPG)\n\n## 六、新增【莱茵实验培养舱】主题家具，限时获取\n\n**活动说明：** 活动期间新增活动限定家具【莱茵实验培养舱】系列\n\n** 获取方式：**\n\n◆SideStory「绿野幻梦」活动奖励及兑换（部分）\n\n◆家具商店限时售卖（部分）：07月05日 16:00 - 07月19日 03:59\n\n![](https://ak.hycdn.cn/announce/images/20220623/5b8a79110c9be4475c8e5f403cfcd974.JPG)\n\n## 七、芯片礼包限时上架\n\n**售卖时间：** 07月05日 16:00 - 07月19日 03:59\n\n**活动说明：** 活动期间，采购中心将限时售卖以下组合包\n\n**[沙洲引路人芯片礼包]**\n\n组合包内容：特种芯片组\\*8、特种芯片\\*5、龙门币\\*210000\n\n![](https://ak.hycdn.cn/announce/images/20220623/3133601d0d4161fb3c0c25782c23d87f.jpg)\n\n## 八、剿灭作战关卡【盘桓蜀道】追加\n\n**开启时间：** 07月11日 04:00 - 09月05日 03:59\n\n**开启条件：** 所有通关主线2-8的玩家\n\n**关卡说明：** 新增剿灭委托关卡【盘桓蜀道】将替换现有剿灭委托关卡【黑夜锦标秀】，现剿灭委托关卡【黑夜锦标秀】将在关闭后收录进假定作战目标\n\n*更多活动内容请持续关注《明日方舟》游戏内公告及官方公告。*\n\n<p style=\"text-align: right\">【明日方舟】运营组<br />2022年06月29日</p>","categories":[],"tags":[]}]